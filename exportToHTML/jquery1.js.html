<html>
<head>
<title>jquery1.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.ln { color: rgb(0,0,0); font-weight: normal; font-style: normal; }
.s0 { color: rgb(128,128,128); font-style: italic; }
.s1 { color: rgb(0,0,0); }
.s2 { color: rgb(0,0,128); font-weight: bold; }
.s3 { color: rgb(0,128,0); font-weight: bold; }
.s4 { color: rgb(0,0,255); }
.s5 { color: rgb(128,128,128); font-weight: bold; font-style: italic; }
</style>
</head>
<BODY BGCOLOR="#ffffff">
<TABLE CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#C0C0C0" >
<TR><TD><CENTER>
<FONT FACE="Arial, Helvetica" COLOR="#000000">
jquery1.js</FONT>
</center></TD></TR></TABLE>
<pre>
<span class="s0">/** 
 * Created by dingyl on 2017/2/15. 
 */</span><span class="s1"> 
</span><span class="s0">/*! 
 * jQuery JavaScript Library v3.1.1 
 * https://jquery.com/ 
 * 
 * Includes Sizzle.js 
 * https://sizzlejs.com/ 
 * 
 * Copyright jQuery Foundation and other contributors 
 * Released under the MIT license 
 * https://jquery.org/license 
 * 
 * Date: 2016-09-22T22:30Z 
 */</span><span class="s1"> 
( </span><span class="s2">function</span><span class="s1">( global, factory ) { 
 
    </span><span class="s3">&quot;use strict&quot;</span><span class="s1">; 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">module === </span><span class="s3">&quot;object&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">module.exports === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
 
        </span><span class="s0">// For CommonJS and CommonJS-like environments where a proper `window`</span><span class="s1"> 
        </span><span class="s0">// is present, execute the factory and get jQuery.</span><span class="s1"> 
        </span><span class="s0">// For environments that do not have a `window` with a `document`</span><span class="s1"> 
        </span><span class="s0">// (such as Node.js), expose a factory as module.exports.</span><span class="s1"> 
        </span><span class="s0">// This accentuates the need for the creation of a real `window`.</span><span class="s1"> 
        </span><span class="s0">// e.g. var jQuery = require(&quot;jquery&quot;)(window);</span><span class="s1"> 
        </span><span class="s0">// See ticket #14549 for more info.</span><span class="s1"> 
        module.exports = global.document ? 
            factory( global, </span><span class="s2">true </span><span class="s1">) : 
            </span><span class="s2">function</span><span class="s1">( w ) { 
                </span><span class="s2">if </span><span class="s1">( !w.document ) { 
                    </span><span class="s2">throw new </span><span class="s1">Error( </span><span class="s3">&quot;jQuery requires a window with a document&quot; </span><span class="s1">); 
                } 
                </span><span class="s2">return </span><span class="s1">factory( w ); 
            }; 
    } </span><span class="s2">else </span><span class="s1">{ 
        factory( global ); 
    } 
 
</span><span class="s0">// Pass this if window is not defined yet</span><span class="s1"> 
} )( </span><span class="s2">typeof </span><span class="s1">window !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">? window : </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( window, noGlobal ) { 
 
</span><span class="s0">// Edge &lt;= 12 - 13+, Firefox &lt;=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1</span><span class="s1"> 
</span><span class="s0">// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode</span><span class="s1"> 
</span><span class="s0">// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common</span><span class="s1"> 
</span><span class="s0">// enough that all such attempts are guarded in a try block.</span><span class="s1"> 
    </span><span class="s3">&quot;use strict&quot;</span><span class="s1">; 
 
    </span><span class="s2">var </span><span class="s1">arr = []; 
 
    </span><span class="s2">var </span><span class="s1">document = window.document; 
 
    </span><span class="s2">var </span><span class="s1">getProto = Object.getPrototypeOf; 
 
    </span><span class="s2">var </span><span class="s1">slice = arr.slice; 
 
    </span><span class="s2">var </span><span class="s1">concat = arr.concat; 
 
    </span><span class="s2">var </span><span class="s1">push = arr.push; 
 
    </span><span class="s2">var </span><span class="s1">indexOf = arr.indexOf; 
 
    </span><span class="s2">var </span><span class="s1">class2type = {}; 
 
    </span><span class="s2">var </span><span class="s1">toString = class2type.toString; 
 
    </span><span class="s2">var </span><span class="s1">hasOwn = class2type.hasOwnProperty; 
 
    </span><span class="s2">var </span><span class="s1">fnToString = hasOwn.toString; 
 
    </span><span class="s2">var </span><span class="s1">ObjectFunctionString = fnToString.call( Object ); 
 
    </span><span class="s2">var </span><span class="s1">support = {}; 
 
 
 
    </span><span class="s2">function </span><span class="s1">DOMEval( code, doc ) { 
        doc = doc || document; 
 
        </span><span class="s2">var </span><span class="s1">script = doc.createElement( </span><span class="s3">&quot;script&quot; </span><span class="s1">); 
 
        script.text = code; 
        doc.head.appendChild( script ).parentNode.removeChild( script ); 
    } 
    </span><span class="s0">/* global Symbol */</span><span class="s1"> 
</span><span class="s0">// Defining this global in .eslintrc.json would create a danger of using the global</span><span class="s1"> 
</span><span class="s0">// unguarded in another place, it seems safer to define global only for this module</span><span class="s1"> 
 
 
 
    </span><span class="s2">var</span><span class="s1"> 
        version = </span><span class="s3">&quot;3.1.1&quot;</span><span class="s1">, 
 
    </span><span class="s0">// Define a local copy of jQuery</span><span class="s1"> 
        jQuery = </span><span class="s2">function</span><span class="s1">( selector, context ) { 
 
            </span><span class="s0">// The jQuery object is actually just the init constructor 'enhanced'</span><span class="s1"> 
            </span><span class="s0">// Need init if jQuery is called (just allow error to be thrown if not included)</span><span class="s1"> 
            </span><span class="s2">return new </span><span class="s1">jQuery.fn.init( selector, context ); 
        }, 
 
    </span><span class="s0">// Support: Android &lt;=4.0 only</span><span class="s1"> 
    </span><span class="s0">// Make sure we trim BOM and NBSP</span><span class="s1"> 
        rtrim = </span><span class="s4">/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g</span><span class="s1">, 
 
    </span><span class="s0">// Matches dashed string for camelizing</span><span class="s1"> 
        rmsPrefix = </span><span class="s4">/^-ms-/</span><span class="s1">, 
        rdashAlpha = </span><span class="s4">/-([a-z])/g</span><span class="s1">, 
 
    </span><span class="s0">// Used by jQuery.camelCase as callback to replace()</span><span class="s1"> 
        fcamelCase = </span><span class="s2">function</span><span class="s1">( all, letter ) { 
            </span><span class="s2">return </span><span class="s1">letter.toUpperCase(); 
        }; 
 
    jQuery.fn = jQuery.prototype = { 
 
        </span><span class="s0">// The current version of jQuery being used</span><span class="s1"> 
        jquery: version, 
 
        constructor: jQuery, 
 
        </span><span class="s0">// The default length of a jQuery object is 0</span><span class="s1"> 
        length: </span><span class="s4">0</span><span class="s1">, 
 
        toArray: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">slice.call( </span><span class="s2">this </span><span class="s1">); 
        }, 
 
        </span><span class="s0">// Get the Nth element in the matched element set OR</span><span class="s1"> 
        </span><span class="s0">// Get the whole matched element set as a clean array</span><span class="s1"> 
        </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( num ) { 
 
            </span><span class="s0">// Return all the elements in a clean array</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( num == </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">slice.call( </span><span class="s2">this </span><span class="s1">); 
            } 
 
            </span><span class="s0">// Return just the one element from the set</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">num &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s2">this</span><span class="s1">[ num + </span><span class="s2">this</span><span class="s1">.length ] : </span><span class="s2">this</span><span class="s1">[ num ]; 
        }, 
 
        </span><span class="s0">// Take an array of elements and push it onto the stack</span><span class="s1"> 
        </span><span class="s0">// (returning the new matched element set)</span><span class="s1"> 
        pushStack: </span><span class="s2">function</span><span class="s1">( elems ) { 
 
            </span><span class="s0">// Build a new jQuery matched element set</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">ret = jQuery.merge( </span><span class="s2">this</span><span class="s1">.constructor(), elems ); 
 
            </span><span class="s0">// Add the old object onto the stack (as a reference)</span><span class="s1"> 
            ret.prevObject = </span><span class="s2">this</span><span class="s1">; 
 
            </span><span class="s0">// Return the newly-formed element set</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ret; 
        }, 
 
        </span><span class="s0">// Execute a callback for every element in the matched set.</span><span class="s1"> 
        each: </span><span class="s2">function</span><span class="s1">( callback ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.each( </span><span class="s2">this</span><span class="s1">, callback ); 
        }, 
 
        map: </span><span class="s2">function</span><span class="s1">( callback ) { 
            </span><span class="s2">return this</span><span class="s1">.pushStack( jQuery.map( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( elem, i ) { 
                </span><span class="s2">return </span><span class="s1">callback.call( elem, i, elem ); 
            } ) ); 
        }, 
 
        slice: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return this</span><span class="s1">.pushStack( slice.apply( </span><span class="s2">this</span><span class="s1">, arguments ) ); 
        }, 
 
        first: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return this</span><span class="s1">.eq( </span><span class="s4">0 </span><span class="s1">); 
        }, 
 
        last: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return this</span><span class="s1">.eq( -</span><span class="s4">1 </span><span class="s1">); 
        }, 
 
        eq: </span><span class="s2">function</span><span class="s1">( i ) { 
            </span><span class="s2">var </span><span class="s1">len = </span><span class="s2">this</span><span class="s1">.length, 
                j = +i + ( i &lt; </span><span class="s4">0 </span><span class="s1">? len : </span><span class="s4">0 </span><span class="s1">); 
            </span><span class="s2">return this</span><span class="s1">.pushStack( j &gt;= </span><span class="s4">0 </span><span class="s1">&amp;&amp; j &lt; len ? [ </span><span class="s2">this</span><span class="s1">[ j ] ] : [] ); 
        }, 
 
        end: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return this</span><span class="s1">.prevObject || </span><span class="s2">this</span><span class="s1">.constructor(); 
        }, 
 
        </span><span class="s0">// For internal use only.</span><span class="s1"> 
        </span><span class="s0">// Behaves like an Array's method, not like a jQuery method.</span><span class="s1"> 
        push: push, 
        sort: arr.sort, 
        splice: arr.splice 
    }; 
 
    jQuery.extend = jQuery.fn.extend = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">options, name, src, copy, copyIsArray, clone, 
            target = arguments[ </span><span class="s4">0 </span><span class="s1">] || {}, 
            i = </span><span class="s4">1</span><span class="s1">, 
            length = arguments.length, 
            deep = </span><span class="s2">false</span><span class="s1">; 
 
        </span><span class="s0">// Handle a deep copy situation</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">target === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">) { 
            deep = target; 
 
            </span><span class="s0">// Skip the boolean and the target</span><span class="s1"> 
            target = arguments[ i ] || {}; 
            i++; 
        } 
 
        </span><span class="s0">// Handle case when target is a string or something (possible in deep copy)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">target !== </span><span class="s3">&quot;object&quot; </span><span class="s1">&amp;&amp; !jQuery.isFunction( target ) ) { 
            target = {}; 
        } 
 
        </span><span class="s0">// Extend jQuery itself if only one argument is passed</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( i === length ) { 
            target = </span><span class="s2">this</span><span class="s1">; 
            i--; 
        } 
 
        </span><span class="s2">for </span><span class="s1">( ; i &lt; length; i++ ) { 
 
            </span><span class="s0">// Only deal with non-null/undefined values</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( ( options = arguments[ i ] ) != </span><span class="s2">null </span><span class="s1">) { 
 
                </span><span class="s0">// Extend the base object</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">options ) { 
                    src = target[ name ]; 
                    copy = options[ name ]; 
 
                    </span><span class="s0">// Prevent never-ending loop</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( target === copy ) { 
                        </span><span class="s2">continue</span><span class="s1">; 
                    } 
 
                    </span><span class="s0">// Recurse if we're merging plain objects or arrays</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( deep &amp;&amp; copy &amp;&amp; ( jQuery.isPlainObject( copy ) || 
                        ( copyIsArray = jQuery.isArray( copy ) ) ) ) { 
 
                        </span><span class="s2">if </span><span class="s1">( copyIsArray ) { 
                            copyIsArray = </span><span class="s2">false</span><span class="s1">; 
                            clone = src &amp;&amp; jQuery.isArray( src ) ? src : []; 
 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            clone = src &amp;&amp; jQuery.isPlainObject( src ) ? src : {}; 
                        } 
 
                        </span><span class="s0">// Never move original objects, clone them</span><span class="s1"> 
                        target[ name ] = jQuery.extend( deep, clone, copy ); 
 
                        </span><span class="s0">// Don't bring in undefined values</span><span class="s1"> 
                    } </span><span class="s2">else if </span><span class="s1">( copy !== undefined ) { 
                        target[ name ] = copy; 
                    } 
                } 
            } 
        } 
 
        </span><span class="s0">// Return the modified object</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">target; 
    }; 
 
    jQuery.extend( { 
 
        </span><span class="s0">// Unique for each copy of jQuery on the page</span><span class="s1"> 
        expando: </span><span class="s3">&quot;jQuery&quot; </span><span class="s1">+ ( version + Math.random() ).replace( </span><span class="s4">/\D/g</span><span class="s1">, </span><span class="s3">&quot;&quot; </span><span class="s1">), 
 
        </span><span class="s0">// Assume jQuery is ready without the ready module</span><span class="s1"> 
        isReady: </span><span class="s2">true</span><span class="s1">, 
 
        error: </span><span class="s2">function</span><span class="s1">( msg ) { 
            </span><span class="s2">throw new </span><span class="s1">Error( msg ); 
        }, 
 
        noop: </span><span class="s2">function</span><span class="s1">() {}, 
 
        isFunction: </span><span class="s2">function</span><span class="s1">( obj ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.type( obj ) === </span><span class="s3">&quot;function&quot;</span><span class="s1">; 
        }, 
 
        isArray: Array.isArray, 
 
        isWindow: </span><span class="s2">function</span><span class="s1">( obj ) { 
            </span><span class="s2">return </span><span class="s1">obj != </span><span class="s2">null </span><span class="s1">&amp;&amp; obj === obj.window; 
        }, 
 
        isNumeric: </span><span class="s2">function</span><span class="s1">( obj ) { 
 
            </span><span class="s0">// As of jQuery 3.0, isNumeric is limited to</span><span class="s1"> 
            </span><span class="s0">// strings and numbers (primitives or objects)</span><span class="s1"> 
            </span><span class="s0">// that can be coerced to finite numbers (gh-2662)</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">type = jQuery.type( obj ); 
            </span><span class="s2">return </span><span class="s1">( type === </span><span class="s3">&quot;number&quot; </span><span class="s1">|| type === </span><span class="s3">&quot;string&quot; </span><span class="s1">) &amp;&amp; 
 
                    </span><span class="s0">// parseFloat NaNs numeric-cast false positives (&quot;&quot;)</span><span class="s1"> 
                    </span><span class="s0">// ...but misinterprets leading-number strings, particularly hex literals (&quot;0x...&quot;)</span><span class="s1"> 
                    </span><span class="s0">// subtraction forces infinities to NaN</span><span class="s1"> 
                !isNaN( obj - parseFloat( obj ) ); 
        }, 
 
        isPlainObject: </span><span class="s2">function</span><span class="s1">( obj ) { 
            </span><span class="s2">var </span><span class="s1">proto, Ctor; 
 
            </span><span class="s0">// Detect obvious negatives</span><span class="s1"> 
            </span><span class="s0">// Use toString instead of jQuery.type to catch host objects</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !obj || toString.call( obj ) !== </span><span class="s3">&quot;[object Object]&quot; </span><span class="s1">) { 
                </span><span class="s2">return false</span><span class="s1">; 
            } 
 
            proto = getProto( obj ); 
 
            </span><span class="s0">// Objects with no prototype (e.g., `Object.create( null )`) are plain</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !proto ) { 
                </span><span class="s2">return true</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Objects with prototype are plain iff they were constructed by a global Object function</span><span class="s1"> 
            Ctor = hasOwn.call( proto, </span><span class="s3">&quot;constructor&quot; </span><span class="s1">) &amp;&amp; proto.constructor; 
            </span><span class="s2">return typeof </span><span class="s1">Ctor === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp; fnToString.call( Ctor ) === ObjectFunctionString; 
        }, 
 
        isEmptyObject: </span><span class="s2">function</span><span class="s1">( obj ) { 
 
            </span><span class="s0">/* eslint-disable no-unused-vars */</span><span class="s1"> 
            </span><span class="s0">// See https://github.com/eslint/eslint/issues/6125</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">name; 
 
            </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">obj ) { 
                </span><span class="s2">return false</span><span class="s1">; 
            } 
            </span><span class="s2">return true</span><span class="s1">; 
        }, 
 
        type: </span><span class="s2">function</span><span class="s1">( obj ) { 
            </span><span class="s2">if </span><span class="s1">( obj == </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">obj + </span><span class="s3">&quot;&quot;</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Support: Android &lt;=2.3 only (functionish RegExp)</span><span class="s1"> 
            </span><span class="s2">return typeof </span><span class="s1">obj === </span><span class="s3">&quot;object&quot; </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">obj === </span><span class="s3">&quot;function&quot; </span><span class="s1">? 
            class2type[ toString.call( obj ) ] || </span><span class="s3">&quot;object&quot; </span><span class="s1">: 
                </span><span class="s2">typeof </span><span class="s1">obj; 
        }, 
 
        </span><span class="s0">// Evaluates a script in a global context</span><span class="s1"> 
        globalEval: </span><span class="s2">function</span><span class="s1">( code ) { 
            DOMEval( code ); 
        }, 
 
        </span><span class="s0">// Convert dashed to camelCase; used by the css and data modules</span><span class="s1"> 
        </span><span class="s0">// Support: IE &lt;=9 - 11, Edge 12 - 13</span><span class="s1"> 
        </span><span class="s0">// Microsoft forgot to hump their vendor prefix (#9572)</span><span class="s1"> 
        camelCase: </span><span class="s2">function</span><span class="s1">( string ) { 
            </span><span class="s2">return </span><span class="s1">string.replace( rmsPrefix, </span><span class="s3">&quot;ms-&quot; </span><span class="s1">).replace( rdashAlpha, fcamelCase ); 
        }, 
 
        nodeName: </span><span class="s2">function</span><span class="s1">( elem, name ) { 
            </span><span class="s2">return </span><span class="s1">elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === name.toLowerCase(); 
        }, 
 
        each: </span><span class="s2">function</span><span class="s1">( obj, callback ) { 
            </span><span class="s2">var </span><span class="s1">length, i = </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s2">if </span><span class="s1">( isArrayLike( obj ) ) { 
                length = obj.length; 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; length; i++ ) { 
                    </span><span class="s2">if </span><span class="s1">( callback.call( obj[ i ], i, obj[ i ] ) === </span><span class="s2">false </span><span class="s1">) { 
                        </span><span class="s2">break</span><span class="s1">; 
                    } 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">obj ) { 
                    </span><span class="s2">if </span><span class="s1">( callback.call( obj[ i ], i, obj[ i ] ) === </span><span class="s2">false </span><span class="s1">) { 
                        </span><span class="s2">break</span><span class="s1">; 
                    } 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">obj; 
        }, 
 
        </span><span class="s0">// Support: Android &lt;=4.0 only</span><span class="s1"> 
        trim: </span><span class="s2">function</span><span class="s1">( text ) { 
            </span><span class="s2">return </span><span class="s1">text == </span><span class="s2">null </span><span class="s1">? 
                </span><span class="s3">&quot;&quot; </span><span class="s1">: 
                ( text + </span><span class="s3">&quot;&quot; </span><span class="s1">).replace( rtrim, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
        }, 
 
        </span><span class="s0">// results is for internal usage only</span><span class="s1"> 
        makeArray: </span><span class="s2">function</span><span class="s1">( arr, results ) { 
            </span><span class="s2">var </span><span class="s1">ret = results || []; 
 
            </span><span class="s2">if </span><span class="s1">( arr != </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( isArrayLike( Object( arr ) ) ) { 
                    jQuery.merge( ret, 
                        </span><span class="s2">typeof </span><span class="s1">arr === </span><span class="s3">&quot;string&quot; </span><span class="s1">? 
                            [ arr ] : arr 
                    ); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    push.call( ret, arr ); 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">ret; 
        }, 
 
        inArray: </span><span class="s2">function</span><span class="s1">( elem, arr, i ) { 
            </span><span class="s2">return </span><span class="s1">arr == </span><span class="s2">null </span><span class="s1">? -</span><span class="s4">1 </span><span class="s1">: indexOf.call( arr, elem, i ); 
        }, 
 
        </span><span class="s0">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span><span class="s1"> 
        </span><span class="s0">// push.apply(_, arraylike) throws on ancient WebKit</span><span class="s1"> 
        merge: </span><span class="s2">function</span><span class="s1">( first, second ) { 
            </span><span class="s2">var </span><span class="s1">len = +second.length, 
                j = </span><span class="s4">0</span><span class="s1">, 
                i = first.length; 
 
            </span><span class="s2">for </span><span class="s1">( ; j &lt; len; j++ ) { 
                first[ i++ ] = second[ j ]; 
            } 
 
            first.length = i; 
 
            </span><span class="s2">return </span><span class="s1">first; 
        }, 
 
        grep: </span><span class="s2">function</span><span class="s1">( elems, callback, invert ) { 
            </span><span class="s2">var </span><span class="s1">callbackInverse, 
                matches = [], 
                i = </span><span class="s4">0</span><span class="s1">, 
                length = elems.length, 
                callbackExpect = !invert; 
 
            </span><span class="s0">// Go through the array, only saving the items</span><span class="s1"> 
            </span><span class="s0">// that pass the validator function</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( ; i &lt; length; i++ ) { 
                callbackInverse = !callback( elems[ i ], i ); 
                </span><span class="s2">if </span><span class="s1">( callbackInverse !== callbackExpect ) { 
                    matches.push( elems[ i ] ); 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">matches; 
        }, 
 
        </span><span class="s0">// arg is for internal usage only</span><span class="s1"> 
        map: </span><span class="s2">function</span><span class="s1">( elems, callback, arg ) { 
            </span><span class="s2">var </span><span class="s1">length, value, 
                i = </span><span class="s4">0</span><span class="s1">, 
                ret = []; 
 
            </span><span class="s0">// Go through the array, translating each of the items to their new values</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( isArrayLike( elems ) ) { 
                length = elems.length; 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; length; i++ ) { 
                    value = callback( elems[ i ], i, arg ); 
 
                    </span><span class="s2">if </span><span class="s1">( value != </span><span class="s2">null </span><span class="s1">) { 
                        ret.push( value ); 
                    } 
                } 
 
                </span><span class="s0">// Go through every key on the object,</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">elems ) { 
                    value = callback( elems[ i ], i, arg ); 
 
                    </span><span class="s2">if </span><span class="s1">( value != </span><span class="s2">null </span><span class="s1">) { 
                        ret.push( value ); 
                    } 
                } 
            } 
 
            </span><span class="s0">// Flatten any nested arrays</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">concat.apply( [], ret ); 
        }, 
 
        </span><span class="s0">// A global GUID counter for objects</span><span class="s1"> 
        guid: </span><span class="s4">1</span><span class="s1">, 
 
        </span><span class="s0">// Bind a function to a context, optionally partially applying any</span><span class="s1"> 
        </span><span class="s0">// arguments.</span><span class="s1"> 
        proxy: </span><span class="s2">function</span><span class="s1">( fn, context ) { 
            </span><span class="s2">var </span><span class="s1">tmp, args, proxy; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                tmp = fn[ context ]; 
                context = fn; 
                fn = tmp; 
            } 
 
            </span><span class="s0">// Quick check to determine if target is callable, in the spec</span><span class="s1"> 
            </span><span class="s0">// this throws a TypeError, but we will just return undefined.</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !jQuery.isFunction( fn ) ) { 
                </span><span class="s2">return </span><span class="s1">undefined; 
            } 
 
            </span><span class="s0">// Simulated bind</span><span class="s1"> 
            args = slice.call( arguments, </span><span class="s4">2 </span><span class="s1">); 
            proxy = </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">return </span><span class="s1">fn.apply( context || </span><span class="s2">this</span><span class="s1">, args.concat( slice.call( arguments ) ) ); 
            }; 
 
            </span><span class="s0">// Set the guid of unique handler to the same of original handler, so it can be removed</span><span class="s1"> 
            proxy.guid = fn.guid = fn.guid || jQuery.guid++; 
 
            </span><span class="s2">return </span><span class="s1">proxy; 
        }, 
 
        now: Date.now, 
 
        </span><span class="s0">// jQuery.support is not used in Core but other projects attach their</span><span class="s1"> 
        </span><span class="s0">// properties to it so it needs to exist.</span><span class="s1"> 
        support: support 
    } ); 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">Symbol === </span><span class="s3">&quot;function&quot; </span><span class="s1">) { 
        jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ]; 
    } 
 
</span><span class="s0">// Populate the class2type map</span><span class="s1"> 
    jQuery.each( </span><span class="s3">&quot;Boolean Number String Function Array Date RegExp Object Error Symbol&quot;</span><span class="s1">.split( </span><span class="s3">&quot; &quot; </span><span class="s1">), 
        </span><span class="s2">function</span><span class="s1">( i, name ) { 
            class2type[ </span><span class="s3">&quot;[object &quot; </span><span class="s1">+ name + </span><span class="s3">&quot;]&quot; </span><span class="s1">] = name.toLowerCase(); 
        } ); 
 
    </span><span class="s2">function </span><span class="s1">isArrayLike( obj ) { 
 
        </span><span class="s0">// Support: real iOS 8.2 only (not reproducible in simulator)</span><span class="s1"> 
        </span><span class="s0">// `in` check used to prevent JIT error (gh-2145)</span><span class="s1"> 
        </span><span class="s0">// hasOwn isn't used here due to false negatives</span><span class="s1"> 
        </span><span class="s0">// regarding Nodelist length in IE</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">length = !!obj &amp;&amp; </span><span class="s3">&quot;length&quot; </span><span class="s2">in </span><span class="s1">obj &amp;&amp; obj.length, 
            type = jQuery.type( obj ); 
 
        </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;function&quot; </span><span class="s1">|| jQuery.isWindow( obj ) ) { 
            </span><span class="s2">return false</span><span class="s1">; 
        } 
 
        </span><span class="s2">return </span><span class="s1">type === </span><span class="s3">&quot;array&quot; </span><span class="s1">|| length === </span><span class="s4">0 </span><span class="s1">|| 
            </span><span class="s2">typeof </span><span class="s1">length === </span><span class="s3">&quot;number&quot; </span><span class="s1">&amp;&amp; length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; ( length - </span><span class="s4">1 </span><span class="s1">) </span><span class="s2">in </span><span class="s1">obj; 
    } 
    </span><span class="s2">var </span><span class="s1">Sizzle = 
        </span><span class="s0">/*! 
         * Sizzle CSS Selector Engine v2.3.3 
         * https://sizzlejs.com/ 
         * 
         * Copyright jQuery Foundation and other contributors 
         * Released under the MIT license 
         * http://jquery.org/license 
         * 
         * Date: 2016-08-08 
         */</span><span class="s1"> 
        (</span><span class="s2">function</span><span class="s1">( window ) { 
 
            </span><span class="s2">var </span><span class="s1">i, 
                support, 
                Expr, 
                getText, 
                isXML, 
                tokenize, 
                compile, 
                select, 
                outermostContext, 
                sortInput, 
                hasDuplicate, 
 
            </span><span class="s0">// Local document vars</span><span class="s1"> 
                setDocument, 
                document, 
                docElem, 
                documentIsHTML, 
                rbuggyQSA, 
                rbuggyMatches, 
                matches, 
                contains, 
 
            </span><span class="s0">// Instance-specific data</span><span class="s1"> 
                expando = </span><span class="s3">&quot;sizzle&quot; </span><span class="s1">+ </span><span class="s4">1 </span><span class="s1">* </span><span class="s2">new </span><span class="s1">Date(), 
                preferredDoc = window.document, 
                dirruns = </span><span class="s4">0</span><span class="s1">, 
                done = </span><span class="s4">0</span><span class="s1">, 
                classCache = createCache(), 
                tokenCache = createCache(), 
                compilerCache = createCache(), 
                sortOrder = </span><span class="s2">function</span><span class="s1">( a, b ) { 
                    </span><span class="s2">if </span><span class="s1">( a === b ) { 
                        hasDuplicate = </span><span class="s2">true</span><span class="s1">; 
                    } 
                    </span><span class="s2">return </span><span class="s4">0</span><span class="s1">; 
                }, 
 
            </span><span class="s0">// Instance methods</span><span class="s1"> 
                hasOwn = ({}).hasOwnProperty, 
                arr = [], 
                pop = arr.pop, 
                push_native = arr.push, 
                push = arr.push, 
                slice = arr.slice, 
            </span><span class="s0">// Use a stripped-down indexOf as it's faster than native</span><span class="s1"> 
            </span><span class="s0">// https://jsperf.com/thor-indexof-vs-for/5</span><span class="s1"> 
                indexOf = </span><span class="s2">function</span><span class="s1">( list, elem ) { 
                    </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, 
                        len = list.length; 
                    </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                        </span><span class="s2">if </span><span class="s1">( list[i] === elem ) { 
                            </span><span class="s2">return </span><span class="s1">i; 
                        } 
                    } 
                    </span><span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">; 
                }, 
 
                booleans = </span><span class="s3">&quot;checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped&quot;</span><span class="s1">, 
 
            </span><span class="s0">// Regular expressions</span><span class="s1"> 
 
            </span><span class="s0">// http://www.w3.org/TR/css3-selectors/#whitespace</span><span class="s1"> 
                whitespace = </span><span class="s3">&quot;[</span><span class="s2">\\</span><span class="s3">x20</span><span class="s2">\\</span><span class="s3">t</span><span class="s2">\\</span><span class="s3">r</span><span class="s2">\\</span><span class="s3">n</span><span class="s2">\\</span><span class="s3">f]&quot;</span><span class="s1">, 
 
            </span><span class="s0">// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier</span><span class="s1"> 
                identifier = </span><span class="s3">&quot;(?:</span><span class="s2">\\\\</span><span class="s3">.|[</span><span class="s2">\\</span><span class="s3">w-]|[^</span><span class="s2">\0</span><span class="s3">-</span><span class="s2">\\</span><span class="s3">xa0])+&quot;</span><span class="s1">, 
 
            </span><span class="s0">// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors</span><span class="s1"> 
                attributes = </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">[&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*(&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;)(?:&quot; </span><span class="s1">+ whitespace + 
                        </span><span class="s0">// Operator (capture 2)</span><span class="s1"> 
                    </span><span class="s3">&quot;*([*^$|!~]?=)&quot; </span><span class="s1">+ whitespace + 
                        </span><span class="s0">// &quot;Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]&quot;</span><span class="s1"> 
                    </span><span class="s3">&quot;*(?:'((?:</span><span class="s2">\\\\</span><span class="s3">.|[^</span><span class="s2">\\\\</span><span class="s3">'])*)'|</span><span class="s2">\&quot;</span><span class="s3">((?:</span><span class="s2">\\\\</span><span class="s3">.|[^</span><span class="s2">\\\\\&quot;</span><span class="s3">])*)</span><span class="s2">\&quot;</span><span class="s3">|(&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;))|)&quot; </span><span class="s1">+ whitespace + 
                    </span><span class="s3">&quot;*</span><span class="s2">\\</span><span class="s3">]&quot;</span><span class="s1">, 
 
                pseudos = </span><span class="s3">&quot;:(&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;)(?:</span><span class="s2">\\</span><span class="s3">((&quot; </span><span class="s1">+ 
                        </span><span class="s0">// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:</span><span class="s1"> 
                        </span><span class="s0">// 1. quoted (capture 3; capture 4 or capture 5)</span><span class="s1"> 
                    </span><span class="s3">&quot;('((?:</span><span class="s2">\\\\</span><span class="s3">.|[^</span><span class="s2">\\\\</span><span class="s3">'])*)'|</span><span class="s2">\&quot;</span><span class="s3">((?:</span><span class="s2">\\\\</span><span class="s3">.|[^</span><span class="s2">\\\\\&quot;</span><span class="s3">])*)</span><span class="s2">\&quot;</span><span class="s3">)|&quot; </span><span class="s1">+ 
                        </span><span class="s0">// 2. simple (capture 6)</span><span class="s1"> 
                    </span><span class="s3">&quot;((?:</span><span class="s2">\\\\</span><span class="s3">.|[^</span><span class="s2">\\\\</span><span class="s3">()[</span><span class="s2">\\</span><span class="s3">]]|&quot; </span><span class="s1">+ attributes + </span><span class="s3">&quot;)*)|&quot; </span><span class="s1">+ 
                        </span><span class="s0">// 3. anything else (capture 2)</span><span class="s1"> 
                    </span><span class="s3">&quot;.*&quot; </span><span class="s1">+ 
                    </span><span class="s3">&quot;)</span><span class="s2">\\</span><span class="s3">)|)&quot;</span><span class="s1">, 
 
            </span><span class="s0">// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter</span><span class="s1"> 
                rwhitespace = </span><span class="s2">new </span><span class="s1">RegExp( whitespace + </span><span class="s3">&quot;+&quot;</span><span class="s1">, </span><span class="s3">&quot;g&quot; </span><span class="s1">), 
                rtrim = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;+|((?:^|[^</span><span class="s2">\\\\</span><span class="s3">])(?:</span><span class="s2">\\\\</span><span class="s3">.)*)&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;+$&quot;</span><span class="s1">, </span><span class="s3">&quot;g&quot; </span><span class="s1">), 
 
                rcomma = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*,&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*&quot; </span><span class="s1">), 
                rcombinators = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*([&gt;+~]|&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*&quot; </span><span class="s1">), 
 
                rattributeQuotes = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;=&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*([^</span><span class="s2">\\</span><span class="s3">]'</span><span class="s2">\&quot;</span><span class="s3">]*?)&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*</span><span class="s2">\\</span><span class="s3">]&quot;</span><span class="s1">, </span><span class="s3">&quot;g&quot; </span><span class="s1">), 
 
                rpseudo = </span><span class="s2">new </span><span class="s1">RegExp( pseudos ), 
                ridentifier = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;$&quot; </span><span class="s1">), 
 
                matchExpr = { 
                    </span><span class="s3">&quot;ID&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^#(&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;)&quot; </span><span class="s1">), 
                    </span><span class="s3">&quot;CLASS&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^</span><span class="s2">\\</span><span class="s3">.(&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;)&quot; </span><span class="s1">), 
                    </span><span class="s3">&quot;TAG&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^(&quot; </span><span class="s1">+ identifier + </span><span class="s3">&quot;|[*])&quot; </span><span class="s1">), 
                    </span><span class="s3">&quot;ATTR&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ attributes ), 
                    </span><span class="s3">&quot;PSEUDO&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ pseudos ), 
                    </span><span class="s3">&quot;CHILD&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^:(only|first|last|nth|nth-last)-(child|of-type)(?:</span><span class="s2">\\</span><span class="s3">(&quot; </span><span class="s1">+ whitespace + 
                        </span><span class="s3">&quot;*(even|odd|(([+-]|)(</span><span class="s2">\\</span><span class="s3">d*)n|)&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*(?:([+-]|)&quot; </span><span class="s1">+ whitespace + 
                        </span><span class="s3">&quot;*(</span><span class="s2">\\</span><span class="s3">d+)|))&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*</span><span class="s2">\\</span><span class="s3">)|)&quot;</span><span class="s1">, </span><span class="s3">&quot;i&quot; </span><span class="s1">), 
                    </span><span class="s3">&quot;bool&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^(?:&quot; </span><span class="s1">+ booleans + </span><span class="s3">&quot;)$&quot;</span><span class="s1">, </span><span class="s3">&quot;i&quot; </span><span class="s1">), 
                    </span><span class="s0">// For use in libraries implementing .is()</span><span class="s1"> 
                    </span><span class="s0">// We use this for POS matching in `select`</span><span class="s1"> 
                    </span><span class="s3">&quot;needsContext&quot;</span><span class="s1">: </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*[&gt;+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:</span><span class="s2">\\</span><span class="s3">(&quot; </span><span class="s1">+ 
                        whitespace + </span><span class="s3">&quot;*((?:-</span><span class="s2">\\</span><span class="s3">d)?</span><span class="s2">\\</span><span class="s3">d*)&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*</span><span class="s2">\\</span><span class="s3">)|)(?=[^-]|$)&quot;</span><span class="s1">, </span><span class="s3">&quot;i&quot; </span><span class="s1">) 
                }, 
 
                rinputs = </span><span class="s4">/^(?:input|select|textarea|button)$/i</span><span class="s1">, 
                rheader = </span><span class="s4">/^h\d$/i</span><span class="s1">, 
 
                rnative = </span><span class="s4">/^[^{]+\{\s*\[native \w/</span><span class="s1">, 
 
            </span><span class="s0">// Easily-parseable/retrievable ID or TAG or CLASS selectors</span><span class="s1"> 
                rquickExpr = </span><span class="s4">/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/</span><span class="s1">, 
 
                rsibling = </span><span class="s4">/[+~]/</span><span class="s1">, 
 
            </span><span class="s0">// CSS escapes</span><span class="s1"> 
            </span><span class="s0">// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters</span><span class="s1"> 
                runescape = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;</span><span class="s2">\\\\</span><span class="s3">([</span><span class="s2">\\</span><span class="s3">da-f]{1,6}&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;?|(&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;)|.)&quot;</span><span class="s1">, </span><span class="s3">&quot;ig&quot; </span><span class="s1">), 
                funescape = </span><span class="s2">function</span><span class="s1">( _, escaped, escapedWhitespace ) { 
                    </span><span class="s2">var </span><span class="s1">high = </span><span class="s3">&quot;0x&quot; </span><span class="s1">+ escaped - </span><span class="s4">0x10000</span><span class="s1">; 
                    </span><span class="s0">// NaN means non-codepoint</span><span class="s1"> 
                    </span><span class="s0">// Support: Firefox&lt;24</span><span class="s1"> 
                    </span><span class="s0">// Workaround erroneous numeric interpretation of +&quot;0x&quot;</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">high !== high || escapedWhitespace ? 
                        escaped : 
                        high &lt; </span><span class="s4">0 </span><span class="s1">? 
                            </span><span class="s0">// BMP codepoint</span><span class="s1"> 
                            String.fromCharCode( high + </span><span class="s4">0x10000 </span><span class="s1">) : 
                            </span><span class="s0">// Supplemental Plane codepoint (surrogate pair)</span><span class="s1"> 
                            String.fromCharCode( high &gt;&gt; </span><span class="s4">10 </span><span class="s1">| </span><span class="s4">0xD800</span><span class="s1">, high &amp; </span><span class="s4">0x3FF </span><span class="s1">| </span><span class="s4">0xDC00 </span><span class="s1">); 
                }, 
 
            </span><span class="s0">// CSS string/identifier serialization</span><span class="s1"> 
            </span><span class="s0">// https://drafts.csswg.org/cssom/#common-serializing-idioms</span><span class="s1"> 
                rcssescape = </span><span class="s4">/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g</span><span class="s1">, 
                fcssescape = </span><span class="s2">function</span><span class="s1">( ch, asCodePoint ) { 
                    </span><span class="s2">if </span><span class="s1">( asCodePoint ) { 
 
                        </span><span class="s0">// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( ch === </span><span class="s3">&quot;</span><span class="s2">\0</span><span class="s3">&quot; </span><span class="s1">) { 
                            </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\uFFFD</span><span class="s3">&quot;</span><span class="s1">; 
                        } 
 
                        </span><span class="s0">// Control characters and (dependent upon position) numbers get escaped as code points</span><span class="s1"> 
                        </span><span class="s2">return </span><span class="s1">ch.slice( </span><span class="s4">0</span><span class="s1">, -</span><span class="s4">1 </span><span class="s1">) + </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot; </span><span class="s1">+ ch.charCodeAt( ch.length - </span><span class="s4">1 </span><span class="s1">).toString( </span><span class="s4">16 </span><span class="s1">) + </span><span class="s3">&quot; &quot;</span><span class="s1">; 
                    } 
 
                    </span><span class="s0">// Other potentially-special ASCII characters get backslash-escaped</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot; </span><span class="s1">+ ch; 
                }, 
 
            </span><span class="s0">// Used for iframes</span><span class="s1"> 
            </span><span class="s0">// See setDocument()</span><span class="s1"> 
            </span><span class="s0">// Removing the function wrapper causes a &quot;Permission Denied&quot;</span><span class="s1"> 
            </span><span class="s0">// error in IE</span><span class="s1"> 
                unloadHandler = </span><span class="s2">function</span><span class="s1">() { 
                    setDocument(); 
                }, 
 
                disabledAncestor = addCombinator( 
                    </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">elem.disabled === </span><span class="s2">true </span><span class="s1">&amp;&amp; (</span><span class="s3">&quot;form&quot; </span><span class="s2">in </span><span class="s1">elem || </span><span class="s3">&quot;label&quot; </span><span class="s2">in </span><span class="s1">elem); 
                    }, 
                    { dir: </span><span class="s3">&quot;parentNode&quot;</span><span class="s1">, next: </span><span class="s3">&quot;legend&quot; </span><span class="s1">} 
                ); 
 
</span><span class="s0">// Optimize for push.apply( _, NodeList )</span><span class="s1"> 
            </span><span class="s2">try </span><span class="s1">{ 
                push.apply( 
                    (arr = slice.call( preferredDoc.childNodes )), 
                    preferredDoc.childNodes 
                ); 
                </span><span class="s0">// Support: Android&lt;4.0</span><span class="s1"> 
                </span><span class="s0">// Detect silently failing push.apply</span><span class="s1"> 
                arr[ preferredDoc.childNodes.length ].nodeType; 
            } </span><span class="s2">catch </span><span class="s1">( e ) { 
                push = { apply: arr.length ? 
 
                    </span><span class="s0">// Leverage slice if possible</span><span class="s1"> 
                    </span><span class="s2">function</span><span class="s1">( target, els ) { 
                        push_native.apply( target, slice.call(els) ); 
                    } : 
 
                    </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
                    </span><span class="s0">// Otherwise append directly</span><span class="s1"> 
                    </span><span class="s2">function</span><span class="s1">( target, els ) { 
                        </span><span class="s2">var </span><span class="s1">j = target.length, 
                            i = </span><span class="s4">0</span><span class="s1">; 
                        </span><span class="s0">// Can't trust NodeList.length</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( (target[j++] = els[i++]) ) {} 
                        target.length = j - </span><span class="s4">1</span><span class="s1">; 
                    } 
                }; 
            } 
 
            </span><span class="s2">function </span><span class="s1">Sizzle( selector, context, results, seed ) { 
                </span><span class="s2">var </span><span class="s1">m, i, elem, nid, match, groups, newSelector, 
                    newContext = context &amp;&amp; context.ownerDocument, 
 
                </span><span class="s0">// nodeType defaults to 9, since context defaults to document</span><span class="s1"> 
                    nodeType = context ? context.nodeType : </span><span class="s4">9</span><span class="s1">; 
 
                results = results || []; 
 
                </span><span class="s0">// Return early from calls with invalid selector or context</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector !== </span><span class="s3">&quot;string&quot; </span><span class="s1">|| !selector || 
                    nodeType !== </span><span class="s4">1 </span><span class="s1">&amp;&amp; nodeType !== </span><span class="s4">9 </span><span class="s1">&amp;&amp; nodeType !== </span><span class="s4">11 </span><span class="s1">) { 
 
                    </span><span class="s2">return </span><span class="s1">results; 
                } 
 
                </span><span class="s0">// Try to shortcut find operations (as opposed to filters) in HTML documents</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !seed ) { 
 
                    </span><span class="s2">if </span><span class="s1">( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) { 
                        setDocument( context ); 
                    } 
                    context = context || document; 
 
                    </span><span class="s2">if </span><span class="s1">( documentIsHTML ) { 
 
                        </span><span class="s0">// If the selector is sufficiently simple, try using a &quot;get*By*&quot; DOM method</span><span class="s1"> 
                        </span><span class="s0">// (excepting DocumentFragment context, where the methods don't exist)</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( nodeType !== </span><span class="s4">11 </span><span class="s1">&amp;&amp; (match = rquickExpr.exec( selector )) ) { 
 
                            </span><span class="s0">// ID selector</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( (m = match[</span><span class="s4">1</span><span class="s1">]) ) { 
 
                                </span><span class="s0">// Document context</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( nodeType === </span><span class="s4">9 </span><span class="s1">) { 
                                    </span><span class="s2">if </span><span class="s1">( (elem = context.getElementById( m )) ) { 
 
                                        </span><span class="s0">// Support: IE, Opera, Webkit</span><span class="s1"> 
                                        </span><span class="s0">// TODO: identify versions</span><span class="s1"> 
                                        </span><span class="s0">// getElementById can match elements by name instead of ID</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( elem.id === m ) { 
                                            results.push( elem ); 
                                            </span><span class="s2">return </span><span class="s1">results; 
                                        } 
                                    } </span><span class="s2">else </span><span class="s1">{ 
                                        </span><span class="s2">return </span><span class="s1">results; 
                                    } 
 
                                    </span><span class="s0">// Element context</span><span class="s1"> 
                                } </span><span class="s2">else </span><span class="s1">{ 
 
                                    </span><span class="s0">// Support: IE, Opera, Webkit</span><span class="s1"> 
                                    </span><span class="s0">// TODO: identify versions</span><span class="s1"> 
                                    </span><span class="s0">// getElementById can match elements by name instead of ID</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( newContext &amp;&amp; (elem = newContext.getElementById( m )) &amp;&amp; 
                                        contains( context, elem ) &amp;&amp; 
                                        elem.id === m ) { 
 
                                        results.push( elem ); 
                                        </span><span class="s2">return </span><span class="s1">results; 
                                    } 
                                } 
 
                                </span><span class="s0">// Type selector</span><span class="s1"> 
                            } </span><span class="s2">else if </span><span class="s1">( match[</span><span class="s4">2</span><span class="s1">] ) { 
                                push.apply( results, context.getElementsByTagName( selector ) ); 
                                </span><span class="s2">return </span><span class="s1">results; 
 
                                </span><span class="s0">// Class selector</span><span class="s1"> 
                            } </span><span class="s2">else if </span><span class="s1">( (m = match[</span><span class="s4">3</span><span class="s1">]) &amp;&amp; support.getElementsByClassName &amp;&amp; 
                                context.getElementsByClassName ) { 
 
                                push.apply( results, context.getElementsByClassName( m ) ); 
                                </span><span class="s2">return </span><span class="s1">results; 
                            } 
                        } 
 
                        </span><span class="s0">// Take advantage of querySelectorAll</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( support.qsa &amp;&amp; 
                            !compilerCache[ selector + </span><span class="s3">&quot; &quot; </span><span class="s1">] &amp;&amp; 
                            (!rbuggyQSA || !rbuggyQSA.test( selector )) ) { 
 
                            </span><span class="s2">if </span><span class="s1">( nodeType !== </span><span class="s4">1 </span><span class="s1">) { 
                                newContext = context; 
                                newSelector = selector; 
 
                                </span><span class="s0">// qSA looks outside Element context, which is not what we want</span><span class="s1"> 
                                </span><span class="s0">// Thanks to Andrew Dupont for this workaround technique</span><span class="s1"> 
                                </span><span class="s0">// Support: IE &lt;=8</span><span class="s1"> 
                                </span><span class="s0">// Exclude object elements</span><span class="s1"> 
                            } </span><span class="s2">else if </span><span class="s1">( context.nodeName.toLowerCase() !== </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
 
                                </span><span class="s0">// Capture the context ID, setting it first if necessary</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( (nid = context.getAttribute( </span><span class="s3">&quot;id&quot; </span><span class="s1">)) ) { 
                                    nid = nid.replace( rcssescape, fcssescape ); 
                                } </span><span class="s2">else </span><span class="s1">{ 
                                    context.setAttribute( </span><span class="s3">&quot;id&quot;</span><span class="s1">, (nid = expando) ); 
                                } 
 
                                </span><span class="s0">// Prefix every selector in the list</span><span class="s1"> 
                                groups = tokenize( selector ); 
                                i = groups.length; 
                                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                                    groups[i] = </span><span class="s3">&quot;#&quot; </span><span class="s1">+ nid + </span><span class="s3">&quot; &quot; </span><span class="s1">+ toSelector( groups[i] ); 
                                } 
                                newSelector = groups.join( </span><span class="s3">&quot;,&quot; </span><span class="s1">); 
 
                                </span><span class="s0">// Expand context for sibling selectors</span><span class="s1"> 
                                newContext = rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || 
                                    context; 
                            } 
 
                            </span><span class="s2">if </span><span class="s1">( newSelector ) { 
                                </span><span class="s2">try </span><span class="s1">{ 
                                    push.apply( results, 
                                        newContext.querySelectorAll( newSelector ) 
                                    ); 
                                    </span><span class="s2">return </span><span class="s1">results; 
                                } </span><span class="s2">catch </span><span class="s1">( qsaError ) { 
                                } </span><span class="s2">finally </span><span class="s1">{ 
                                    </span><span class="s2">if </span><span class="s1">( nid === expando ) { 
                                        context.removeAttribute( </span><span class="s3">&quot;id&quot; </span><span class="s1">); 
                                    } 
                                } 
                            } 
                        } 
                    } 
                } 
 
                </span><span class="s0">// All others</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">select( selector.replace( rtrim, </span><span class="s3">&quot;$1&quot; </span><span class="s1">), context, results, seed ); 
            } 
 
            </span><span class="s0">/** 
             * Create key-value caches of limited size 
             * </span><span class="s5">@returns </span><span class="s0">{function(string, object)} Returns the Object data after storing it on itself with 
             *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength) 
             *  deleting the oldest entry 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">createCache() { 
                </span><span class="s2">var </span><span class="s1">keys = []; 
 
                </span><span class="s2">function </span><span class="s1">cache( key, value ) { 
                    </span><span class="s0">// Use (key + &quot; &quot;) to avoid collision with native prototype properties (see Issue #157)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( keys.push( key + </span><span class="s3">&quot; &quot; </span><span class="s1">) &gt; Expr.cacheLength ) { 
                        </span><span class="s0">// Only keep the most recent entries</span><span class="s1"> 
                        </span><span class="s2">delete </span><span class="s1">cache[ keys.shift() ]; 
                    } 
                    </span><span class="s2">return </span><span class="s1">(cache[ key + </span><span class="s3">&quot; &quot; </span><span class="s1">] = value); 
                } 
                </span><span class="s2">return </span><span class="s1">cache; 
            } 
 
            </span><span class="s0">/** 
             * Mark a function for special use by Sizzle 
             * </span><span class="s5">@param </span><span class="s0">{Function} fn The function to mark 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">markFunction( fn ) { 
                fn[ expando ] = </span><span class="s2">true</span><span class="s1">; 
                </span><span class="s2">return </span><span class="s1">fn; 
            } 
 
            </span><span class="s0">/** 
             * Support testing using an element 
             * </span><span class="s5">@param </span><span class="s0">{Function} fn Passed the created element and returns a boolean result 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">assert( fn ) { 
                </span><span class="s2">var </span><span class="s1">el = document.createElement(</span><span class="s3">&quot;fieldset&quot;</span><span class="s1">); 
 
                </span><span class="s2">try </span><span class="s1">{ 
                    </span><span class="s2">return </span><span class="s1">!!fn( el ); 
                } </span><span class="s2">catch </span><span class="s1">(e) { 
                    </span><span class="s2">return false</span><span class="s1">; 
                } </span><span class="s2">finally </span><span class="s1">{ 
                    </span><span class="s0">// Remove from its parent by default</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( el.parentNode ) { 
                        el.parentNode.removeChild( el ); 
                    } 
                    </span><span class="s0">// release memory in IE</span><span class="s1"> 
                    el = </span><span class="s2">null</span><span class="s1">; 
                } 
            } 
 
            </span><span class="s0">/** 
             * Adds the same handler for all of the specified attrs 
             * </span><span class="s5">@param </span><span class="s0">{String} attrs Pipe-separated list of attributes 
             * </span><span class="s5">@param </span><span class="s0">{Function} handler The method that will be applied 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">addHandle( attrs, handler ) { 
                </span><span class="s2">var </span><span class="s1">arr = attrs.split(</span><span class="s3">&quot;|&quot;</span><span class="s1">), 
                    i = arr.length; 
 
                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                    Expr.attrHandle[ arr[i] ] = handler; 
                } 
            } 
 
            </span><span class="s0">/** 
             * Checks document order of two siblings 
             * </span><span class="s5">@param </span><span class="s0">{Element} a 
             * </span><span class="s5">@param </span><span class="s0">{Element} b 
             * </span><span class="s5">@returns </span><span class="s0">{Number} Returns less than 0 if a precedes b, greater than 0 if a follows b 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">siblingCheck( a, b ) { 
                </span><span class="s2">var </span><span class="s1">cur = b &amp;&amp; a, 
                    diff = cur &amp;&amp; a.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; b.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; 
                        a.sourceIndex - b.sourceIndex; 
 
                </span><span class="s0">// Use IE sourceIndex if available on both nodes</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( diff ) { 
                    </span><span class="s2">return </span><span class="s1">diff; 
                } 
 
                </span><span class="s0">// Check if b follows a</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( cur ) { 
                    </span><span class="s2">while </span><span class="s1">( (cur = cur.nextSibling) ) { 
                        </span><span class="s2">if </span><span class="s1">( cur === b ) { 
                            </span><span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">; 
                        } 
                    } 
                } 
 
                </span><span class="s2">return </span><span class="s1">a ? </span><span class="s4">1 </span><span class="s1">: -</span><span class="s4">1</span><span class="s1">; 
            } 
 
            </span><span class="s0">/** 
             * Returns a function to use in pseudos for input types 
             * </span><span class="s5">@param </span><span class="s0">{String} type 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">createInputPseudo( type ) { 
                </span><span class="s2">return function</span><span class="s1">( elem ) { 
                    </span><span class="s2">var </span><span class="s1">name = elem.nodeName.toLowerCase(); 
                    </span><span class="s2">return </span><span class="s1">name === </span><span class="s3">&quot;input&quot; </span><span class="s1">&amp;&amp; elem.type === type; 
                }; 
            } 
 
            </span><span class="s0">/** 
             * Returns a function to use in pseudos for buttons 
             * </span><span class="s5">@param </span><span class="s0">{String} type 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">createButtonPseudo( type ) { 
                </span><span class="s2">return function</span><span class="s1">( elem ) { 
                    </span><span class="s2">var </span><span class="s1">name = elem.nodeName.toLowerCase(); 
                    </span><span class="s2">return </span><span class="s1">(name === </span><span class="s3">&quot;input&quot; </span><span class="s1">|| name === </span><span class="s3">&quot;button&quot;</span><span class="s1">) &amp;&amp; elem.type === type; 
                }; 
            } 
 
            </span><span class="s0">/** 
             * Returns a function to use in pseudos for :enabled/:disabled 
             * </span><span class="s5">@param </span><span class="s0">{Boolean} disabled true for :disabled; false for :enabled 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">createDisabledPseudo( disabled ) { 
 
                </span><span class="s0">// Known :disabled false positives: fieldset[disabled] &gt; legend:nth-of-type(n+2) :can-disable</span><span class="s1"> 
                </span><span class="s2">return function</span><span class="s1">( elem ) { 
 
                    </span><span class="s0">// Only certain elements can match :enabled or :disabled</span><span class="s1"> 
                    </span><span class="s0">// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled</span><span class="s1"> 
                    </span><span class="s0">// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s3">&quot;form&quot; </span><span class="s2">in </span><span class="s1">elem ) { 
 
                        </span><span class="s0">// Check for inherited disabledness on relevant non-disabled elements:</span><span class="s1"> 
                        </span><span class="s0">// * listed form-associated elements in a disabled fieldset</span><span class="s1"> 
                        </span><span class="s0">//   https://html.spec.whatwg.org/multipage/forms.html#category-listed</span><span class="s1"> 
                        </span><span class="s0">//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled</span><span class="s1"> 
                        </span><span class="s0">// * option elements in a disabled optgroup</span><span class="s1"> 
                        </span><span class="s0">//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled</span><span class="s1"> 
                        </span><span class="s0">// All such elements have a &quot;form&quot; property.</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( elem.parentNode &amp;&amp; elem.disabled === </span><span class="s2">false </span><span class="s1">) { 
 
                            </span><span class="s0">// Option elements defer to a parent optgroup if present</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( </span><span class="s3">&quot;label&quot; </span><span class="s2">in </span><span class="s1">elem ) { 
                                </span><span class="s2">if </span><span class="s1">( </span><span class="s3">&quot;label&quot; </span><span class="s2">in </span><span class="s1">elem.parentNode ) { 
                                    </span><span class="s2">return </span><span class="s1">elem.parentNode.disabled === disabled; 
                                } </span><span class="s2">else </span><span class="s1">{ 
                                    </span><span class="s2">return </span><span class="s1">elem.disabled === disabled; 
                                } 
                            } 
 
                            </span><span class="s0">// Support: IE 6 - 11</span><span class="s1"> 
                            </span><span class="s0">// Use the isDisabled shortcut property to check for disabled fieldset ancestors</span><span class="s1"> 
                            </span><span class="s2">return </span><span class="s1">elem.isDisabled === disabled || 
 
                                    </span><span class="s0">// Where there is no isDisabled, check manually</span><span class="s1"> 
                                    </span><span class="s0">/* jshint -W018 */</span><span class="s1"> 
                                elem.isDisabled !== !disabled &amp;&amp; 
                                disabledAncestor( elem ) === disabled; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">elem.disabled === disabled; 
 
                        </span><span class="s0">// Try to winnow out elements that can't be disabled before trusting the disabled property.</span><span class="s1"> 
                        </span><span class="s0">// Some victims get caught in our net (label, legend, menu, track), but it shouldn't</span><span class="s1"> 
                        </span><span class="s0">// even exist on them, let alone have a boolean value.</span><span class="s1"> 
                    } </span><span class="s2">else if </span><span class="s1">( </span><span class="s3">&quot;label&quot; </span><span class="s2">in </span><span class="s1">elem ) { 
                        </span><span class="s2">return </span><span class="s1">elem.disabled === disabled; 
                    } 
 
                    </span><span class="s0">// Remaining elements are neither :enabled nor :disabled</span><span class="s1"> 
                    </span><span class="s2">return false</span><span class="s1">; 
                }; 
            } 
 
            </span><span class="s0">/** 
             * Returns a function to use in pseudos for positionals 
             * </span><span class="s5">@param </span><span class="s0">{Function} fn 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">createPositionalPseudo( fn ) { 
                </span><span class="s2">return </span><span class="s1">markFunction(</span><span class="s2">function</span><span class="s1">( argument ) { 
                    argument = +argument; 
                    </span><span class="s2">return </span><span class="s1">markFunction(</span><span class="s2">function</span><span class="s1">( seed, matches ) { 
                        </span><span class="s2">var </span><span class="s1">j, 
                            matchIndexes = fn( [], seed.length, argument ), 
                            i = matchIndexes.length; 
 
                        </span><span class="s0">// Match elements found at the specified indexes</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( i-- ) { 
                            </span><span class="s2">if </span><span class="s1">( seed[ (j = matchIndexes[i]) ] ) { 
                                seed[j] = !(matches[j] = seed[j]); 
                            } 
                        } 
                    }); 
                }); 
            } 
 
            </span><span class="s0">/** 
             * Checks a node for validity as a Sizzle context 
             * </span><span class="s5">@param </span><span class="s0">{Element|Object=} context 
             * </span><span class="s5">@returns </span><span class="s0">{Element|Object|Boolean} The input node if acceptable, otherwise a falsy value 
             */</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">testContext( context ) { 
                </span><span class="s2">return </span><span class="s1">context &amp;&amp; </span><span class="s2">typeof </span><span class="s1">context.getElementsByTagName !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; context; 
            } 
 
</span><span class="s0">// Expose support vars for convenience</span><span class="s1"> 
            support = Sizzle.support = {}; 
 
            </span><span class="s0">/** 
             * Detects XML nodes 
             * </span><span class="s5">@param </span><span class="s0">{Element|Object} elem An element or a document 
             * </span><span class="s5">@returns </span><span class="s0">{Boolean} True iff elem is a non-HTML XML node 
             */</span><span class="s1"> 
            isXML = Sizzle.isXML = </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s0">// documentElement is verified for cases where it doesn't yet exist</span><span class="s1"> 
                </span><span class="s0">// (such as loading iframes in IE - #4833)</span><span class="s1"> 
                </span><span class="s2">var </span><span class="s1">documentElement = elem &amp;&amp; (elem.ownerDocument || elem).documentElement; 
                </span><span class="s2">return </span><span class="s1">documentElement ? documentElement.nodeName !== </span><span class="s3">&quot;HTML&quot; </span><span class="s1">: </span><span class="s2">false</span><span class="s1">; 
            }; 
 
            </span><span class="s0">/** 
             * Sets document-related variables once based on the current document 
             * </span><span class="s5">@param </span><span class="s0">{Element|Object} [doc] An element or document object to use to set the document 
             * </span><span class="s5">@returns </span><span class="s0">{Object} Returns the current document 
             */</span><span class="s1"> 
            setDocument = Sizzle.setDocument = </span><span class="s2">function</span><span class="s1">( node ) { 
                </span><span class="s2">var </span><span class="s1">hasCompare, subWindow, 
                    doc = node ? node.ownerDocument || node : preferredDoc; 
 
                </span><span class="s0">// Return early if doc is invalid or already selected</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( doc === document || doc.nodeType !== </span><span class="s4">9 </span><span class="s1">|| !doc.documentElement ) { 
                    </span><span class="s2">return </span><span class="s1">document; 
                } 
 
                </span><span class="s0">// Update global variables</span><span class="s1"> 
                document = doc; 
                docElem = document.documentElement; 
                documentIsHTML = !isXML( document ); 
 
                </span><span class="s0">// Support: IE 9-11, Edge</span><span class="s1"> 
                </span><span class="s0">// Accessing iframe documents after unload throws &quot;permission denied&quot; errors (jQuery #13936)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( preferredDoc !== document &amp;&amp; 
                    (subWindow = document.defaultView) &amp;&amp; subWindow.top !== subWindow ) { 
 
                    </span><span class="s0">// Support: IE 11, Edge</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( subWindow.addEventListener ) { 
                        subWindow.addEventListener( </span><span class="s3">&quot;unload&quot;</span><span class="s1">, unloadHandler, </span><span class="s2">false </span><span class="s1">); 
 
                        </span><span class="s0">// Support: IE 9 - 10 only</span><span class="s1"> 
                    } </span><span class="s2">else if </span><span class="s1">( subWindow.attachEvent ) { 
                        subWindow.attachEvent( </span><span class="s3">&quot;onunload&quot;</span><span class="s1">, unloadHandler ); 
                    } 
                } 
 
                </span><span class="s0">/* Attributes 
                 ---------------------------------------------------------------------- */</span><span class="s1"> 
 
                </span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
                </span><span class="s0">// Verify that getAttribute really returns attributes and not properties</span><span class="s1"> 
                </span><span class="s0">// (excepting IE8 booleans)</span><span class="s1"> 
                support.attributes = assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                    el.className = </span><span class="s3">&quot;i&quot;</span><span class="s1">; 
                    </span><span class="s2">return </span><span class="s1">!el.getAttribute(</span><span class="s3">&quot;className&quot;</span><span class="s1">); 
                }); 
 
                </span><span class="s0">/* getElement(s)By* 
                 ---------------------------------------------------------------------- */</span><span class="s1"> 
 
                </span><span class="s0">// Check if getElementsByTagName(&quot;*&quot;) returns only elements</span><span class="s1"> 
                support.getElementsByTagName = assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                    el.appendChild( document.createComment(</span><span class="s3">&quot;&quot;</span><span class="s1">) ); 
                    </span><span class="s2">return </span><span class="s1">!el.getElementsByTagName(</span><span class="s3">&quot;*&quot;</span><span class="s1">).length; 
                }); 
 
                </span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
                support.getElementsByClassName = rnative.test( document.getElementsByClassName ); 
 
                </span><span class="s0">// Support: IE&lt;10</span><span class="s1"> 
                </span><span class="s0">// Check if getElementById returns elements by name</span><span class="s1"> 
                </span><span class="s0">// The broken getElementById methods don't pick up programmatically-set names,</span><span class="s1"> 
                </span><span class="s0">// so use a roundabout getElementsByName test</span><span class="s1"> 
                support.getById = assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                    docElem.appendChild( el ).id = expando; 
                    </span><span class="s2">return </span><span class="s1">!document.getElementsByName || !document.getElementsByName( expando ).length; 
                }); 
 
                </span><span class="s0">// ID filter and find</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( support.getById ) { 
                    Expr.filter[</span><span class="s3">&quot;ID&quot;</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">( id ) { 
                        </span><span class="s2">var </span><span class="s1">attrId = id.replace( runescape, funescape ); 
                        </span><span class="s2">return function</span><span class="s1">( elem ) { 
                            </span><span class="s2">return </span><span class="s1">elem.getAttribute(</span><span class="s3">&quot;id&quot;</span><span class="s1">) === attrId; 
                        }; 
                    }; 
                    Expr.find[</span><span class="s3">&quot;ID&quot;</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">( id, context ) { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementById !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; documentIsHTML ) { 
                            </span><span class="s2">var </span><span class="s1">elem = context.getElementById( id ); 
                            </span><span class="s2">return </span><span class="s1">elem ? [ elem ] : []; 
                        } 
                    }; 
                } </span><span class="s2">else </span><span class="s1">{ 
                    Expr.filter[</span><span class="s3">&quot;ID&quot;</span><span class="s1">] =  </span><span class="s2">function</span><span class="s1">( id ) { 
                        </span><span class="s2">var </span><span class="s1">attrId = id.replace( runescape, funescape ); 
                        </span><span class="s2">return function</span><span class="s1">( elem ) { 
                            </span><span class="s2">var </span><span class="s1">node = </span><span class="s2">typeof </span><span class="s1">elem.getAttributeNode !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; 
                                elem.getAttributeNode(</span><span class="s3">&quot;id&quot;</span><span class="s1">); 
                            </span><span class="s2">return </span><span class="s1">node &amp;&amp; node.value === attrId; 
                        }; 
                    }; 
 
                    </span><span class="s0">// Support: IE 6 - 7 only</span><span class="s1"> 
                    </span><span class="s0">// getElementById is not reliable as a find shortcut</span><span class="s1"> 
                    Expr.find[</span><span class="s3">&quot;ID&quot;</span><span class="s1">] = </span><span class="s2">function</span><span class="s1">( id, context ) { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementById !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; documentIsHTML ) { 
                            </span><span class="s2">var </span><span class="s1">node, i, elems, 
                                elem = context.getElementById( id ); 
 
                            </span><span class="s2">if </span><span class="s1">( elem ) { 
 
                                </span><span class="s0">// Verify the id attribute</span><span class="s1"> 
                                node = elem.getAttributeNode(</span><span class="s3">&quot;id&quot;</span><span class="s1">); 
                                </span><span class="s2">if </span><span class="s1">( node &amp;&amp; node.value === id ) { 
                                    </span><span class="s2">return </span><span class="s1">[ elem ]; 
                                } 
 
                                </span><span class="s0">// Fall back on getElementsByName</span><span class="s1"> 
                                elems = context.getElementsByName( id ); 
                                i = </span><span class="s4">0</span><span class="s1">; 
                                </span><span class="s2">while </span><span class="s1">( (elem = elems[i++]) ) { 
                                    node = elem.getAttributeNode(</span><span class="s3">&quot;id&quot;</span><span class="s1">); 
                                    </span><span class="s2">if </span><span class="s1">( node &amp;&amp; node.value === id ) { 
                                        </span><span class="s2">return </span><span class="s1">[ elem ]; 
                                    } 
                                } 
                            } 
 
                            </span><span class="s2">return </span><span class="s1">[]; 
                        } 
                    }; 
                } 
 
                </span><span class="s0">// Tag</span><span class="s1"> 
                Expr.find[</span><span class="s3">&quot;TAG&quot;</span><span class="s1">] = support.getElementsByTagName ? 
                    </span><span class="s2">function</span><span class="s1">( tag, context ) { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementsByTagName !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">) { 
                            </span><span class="s2">return </span><span class="s1">context.getElementsByTagName( tag ); 
 
                            </span><span class="s0">// DocumentFragment nodes don't have gEBTN</span><span class="s1"> 
                        } </span><span class="s2">else if </span><span class="s1">( support.qsa ) { 
                            </span><span class="s2">return </span><span class="s1">context.querySelectorAll( tag ); 
                        } 
                    } : 
 
                    </span><span class="s2">function</span><span class="s1">( tag, context ) { 
                        </span><span class="s2">var </span><span class="s1">elem, 
                            tmp = [], 
                            i = </span><span class="s4">0</span><span class="s1">, 
                        </span><span class="s0">// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too</span><span class="s1"> 
                            results = context.getElementsByTagName( tag ); 
 
                        </span><span class="s0">// Filter out possible comments</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( tag === </span><span class="s3">&quot;*&quot; </span><span class="s1">) { 
                            </span><span class="s2">while </span><span class="s1">( (elem = results[i++]) ) { 
                                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
                                    tmp.push( elem ); 
                                } 
                            } 
 
                            </span><span class="s2">return </span><span class="s1">tmp; 
                        } 
                        </span><span class="s2">return </span><span class="s1">results; 
                    }; 
 
                </span><span class="s0">// Class</span><span class="s1"> 
                Expr.find[</span><span class="s3">&quot;CLASS&quot;</span><span class="s1">] = support.getElementsByClassName &amp;&amp; </span><span class="s2">function</span><span class="s1">( className, context ) { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementsByClassName !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; documentIsHTML ) { 
                            </span><span class="s2">return </span><span class="s1">context.getElementsByClassName( className ); 
                        } 
                    }; 
 
                </span><span class="s0">/* QSA/matchesSelector 
                 ---------------------------------------------------------------------- */</span><span class="s1"> 
 
                </span><span class="s0">// QSA and matchesSelector support</span><span class="s1"> 
 
                </span><span class="s0">// matchesSelector(:active) reports false when true (IE9/Opera 11.5)</span><span class="s1"> 
                rbuggyMatches = []; 
 
                </span><span class="s0">// qSa(:focus) reports false when true (Chrome 21)</span><span class="s1"> 
                </span><span class="s0">// We allow this because of a bug in IE8/9 that throws an error</span><span class="s1"> 
                </span><span class="s0">// whenever `document.activeElement` is accessed on an iframe</span><span class="s1"> 
                </span><span class="s0">// So, we allow :focus to pass through QSA all the time to avoid the IE error</span><span class="s1"> 
                </span><span class="s0">// See https://bugs.jquery.com/ticket/13378</span><span class="s1"> 
                rbuggyQSA = []; 
 
                </span><span class="s2">if </span><span class="s1">( (support.qsa = rnative.test( document.querySelectorAll )) ) { 
                    </span><span class="s0">// Build QSA regex</span><span class="s1"> 
                    </span><span class="s0">// Regex strategy adopted from Diego Perini</span><span class="s1"> 
                    assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                        </span><span class="s0">// Select is set to empty string on purpose</span><span class="s1"> 
                        </span><span class="s0">// This is to test IE's treatment of not explicitly</span><span class="s1"> 
                        </span><span class="s0">// setting a boolean content attribute,</span><span class="s1"> 
                        </span><span class="s0">// since its presence should be enough</span><span class="s1"> 
                        </span><span class="s0">// https://bugs.jquery.com/ticket/12359</span><span class="s1"> 
                        docElem.appendChild( el ).innerHTML = </span><span class="s3">&quot;&lt;a id='&quot; </span><span class="s1">+ expando + </span><span class="s3">&quot;'&gt;&lt;/a&gt;&quot; </span><span class="s1">+ 
                            </span><span class="s3">&quot;&lt;select id='&quot; </span><span class="s1">+ expando + </span><span class="s3">&quot;-</span><span class="s2">\r\\</span><span class="s3">' msallowcapture=''&gt;&quot; </span><span class="s1">+ 
                            </span><span class="s3">&quot;&lt;option selected=''&gt;&lt;/option&gt;&lt;/select&gt;&quot;</span><span class="s1">; 
 
                        </span><span class="s0">// Support: IE8, Opera 11-12.16</span><span class="s1"> 
                        </span><span class="s0">// Nothing should be selected when empty strings follow ^= or $= or *=</span><span class="s1"> 
                        </span><span class="s0">// The test attribute must be unknown in Opera but &quot;safe&quot; for WinRT</span><span class="s1"> 
                        </span><span class="s0">// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( el.querySelectorAll(</span><span class="s3">&quot;[msallowcapture^='']&quot;</span><span class="s1">).length ) { 
                            rbuggyQSA.push( </span><span class="s3">&quot;[*^$]=&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*(?:''|</span><span class="s2">\&quot;\&quot;</span><span class="s3">)&quot; </span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// Support: IE8</span><span class="s1"> 
                        </span><span class="s0">// Boolean attributes and &quot;value&quot; are not treated correctly</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !el.querySelectorAll(</span><span class="s3">&quot;[selected]&quot;</span><span class="s1">).length ) { 
                            rbuggyQSA.push( </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">[&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*(?:value|&quot; </span><span class="s1">+ booleans + </span><span class="s3">&quot;)&quot; </span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// Support: Chrome&lt;29, Android&lt;4.4, Safari&lt;7.0+, iOS&lt;7.0+, PhantomJS&lt;1.9.8+</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !el.querySelectorAll( </span><span class="s3">&quot;[id~=&quot; </span><span class="s1">+ expando + </span><span class="s3">&quot;-]&quot; </span><span class="s1">).length ) { 
                            rbuggyQSA.push(</span><span class="s3">&quot;~=&quot;</span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// Webkit/Opera - :checked should return selected option elements</span><span class="s1"> 
                        </span><span class="s0">// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</span><span class="s1"> 
                        </span><span class="s0">// IE8 throws error here and will not see later tests</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !el.querySelectorAll(</span><span class="s3">&quot;:checked&quot;</span><span class="s1">).length ) { 
                            rbuggyQSA.push(</span><span class="s3">&quot;:checked&quot;</span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// Support: Safari 8+, iOS 8+</span><span class="s1"> 
                        </span><span class="s0">// https://bugs.webkit.org/show_bug.cgi?id=136851</span><span class="s1"> 
                        </span><span class="s0">// In-page `selector#id sibling-combinator selector` fails</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !el.querySelectorAll( </span><span class="s3">&quot;a#&quot; </span><span class="s1">+ expando + </span><span class="s3">&quot;+*&quot; </span><span class="s1">).length ) { 
                            rbuggyQSA.push(</span><span class="s3">&quot;.#.+[+~]&quot;</span><span class="s1">); 
                        } 
                    }); 
 
                    assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                        el.innerHTML = </span><span class="s3">&quot;&lt;a href='' disabled='disabled'&gt;&lt;/a&gt;&quot; </span><span class="s1">+ 
                            </span><span class="s3">&quot;&lt;select disabled='disabled'&gt;&lt;option/&gt;&lt;/select&gt;&quot;</span><span class="s1">; 
 
                        </span><span class="s0">// Support: Windows 8 Native Apps</span><span class="s1"> 
                        </span><span class="s0">// The type and name attributes are restricted during .innerHTML assignment</span><span class="s1"> 
                        </span><span class="s2">var </span><span class="s1">input = document.createElement(</span><span class="s3">&quot;input&quot;</span><span class="s1">); 
                        input.setAttribute( </span><span class="s3">&quot;type&quot;</span><span class="s1">, </span><span class="s3">&quot;hidden&quot; </span><span class="s1">); 
                        el.appendChild( input ).setAttribute( </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;D&quot; </span><span class="s1">); 
 
                        </span><span class="s0">// Support: IE8</span><span class="s1"> 
                        </span><span class="s0">// Enforce case-sensitivity of name attribute</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( el.querySelectorAll(</span><span class="s3">&quot;[name=d]&quot;</span><span class="s1">).length ) { 
                            rbuggyQSA.push( </span><span class="s3">&quot;name&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;*[*^$|!~]?=&quot; </span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)</span><span class="s1"> 
                        </span><span class="s0">// IE8 throws error here and will not see later tests</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( el.querySelectorAll(</span><span class="s3">&quot;:enabled&quot;</span><span class="s1">).length !== </span><span class="s4">2 </span><span class="s1">) { 
                            rbuggyQSA.push( </span><span class="s3">&quot;:enabled&quot;</span><span class="s1">, </span><span class="s3">&quot;:disabled&quot; </span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// Support: IE9-11+</span><span class="s1"> 
                        </span><span class="s0">// IE's :disabled selector does not pick up the children of disabled fieldsets</span><span class="s1"> 
                        docElem.appendChild( el ).disabled = </span><span class="s2">true</span><span class="s1">; 
                        </span><span class="s2">if </span><span class="s1">( el.querySelectorAll(</span><span class="s3">&quot;:disabled&quot;</span><span class="s1">).length !== </span><span class="s4">2 </span><span class="s1">) { 
                            rbuggyQSA.push( </span><span class="s3">&quot;:enabled&quot;</span><span class="s1">, </span><span class="s3">&quot;:disabled&quot; </span><span class="s1">); 
                        } 
 
                        </span><span class="s0">// Opera 10-11 does not throw on post-comma invalid pseudos</span><span class="s1"> 
                        el.querySelectorAll(</span><span class="s3">&quot;*,:x&quot;</span><span class="s1">); 
                        rbuggyQSA.push(</span><span class="s3">&quot;,.*:&quot;</span><span class="s1">); 
                    }); 
                } 
 
                </span><span class="s2">if </span><span class="s1">( (support.matchesSelector = rnative.test( (matches = docElem.matches || 
                        docElem.webkitMatchesSelector || 
                        docElem.mozMatchesSelector || 
                        docElem.oMatchesSelector || 
                        docElem.msMatchesSelector) )) ) { 
 
                    assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                        </span><span class="s0">// Check to see if it's possible to do matchesSelector</span><span class="s1"> 
                        </span><span class="s0">// on a disconnected node (IE 9)</span><span class="s1"> 
                        support.disconnectedMatch = matches.call( el, </span><span class="s3">&quot;*&quot; </span><span class="s1">); 
 
                        </span><span class="s0">// This should fail with an exception</span><span class="s1"> 
                        </span><span class="s0">// Gecko does not error, returns false instead</span><span class="s1"> 
                        matches.call( el, </span><span class="s3">&quot;[s!='']:x&quot; </span><span class="s1">); 
                        rbuggyMatches.push( </span><span class="s3">&quot;!=&quot;</span><span class="s1">, pseudos ); 
                    }); 
                } 
 
                rbuggyQSA = rbuggyQSA.length &amp;&amp; </span><span class="s2">new </span><span class="s1">RegExp( rbuggyQSA.join(</span><span class="s3">&quot;|&quot;</span><span class="s1">) ); 
                rbuggyMatches = rbuggyMatches.length &amp;&amp; </span><span class="s2">new </span><span class="s1">RegExp( rbuggyMatches.join(</span><span class="s3">&quot;|&quot;</span><span class="s1">) ); 
 
                </span><span class="s0">/* Contains 
                 ---------------------------------------------------------------------- */</span><span class="s1"> 
                hasCompare = rnative.test( docElem.compareDocumentPosition ); 
 
                </span><span class="s0">// Element contains another</span><span class="s1"> 
                </span><span class="s0">// Purposefully self-exclusive</span><span class="s1"> 
                </span><span class="s0">// As in, an element does not contain itself</span><span class="s1"> 
                contains = hasCompare || rnative.test( docElem.contains ) ? 
                    </span><span class="s2">function</span><span class="s1">( a, b ) { 
                        </span><span class="s2">var </span><span class="s1">adown = a.nodeType === </span><span class="s4">9 </span><span class="s1">? a.documentElement : a, 
                            bup = b &amp;&amp; b.parentNode; 
                        </span><span class="s2">return </span><span class="s1">a === bup || !!( bup &amp;&amp; bup.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; ( 
                                adown.contains ? 
                                    adown.contains( bup ) : 
                                a.compareDocumentPosition &amp;&amp; a.compareDocumentPosition( bup ) &amp; </span><span class="s4">16</span><span class="s1"> 
                            )); 
                    } : 
                    </span><span class="s2">function</span><span class="s1">( a, b ) { 
                        </span><span class="s2">if </span><span class="s1">( b ) { 
                            </span><span class="s2">while </span><span class="s1">( (b = b.parentNode) ) { 
                                </span><span class="s2">if </span><span class="s1">( b === a ) { 
                                    </span><span class="s2">return true</span><span class="s1">; 
                                } 
                            } 
                        } 
                        </span><span class="s2">return false</span><span class="s1">; 
                    }; 
 
                </span><span class="s0">/* Sorting 
                 ---------------------------------------------------------------------- */</span><span class="s1"> 
 
                </span><span class="s0">// Document order sorting</span><span class="s1"> 
                sortOrder = hasCompare ? 
                    </span><span class="s2">function</span><span class="s1">( a, b ) { 
 
                        </span><span class="s0">// Flag for duplicate removal</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( a === b ) { 
                            hasDuplicate = </span><span class="s2">true</span><span class="s1">; 
                            </span><span class="s2">return </span><span class="s4">0</span><span class="s1">; 
                        } 
 
                        </span><span class="s0">// Sort on method existence if only one input has compareDocumentPosition</span><span class="s1"> 
                        </span><span class="s2">var </span><span class="s1">compare = !a.compareDocumentPosition - !b.compareDocumentPosition; 
                        </span><span class="s2">if </span><span class="s1">( compare ) { 
                            </span><span class="s2">return </span><span class="s1">compare; 
                        } 
 
                        </span><span class="s0">// Calculate position if both inputs belong to the same document</span><span class="s1"> 
                        compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ? 
                            a.compareDocumentPosition( b ) : 
 
                            </span><span class="s0">// Otherwise we know they are disconnected</span><span class="s1"> 
                            </span><span class="s4">1</span><span class="s1">; 
 
                        </span><span class="s0">// Disconnected nodes</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( compare &amp; </span><span class="s4">1 </span><span class="s1">|| 
                            (!support.sortDetached &amp;&amp; b.compareDocumentPosition( a ) === compare) ) { 
 
                            </span><span class="s0">// Choose the first element that is related to our preferred document</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( a === document || a.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, a) ) { 
                                </span><span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">; 
                            } 
                            </span><span class="s2">if </span><span class="s1">( b === document || b.ownerDocument === preferredDoc &amp;&amp; contains(preferredDoc, b) ) { 
                                </span><span class="s2">return </span><span class="s4">1</span><span class="s1">; 
                            } 
 
                            </span><span class="s0">// Maintain original order</span><span class="s1"> 
                            </span><span class="s2">return </span><span class="s1">sortInput ? 
                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) : 
                                </span><span class="s4">0</span><span class="s1">; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">compare &amp; </span><span class="s4">4 </span><span class="s1">? -</span><span class="s4">1 </span><span class="s1">: </span><span class="s4">1</span><span class="s1">; 
                    } : 
                    </span><span class="s2">function</span><span class="s1">( a, b ) { 
                        </span><span class="s0">// Exit early if the nodes are identical</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( a === b ) { 
                            hasDuplicate = </span><span class="s2">true</span><span class="s1">; 
                            </span><span class="s2">return </span><span class="s4">0</span><span class="s1">; 
                        } 
 
                        </span><span class="s2">var </span><span class="s1">cur, 
                            i = </span><span class="s4">0</span><span class="s1">, 
                            aup = a.parentNode, 
                            bup = b.parentNode, 
                            ap = [ a ], 
                            bp = [ b ]; 
 
                        </span><span class="s0">// Parentless nodes are either documents or disconnected</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !aup || !bup ) { 
                            </span><span class="s2">return </span><span class="s1">a === document ? -</span><span class="s4">1 </span><span class="s1">: 
                                b === document ? </span><span class="s4">1 </span><span class="s1">: 
                                    aup ? -</span><span class="s4">1 </span><span class="s1">: 
                                        bup ? </span><span class="s4">1 </span><span class="s1">: 
                                            sortInput ? 
                                                ( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) : 
                                                </span><span class="s4">0</span><span class="s1">; 
 
                            </span><span class="s0">// If the nodes are siblings, we can do a quick check</span><span class="s1"> 
                        } </span><span class="s2">else if </span><span class="s1">( aup === bup ) { 
                            </span><span class="s2">return </span><span class="s1">siblingCheck( a, b ); 
                        } 
 
                        </span><span class="s0">// Otherwise we need full lists of their ancestors for comparison</span><span class="s1"> 
                        cur = a; 
                        </span><span class="s2">while </span><span class="s1">( (cur = cur.parentNode) ) { 
                            ap.unshift( cur ); 
                        } 
                        cur = b; 
                        </span><span class="s2">while </span><span class="s1">( (cur = cur.parentNode) ) { 
                            bp.unshift( cur ); 
                        } 
 
                        </span><span class="s0">// Walk down the tree looking for a discrepancy</span><span class="s1"> 
                        </span><span class="s2">while </span><span class="s1">( ap[i] === bp[i] ) { 
                            i++; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">i ? 
                            </span><span class="s0">// Do a sibling check if the nodes have a common ancestor</span><span class="s1"> 
                            siblingCheck( ap[i], bp[i] ) : 
 
                            </span><span class="s0">// Otherwise nodes in our document sort first</span><span class="s1"> 
                            ap[i] === preferredDoc ? -</span><span class="s4">1 </span><span class="s1">: 
                                bp[i] === preferredDoc ? </span><span class="s4">1 </span><span class="s1">: 
                                    </span><span class="s4">0</span><span class="s1">; 
                    }; 
 
                </span><span class="s2">return </span><span class="s1">document; 
            }; 
 
            Sizzle.matches = </span><span class="s2">function</span><span class="s1">( expr, elements ) { 
                </span><span class="s2">return </span><span class="s1">Sizzle( expr, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, elements ); 
            }; 
 
            Sizzle.matchesSelector = </span><span class="s2">function</span><span class="s1">( elem, expr ) { 
                </span><span class="s0">// Set document vars if needed</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( ( elem.ownerDocument || elem ) !== document ) { 
                    setDocument( elem ); 
                } 
 
                </span><span class="s0">// Make sure that attribute selectors are quoted</span><span class="s1"> 
                expr = expr.replace( rattributeQuotes, </span><span class="s3">&quot;='$1']&quot; </span><span class="s1">); 
 
                </span><span class="s2">if </span><span class="s1">( support.matchesSelector &amp;&amp; documentIsHTML &amp;&amp; 
                    !compilerCache[ expr + </span><span class="s3">&quot; &quot; </span><span class="s1">] &amp;&amp; 
                    ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &amp;&amp; 
                    ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) { 
 
                    </span><span class="s2">try </span><span class="s1">{ 
                        </span><span class="s2">var </span><span class="s1">ret = matches.call( elem, expr ); 
 
                        </span><span class="s0">// IE 9's matchesSelector returns false on disconnected nodes</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( ret || support.disconnectedMatch || 
                                </span><span class="s0">// As well, disconnected nodes are said to be in a document</span><span class="s1"> 
                                </span><span class="s0">// fragment in IE 9</span><span class="s1"> 
                            elem.document &amp;&amp; elem.document.nodeType !== </span><span class="s4">11 </span><span class="s1">) { 
                            </span><span class="s2">return </span><span class="s1">ret; 
                        } 
                    } </span><span class="s2">catch </span><span class="s1">(e) {} 
                } 
 
                </span><span class="s2">return </span><span class="s1">Sizzle( expr, document, </span><span class="s2">null</span><span class="s1">, [ elem ] ).length &gt; </span><span class="s4">0</span><span class="s1">; 
            }; 
 
            Sizzle.contains = </span><span class="s2">function</span><span class="s1">( context, elem ) { 
                </span><span class="s0">// Set document vars if needed</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( ( context.ownerDocument || context ) !== document ) { 
                    setDocument( context ); 
                } 
                </span><span class="s2">return </span><span class="s1">contains( context, elem ); 
            }; 
 
            Sizzle.attr = </span><span class="s2">function</span><span class="s1">( elem, name ) { 
                </span><span class="s0">// Set document vars if needed</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( ( elem.ownerDocument || elem ) !== document ) { 
                    setDocument( elem ); 
                } 
 
                </span><span class="s2">var </span><span class="s1">fn = Expr.attrHandle[ name.toLowerCase() ], 
                </span><span class="s0">// Don't get fooled by Object.prototype properties (jQuery #13807)</span><span class="s1"> 
                    val = fn &amp;&amp; hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ? 
                        fn( elem, name, !documentIsHTML ) : 
                        undefined; 
 
                </span><span class="s2">return </span><span class="s1">val !== undefined ? 
                    val : 
                    support.attributes || !documentIsHTML ? 
                        elem.getAttribute( name ) : 
                        (val = elem.getAttributeNode(name)) &amp;&amp; val.specified ? 
                            val.value : 
                            </span><span class="s2">null</span><span class="s1">; 
            }; 
 
            Sizzle.escape = </span><span class="s2">function</span><span class="s1">( sel ) { 
                </span><span class="s2">return </span><span class="s1">(sel + </span><span class="s3">&quot;&quot;</span><span class="s1">).replace( rcssescape, fcssescape ); 
            }; 
 
            Sizzle.error = </span><span class="s2">function</span><span class="s1">( msg ) { 
                </span><span class="s2">throw new </span><span class="s1">Error( </span><span class="s3">&quot;Syntax error, unrecognized expression: &quot; </span><span class="s1">+ msg ); 
            }; 
 
            </span><span class="s0">/** 
             * Document sorting and removing duplicates 
             * </span><span class="s5">@param </span><span class="s0">{ArrayLike} results 
             */</span><span class="s1"> 
            Sizzle.uniqueSort = </span><span class="s2">function</span><span class="s1">( results ) { 
                </span><span class="s2">var </span><span class="s1">elem, 
                    duplicates = [], 
                    j = </span><span class="s4">0</span><span class="s1">, 
                    i = </span><span class="s4">0</span><span class="s1">; 
 
                </span><span class="s0">// Unless we *know* we can detect duplicates, assume their presence</span><span class="s1"> 
                hasDuplicate = !support.detectDuplicates; 
                sortInput = !support.sortStable &amp;&amp; results.slice( </span><span class="s4">0 </span><span class="s1">); 
                results.sort( sortOrder ); 
 
                </span><span class="s2">if </span><span class="s1">( hasDuplicate ) { 
                    </span><span class="s2">while </span><span class="s1">( (elem = results[i++]) ) { 
                        </span><span class="s2">if </span><span class="s1">( elem === results[ i ] ) { 
                            j = duplicates.push( i ); 
                        } 
                    } 
                    </span><span class="s2">while </span><span class="s1">( j-- ) { 
                        results.splice( duplicates[ j ], </span><span class="s4">1 </span><span class="s1">); 
                    } 
                } 
 
                </span><span class="s0">// Clear input after sorting to release objects</span><span class="s1"> 
                </span><span class="s0">// See https://github.com/jquery/sizzle/pull/225</span><span class="s1"> 
                sortInput = </span><span class="s2">null</span><span class="s1">; 
 
                </span><span class="s2">return </span><span class="s1">results; 
            }; 
 
            </span><span class="s0">/** 
             * Utility function for retrieving the text value of an array of DOM nodes 
             * </span><span class="s5">@param </span><span class="s0">{Array|Element} elem 
             */</span><span class="s1"> 
            getText = Sizzle.getText = </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">node, 
                    ret = </span><span class="s3">&quot;&quot;</span><span class="s1">, 
                    i = </span><span class="s4">0</span><span class="s1">, 
                    nodeType = elem.nodeType; 
 
                </span><span class="s2">if </span><span class="s1">( !nodeType ) { 
                    </span><span class="s0">// If no nodeType, this is expected to be an array</span><span class="s1"> 
                    </span><span class="s2">while </span><span class="s1">( (node = elem[i++]) ) { 
                        </span><span class="s0">// Do not traverse comment nodes</span><span class="s1"> 
                        ret += getText( node ); 
                    } 
                } </span><span class="s2">else if </span><span class="s1">( nodeType === </span><span class="s4">1 </span><span class="s1">|| nodeType === </span><span class="s4">9 </span><span class="s1">|| nodeType === </span><span class="s4">11 </span><span class="s1">) { 
                    </span><span class="s0">// Use textContent for elements</span><span class="s1"> 
                    </span><span class="s0">// innerText usage removed for consistency of new lines (jQuery #11153)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem.textContent === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                        </span><span class="s2">return </span><span class="s1">elem.textContent; 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        </span><span class="s0">// Traverse its children</span><span class="s1"> 
                        </span><span class="s2">for </span><span class="s1">( elem = elem.firstChild; elem; elem = elem.nextSibling ) { 
                            ret += getText( elem ); 
                        } 
                    } 
                } </span><span class="s2">else if </span><span class="s1">( nodeType === </span><span class="s4">3 </span><span class="s1">|| nodeType === </span><span class="s4">4 </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">elem.nodeValue; 
                } 
                </span><span class="s0">// Do not include comment or processing instruction nodes</span><span class="s1"> 
 
                </span><span class="s2">return </span><span class="s1">ret; 
            }; 
 
            Expr = Sizzle.selectors = { 
 
                </span><span class="s0">// Can be adjusted by the user</span><span class="s1"> 
                cacheLength: </span><span class="s4">50</span><span class="s1">, 
 
                createPseudo: markFunction, 
 
                match: matchExpr, 
 
                attrHandle: {}, 
 
                find: {}, 
 
                relative: { 
                    </span><span class="s3">&quot;&gt;&quot;</span><span class="s1">: { dir: </span><span class="s3">&quot;parentNode&quot;</span><span class="s1">, first: </span><span class="s2">true </span><span class="s1">}, 
                    </span><span class="s3">&quot; &quot;</span><span class="s1">: { dir: </span><span class="s3">&quot;parentNode&quot; </span><span class="s1">}, 
                    </span><span class="s3">&quot;+&quot;</span><span class="s1">: { dir: </span><span class="s3">&quot;previousSibling&quot;</span><span class="s1">, first: </span><span class="s2">true </span><span class="s1">}, 
                    </span><span class="s3">&quot;~&quot;</span><span class="s1">: { dir: </span><span class="s3">&quot;previousSibling&quot; </span><span class="s1">} 
                }, 
 
                preFilter: { 
                    </span><span class="s3">&quot;ATTR&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( match ) { 
                        match[</span><span class="s4">1</span><span class="s1">] = match[</span><span class="s4">1</span><span class="s1">].replace( runescape, funescape ); 
 
                        </span><span class="s0">// Move the given value to match[3] whether quoted or unquoted</span><span class="s1"> 
                        match[</span><span class="s4">3</span><span class="s1">] = ( match[</span><span class="s4">3</span><span class="s1">] || match[</span><span class="s4">4</span><span class="s1">] || match[</span><span class="s4">5</span><span class="s1">] || </span><span class="s3">&quot;&quot; </span><span class="s1">).replace( runescape, funescape ); 
 
                        </span><span class="s2">if </span><span class="s1">( match[</span><span class="s4">2</span><span class="s1">] === </span><span class="s3">&quot;~=&quot; </span><span class="s1">) { 
                            match[</span><span class="s4">3</span><span class="s1">] = </span><span class="s3">&quot; &quot; </span><span class="s1">+ match[</span><span class="s4">3</span><span class="s1">] + </span><span class="s3">&quot; &quot;</span><span class="s1">; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">match.slice( </span><span class="s4">0</span><span class="s1">, </span><span class="s4">4 </span><span class="s1">); 
                    }, 
 
                    </span><span class="s3">&quot;CHILD&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( match ) { 
                        </span><span class="s0">/* matches from matchExpr[&quot;CHILD&quot;] 
                         1 type (only|nth|...) 
                         2 what (child|of-type) 
                         3 argument (even|odd|\d*|\d*n([+-]\d+)?|...) 
                         4 xn-component of xn+y argument ([+-]?\d*n|) 
                         5 sign of xn-component 
                         6 x of xn-component 
                         7 sign of y-component 
                         8 y of y-component 
                         */</span><span class="s1"> 
                        match[</span><span class="s4">1</span><span class="s1">] = match[</span><span class="s4">1</span><span class="s1">].toLowerCase(); 
 
                        </span><span class="s2">if </span><span class="s1">( match[</span><span class="s4">1</span><span class="s1">].slice( </span><span class="s4">0</span><span class="s1">, </span><span class="s4">3 </span><span class="s1">) === </span><span class="s3">&quot;nth&quot; </span><span class="s1">) { 
                            </span><span class="s0">// nth-* requires argument</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( !match[</span><span class="s4">3</span><span class="s1">] ) { 
                                Sizzle.error( match[</span><span class="s4">0</span><span class="s1">] ); 
                            } 
 
                            </span><span class="s0">// numeric x and y parameters for Expr.filter.CHILD</span><span class="s1"> 
                            </span><span class="s0">// remember that false/true cast respectively to 0/1</span><span class="s1"> 
                            match[</span><span class="s4">4</span><span class="s1">] = +( match[</span><span class="s4">4</span><span class="s1">] ? match[</span><span class="s4">5</span><span class="s1">] + (match[</span><span class="s4">6</span><span class="s1">] || </span><span class="s4">1</span><span class="s1">) : </span><span class="s4">2 </span><span class="s1">* ( match[</span><span class="s4">3</span><span class="s1">] === </span><span class="s3">&quot;even&quot; </span><span class="s1">|| match[</span><span class="s4">3</span><span class="s1">] === </span><span class="s3">&quot;odd&quot; </span><span class="s1">) ); 
                            match[</span><span class="s4">5</span><span class="s1">] = +( ( match[</span><span class="s4">7</span><span class="s1">] + match[</span><span class="s4">8</span><span class="s1">] ) || match[</span><span class="s4">3</span><span class="s1">] === </span><span class="s3">&quot;odd&quot; </span><span class="s1">); 
 
                            </span><span class="s0">// other types prohibit arguments</span><span class="s1"> 
                        } </span><span class="s2">else if </span><span class="s1">( match[</span><span class="s4">3</span><span class="s1">] ) { 
                            Sizzle.error( match[</span><span class="s4">0</span><span class="s1">] ); 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">match; 
                    }, 
 
                    </span><span class="s3">&quot;PSEUDO&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( match ) { 
                        </span><span class="s2">var </span><span class="s1">excess, 
                            unquoted = !match[</span><span class="s4">6</span><span class="s1">] &amp;&amp; match[</span><span class="s4">2</span><span class="s1">]; 
 
                        </span><span class="s2">if </span><span class="s1">( matchExpr[</span><span class="s3">&quot;CHILD&quot;</span><span class="s1">].test( match[</span><span class="s4">0</span><span class="s1">] ) ) { 
                            </span><span class="s2">return null</span><span class="s1">; 
                        } 
 
                        </span><span class="s0">// Accept quoted arguments as-is</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( match[</span><span class="s4">3</span><span class="s1">] ) { 
                            match[</span><span class="s4">2</span><span class="s1">] = match[</span><span class="s4">4</span><span class="s1">] || match[</span><span class="s4">5</span><span class="s1">] || </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
                            </span><span class="s0">// Strip excess characters from unquoted arguments</span><span class="s1"> 
                        } </span><span class="s2">else if </span><span class="s1">( unquoted &amp;&amp; rpseudo.test( unquoted ) &amp;&amp; 
                                </span><span class="s0">// Get excess from tokenize (recursively)</span><span class="s1"> 
                            (excess = tokenize( unquoted, </span><span class="s2">true </span><span class="s1">)) &amp;&amp; 
                                </span><span class="s0">// advance to the next closing parenthesis</span><span class="s1"> 
                            (excess = unquoted.indexOf( </span><span class="s3">&quot;)&quot;</span><span class="s1">, unquoted.length - excess ) - unquoted.length) ) { 
 
                            </span><span class="s0">// excess is a negative index</span><span class="s1"> 
                            match[</span><span class="s4">0</span><span class="s1">] = match[</span><span class="s4">0</span><span class="s1">].slice( </span><span class="s4">0</span><span class="s1">, excess ); 
                            match[</span><span class="s4">2</span><span class="s1">] = unquoted.slice( </span><span class="s4">0</span><span class="s1">, excess ); 
                        } 
 
                        </span><span class="s0">// Return only captures needed by the pseudo filter method (type and argument)</span><span class="s1"> 
                        </span><span class="s2">return </span><span class="s1">match.slice( </span><span class="s4">0</span><span class="s1">, </span><span class="s4">3 </span><span class="s1">); 
                    } 
                }, 
 
                filter: { 
 
                    </span><span class="s3">&quot;TAG&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( nodeNameSelector ) { 
                        </span><span class="s2">var </span><span class="s1">nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase(); 
                        </span><span class="s2">return </span><span class="s1">nodeNameSelector === </span><span class="s3">&quot;*&quot; </span><span class="s1">? 
                            </span><span class="s2">function</span><span class="s1">() { </span><span class="s2">return true</span><span class="s1">; } : 
                            </span><span class="s2">function</span><span class="s1">( elem ) { 
                                </span><span class="s2">return </span><span class="s1">elem.nodeName &amp;&amp; elem.nodeName.toLowerCase() === nodeName; 
                            }; 
                    }, 
 
                    </span><span class="s3">&quot;CLASS&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( className ) { 
                        </span><span class="s2">var </span><span class="s1">pattern = classCache[ className + </span><span class="s3">&quot; &quot; </span><span class="s1">]; 
 
                        </span><span class="s2">return </span><span class="s1">pattern || 
                            (pattern = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;(^|&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;)&quot; </span><span class="s1">+ className + </span><span class="s3">&quot;(&quot; </span><span class="s1">+ whitespace + </span><span class="s3">&quot;|$)&quot; </span><span class="s1">)) &amp;&amp; 
                            classCache( className, </span><span class="s2">function</span><span class="s1">( elem ) { 
                                </span><span class="s2">return </span><span class="s1">pattern.test( </span><span class="s2">typeof </span><span class="s1">elem.className === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; elem.className || </span><span class="s2">typeof </span><span class="s1">elem.getAttribute !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; elem.getAttribute(</span><span class="s3">&quot;class&quot;</span><span class="s1">) || </span><span class="s3">&quot;&quot; </span><span class="s1">); 
                            }); 
                    }, 
 
                    </span><span class="s3">&quot;ATTR&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( name, operator, check ) { 
                        </span><span class="s2">return function</span><span class="s1">( elem ) { 
                            </span><span class="s2">var </span><span class="s1">result = Sizzle.attr( elem, name ); 
 
                            </span><span class="s2">if </span><span class="s1">( result == </span><span class="s2">null </span><span class="s1">) { 
                                </span><span class="s2">return </span><span class="s1">operator === </span><span class="s3">&quot;!=&quot;</span><span class="s1">; 
                            } 
                            </span><span class="s2">if </span><span class="s1">( !operator ) { 
                                </span><span class="s2">return true</span><span class="s1">; 
                            } 
 
                            result += </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
                            </span><span class="s2">return </span><span class="s1">operator === </span><span class="s3">&quot;=&quot; </span><span class="s1">? result === check : 
                                operator === </span><span class="s3">&quot;!=&quot; </span><span class="s1">? result !== check : 
                                    operator === </span><span class="s3">&quot;^=&quot; </span><span class="s1">? check &amp;&amp; result.indexOf( check ) === </span><span class="s4">0 </span><span class="s1">: 
                                        operator === </span><span class="s3">&quot;*=&quot; </span><span class="s1">? check &amp;&amp; result.indexOf( check ) &gt; -</span><span class="s4">1 </span><span class="s1">: 
                                            operator === </span><span class="s3">&quot;$=&quot; </span><span class="s1">? check &amp;&amp; result.slice( -check.length ) === check : 
                                                operator === </span><span class="s3">&quot;~=&quot; </span><span class="s1">? ( </span><span class="s3">&quot; &quot; </span><span class="s1">+ result.replace( rwhitespace, </span><span class="s3">&quot; &quot; </span><span class="s1">) + </span><span class="s3">&quot; &quot; </span><span class="s1">).indexOf( check ) &gt; -</span><span class="s4">1 </span><span class="s1">: 
                                                    operator === </span><span class="s3">&quot;|=&quot; </span><span class="s1">? result === check || result.slice( </span><span class="s4">0</span><span class="s1">, check.length + </span><span class="s4">1 </span><span class="s1">) === check + </span><span class="s3">&quot;-&quot; </span><span class="s1">: 
                                                        </span><span class="s2">false</span><span class="s1">; 
                        }; 
                    }, 
 
                    </span><span class="s3">&quot;CHILD&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( type, what, argument, first, last ) { 
                        </span><span class="s2">var </span><span class="s1">simple = type.slice( </span><span class="s4">0</span><span class="s1">, </span><span class="s4">3 </span><span class="s1">) !== </span><span class="s3">&quot;nth&quot;</span><span class="s1">, 
                            forward = type.slice( -</span><span class="s4">4 </span><span class="s1">) !== </span><span class="s3">&quot;last&quot;</span><span class="s1">, 
                            ofType = what === </span><span class="s3">&quot;of-type&quot;</span><span class="s1">; 
 
                        </span><span class="s2">return </span><span class="s1">first === </span><span class="s4">1 </span><span class="s1">&amp;&amp; last === </span><span class="s4">0 </span><span class="s1">? 
 
                            </span><span class="s0">// Shortcut for :nth-*(n)</span><span class="s1"> 
                            </span><span class="s2">function</span><span class="s1">( elem ) { 
                                </span><span class="s2">return </span><span class="s1">!!elem.parentNode; 
                            } : 
 
                            </span><span class="s2">function</span><span class="s1">( elem, context, xml ) { 
                                </span><span class="s2">var </span><span class="s1">cache, uniqueCache, outerCache, node, nodeIndex, start, 
                                    dir = simple !== forward ? </span><span class="s3">&quot;nextSibling&quot; </span><span class="s1">: </span><span class="s3">&quot;previousSibling&quot;</span><span class="s1">, 
                                    parent = elem.parentNode, 
                                    name = ofType &amp;&amp; elem.nodeName.toLowerCase(), 
                                    useCache = !xml &amp;&amp; !ofType, 
                                    diff = </span><span class="s2">false</span><span class="s1">; 
 
                                </span><span class="s2">if </span><span class="s1">( parent ) { 
 
                                    </span><span class="s0">// :(first|last|only)-(child|of-type)</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( simple ) { 
                                        </span><span class="s2">while </span><span class="s1">( dir ) { 
                                            node = elem; 
                                            </span><span class="s2">while </span><span class="s1">( (node = node[ dir ]) ) { 
                                                </span><span class="s2">if </span><span class="s1">( ofType ? 
                                                    node.nodeName.toLowerCase() === name : 
                                                    node.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
 
                                                    </span><span class="s2">return false</span><span class="s1">; 
                                                } 
                                            } 
                                            </span><span class="s0">// Reverse direction for :only-* (if we haven't yet done so)</span><span class="s1"> 
                                            start = dir = type === </span><span class="s3">&quot;only&quot; </span><span class="s1">&amp;&amp; !start &amp;&amp; </span><span class="s3">&quot;nextSibling&quot;</span><span class="s1">; 
                                        } 
                                        </span><span class="s2">return true</span><span class="s1">; 
                                    } 
 
                                    start = [ forward ? parent.firstChild : parent.lastChild ]; 
 
                                    </span><span class="s0">// non-xml :nth-child(...) stores cache data on `parent`</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( forward &amp;&amp; useCache ) { 
 
                                        </span><span class="s0">// Seek `elem` from a previously-cached index</span><span class="s1"> 
 
                                        </span><span class="s0">// ...in a gzip-friendly way</span><span class="s1"> 
                                        node = parent; 
                                        outerCache = node[ expando ] || (node[ expando ] = {}); 
 
                                        </span><span class="s0">// Support: IE &lt;9 only</span><span class="s1"> 
                                        </span><span class="s0">// Defend against cloned attroperties (jQuery gh-1709)</span><span class="s1"> 
                                        uniqueCache = outerCache[ node.uniqueID ] || 
                                            (outerCache[ node.uniqueID ] = {}); 
 
                                        cache = uniqueCache[ type ] || []; 
                                        nodeIndex = cache[ </span><span class="s4">0 </span><span class="s1">] === dirruns &amp;&amp; cache[ </span><span class="s4">1 </span><span class="s1">]; 
                                        diff = nodeIndex &amp;&amp; cache[ </span><span class="s4">2 </span><span class="s1">]; 
                                        node = nodeIndex &amp;&amp; parent.childNodes[ nodeIndex ]; 
 
                                        </span><span class="s2">while </span><span class="s1">( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] || 
 
                                                </span><span class="s0">// Fallback to seeking `elem` from the start</span><span class="s1"> 
                                            (diff = nodeIndex = </span><span class="s4">0</span><span class="s1">) || start.pop()) ) { 
 
                                            </span><span class="s0">// When found, cache indexes on `parent` and break</span><span class="s1"> 
                                            </span><span class="s2">if </span><span class="s1">( node.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; ++diff &amp;&amp; node === elem ) { 
                                                uniqueCache[ type ] = [ dirruns, nodeIndex, diff ]; 
                                                </span><span class="s2">break</span><span class="s1">; 
                                            } 
                                        } 
 
                                    } </span><span class="s2">else </span><span class="s1">{ 
                                        </span><span class="s0">// Use previously-cached element index if available</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( useCache ) { 
                                            </span><span class="s0">// ...in a gzip-friendly way</span><span class="s1"> 
                                            node = elem; 
                                            outerCache = node[ expando ] || (node[ expando ] = {}); 
 
                                            </span><span class="s0">// Support: IE &lt;9 only</span><span class="s1"> 
                                            </span><span class="s0">// Defend against cloned attroperties (jQuery gh-1709)</span><span class="s1"> 
                                            uniqueCache = outerCache[ node.uniqueID ] || 
                                                (outerCache[ node.uniqueID ] = {}); 
 
                                            cache = uniqueCache[ type ] || []; 
                                            nodeIndex = cache[ </span><span class="s4">0 </span><span class="s1">] === dirruns &amp;&amp; cache[ </span><span class="s4">1 </span><span class="s1">]; 
                                            diff = nodeIndex; 
                                        } 
 
                                        </span><span class="s0">// xml :nth-child(...)</span><span class="s1"> 
                                        </span><span class="s0">// or :nth-last-child(...) or :nth(-last)?-of-type(...)</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( diff === </span><span class="s2">false </span><span class="s1">) { 
                                            </span><span class="s0">// Use the same loop as above to seek `elem` from the start</span><span class="s1"> 
                                            </span><span class="s2">while </span><span class="s1">( (node = ++nodeIndex &amp;&amp; node &amp;&amp; node[ dir ] || 
                                                (diff = nodeIndex = </span><span class="s4">0</span><span class="s1">) || start.pop()) ) { 
 
                                                </span><span class="s2">if </span><span class="s1">( ( ofType ? 
                                                    node.nodeName.toLowerCase() === name : 
                                                    node.nodeType === </span><span class="s4">1 </span><span class="s1">) &amp;&amp; 
                                                    ++diff ) { 
 
                                                    </span><span class="s0">// Cache the index of each encountered element</span><span class="s1"> 
                                                    </span><span class="s2">if </span><span class="s1">( useCache ) { 
                                                        outerCache = node[ expando ] || (node[ expando ] = {}); 
 
                                                        </span><span class="s0">// Support: IE &lt;9 only</span><span class="s1"> 
                                                        </span><span class="s0">// Defend against cloned attroperties (jQuery gh-1709)</span><span class="s1"> 
                                                        uniqueCache = outerCache[ node.uniqueID ] || 
                                                            (outerCache[ node.uniqueID ] = {}); 
 
                                                        uniqueCache[ type ] = [ dirruns, diff ]; 
                                                    } 
 
                                                    </span><span class="s2">if </span><span class="s1">( node === elem ) { 
                                                        </span><span class="s2">break</span><span class="s1">; 
                                                    } 
                                                } 
                                            } 
                                        } 
                                    } 
 
                                    </span><span class="s0">// Incorporate the offset, then check against cycle size</span><span class="s1"> 
                                    diff -= last; 
                                    </span><span class="s2">return </span><span class="s1">diff === first || ( diff % first === </span><span class="s4">0 </span><span class="s1">&amp;&amp; diff / first &gt;= </span><span class="s4">0 </span><span class="s1">); 
                                } 
                            }; 
                    }, 
 
                    </span><span class="s3">&quot;PSEUDO&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( pseudo, argument ) { 
                        </span><span class="s0">// pseudo-class names are case-insensitive</span><span class="s1"> 
                        </span><span class="s0">// http://www.w3.org/TR/selectors/#pseudo-classes</span><span class="s1"> 
                        </span><span class="s0">// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters</span><span class="s1"> 
                        </span><span class="s0">// Remember that setFilters inherits from pseudos</span><span class="s1"> 
                        </span><span class="s2">var </span><span class="s1">args, 
                            fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] || 
                                Sizzle.error( </span><span class="s3">&quot;unsupported pseudo: &quot; </span><span class="s1">+ pseudo ); 
 
                        </span><span class="s0">// The user may use createPseudo to indicate that</span><span class="s1"> 
                        </span><span class="s0">// arguments are needed to create the filter function</span><span class="s1"> 
                        </span><span class="s0">// just as Sizzle does</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( fn[ expando ] ) { 
                            </span><span class="s2">return </span><span class="s1">fn( argument ); 
                        } 
 
                        </span><span class="s0">// But maintain support for old signatures</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( fn.length &gt; </span><span class="s4">1 </span><span class="s1">) { 
                            args = [ pseudo, pseudo, </span><span class="s3">&quot;&quot;</span><span class="s1">, argument ]; 
                            </span><span class="s2">return </span><span class="s1">Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ? 
                                markFunction(</span><span class="s2">function</span><span class="s1">( seed, matches ) { 
                                    </span><span class="s2">var </span><span class="s1">idx, 
                                        matched = fn( seed, argument ), 
                                        i = matched.length; 
                                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                                        idx = indexOf( seed, matched[i] ); 
                                        seed[ idx ] = !( matches[ idx ] = matched[i] ); 
                                    } 
                                }) : 
                                </span><span class="s2">function</span><span class="s1">( elem ) { 
                                    </span><span class="s2">return </span><span class="s1">fn( elem, </span><span class="s4">0</span><span class="s1">, args ); 
                                }; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">fn; 
                    } 
                }, 
 
                pseudos: { 
                    </span><span class="s0">// Potentially complex pseudos</span><span class="s1"> 
                    </span><span class="s3">&quot;not&quot;</span><span class="s1">: markFunction(</span><span class="s2">function</span><span class="s1">( selector ) { 
                        </span><span class="s0">// Trim the selector passed to compile</span><span class="s1"> 
                        </span><span class="s0">// to avoid treating leading and trailing</span><span class="s1"> 
                        </span><span class="s0">// spaces as combinators</span><span class="s1"> 
                        </span><span class="s2">var </span><span class="s1">input = [], 
                            results = [], 
                            matcher = compile( selector.replace( rtrim, </span><span class="s3">&quot;$1&quot; </span><span class="s1">) ); 
 
                        </span><span class="s2">return </span><span class="s1">matcher[ expando ] ? 
                            markFunction(</span><span class="s2">function</span><span class="s1">( seed, matches, context, xml ) { 
                                </span><span class="s2">var </span><span class="s1">elem, 
                                    unmatched = matcher( seed, </span><span class="s2">null</span><span class="s1">, xml, [] ), 
                                    i = seed.length; 
 
                                </span><span class="s0">// Match elements unmatched by `matcher`</span><span class="s1"> 
                                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                                    </span><span class="s2">if </span><span class="s1">( (elem = unmatched[i]) ) { 
                                        seed[i] = !(matches[i] = elem); 
                                    } 
                                } 
                            }) : 
                            </span><span class="s2">function</span><span class="s1">( elem, context, xml ) { 
                                input[</span><span class="s4">0</span><span class="s1">] = elem; 
                                matcher( input, </span><span class="s2">null</span><span class="s1">, xml, results ); 
                                </span><span class="s0">// Don't keep the element (issue #299)</span><span class="s1"> 
                                input[</span><span class="s4">0</span><span class="s1">] = </span><span class="s2">null</span><span class="s1">; 
                                </span><span class="s2">return </span><span class="s1">!results.pop(); 
                            }; 
                    }), 
 
                    </span><span class="s3">&quot;has&quot;</span><span class="s1">: markFunction(</span><span class="s2">function</span><span class="s1">( selector ) { 
                        </span><span class="s2">return function</span><span class="s1">( elem ) { 
                            </span><span class="s2">return </span><span class="s1">Sizzle( selector, elem ).length &gt; </span><span class="s4">0</span><span class="s1">; 
                        }; 
                    }), 
 
                    </span><span class="s3">&quot;contains&quot;</span><span class="s1">: markFunction(</span><span class="s2">function</span><span class="s1">( text ) { 
                        text = text.replace( runescape, funescape ); 
                        </span><span class="s2">return function</span><span class="s1">( elem ) { 
                            </span><span class="s2">return </span><span class="s1">( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) &gt; -</span><span class="s4">1</span><span class="s1">; 
                        }; 
                    }), 
 
                    </span><span class="s0">// &quot;Whether an element is represented by a :lang() selector</span><span class="s1"> 
                    </span><span class="s0">// is based solely on the element's language value</span><span class="s1"> 
                    </span><span class="s0">// being equal to the identifier C,</span><span class="s1"> 
                    </span><span class="s0">// or beginning with the identifier C immediately followed by &quot;-&quot;.</span><span class="s1"> 
                    </span><span class="s0">// The matching of C against the element's language value is performed case-insensitively.</span><span class="s1"> 
                    </span><span class="s0">// The identifier C does not have to be a valid language name.&quot;</span><span class="s1"> 
                    </span><span class="s0">// http://www.w3.org/TR/selectors/#lang-pseudo</span><span class="s1"> 
                    </span><span class="s3">&quot;lang&quot;</span><span class="s1">: markFunction( </span><span class="s2">function</span><span class="s1">( lang ) { 
                        </span><span class="s0">// lang value must be a valid identifier</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( !ridentifier.test(lang || </span><span class="s3">&quot;&quot;</span><span class="s1">) ) { 
                            Sizzle.error( </span><span class="s3">&quot;unsupported lang: &quot; </span><span class="s1">+ lang ); 
                        } 
                        lang = lang.replace( runescape, funescape ).toLowerCase(); 
                        </span><span class="s2">return function</span><span class="s1">( elem ) { 
                            </span><span class="s2">var </span><span class="s1">elemLang; 
                            </span><span class="s2">do </span><span class="s1">{ 
                                </span><span class="s2">if </span><span class="s1">( (elemLang = documentIsHTML ? 
                                        elem.lang : 
                                    elem.getAttribute(</span><span class="s3">&quot;xml:lang&quot;</span><span class="s1">) || elem.getAttribute(</span><span class="s3">&quot;lang&quot;</span><span class="s1">)) ) { 
 
                                    elemLang = elemLang.toLowerCase(); 
                                    </span><span class="s2">return </span><span class="s1">elemLang === lang || elemLang.indexOf( lang + </span><span class="s3">&quot;-&quot; </span><span class="s1">) === </span><span class="s4">0</span><span class="s1">; 
                                } 
                            } </span><span class="s2">while </span><span class="s1">( (elem = elem.parentNode) &amp;&amp; elem.nodeType === </span><span class="s4">1 </span><span class="s1">); 
                            </span><span class="s2">return false</span><span class="s1">; 
                        }; 
                    }), 
 
                    </span><span class="s0">// Miscellaneous</span><span class="s1"> 
                    </span><span class="s3">&quot;target&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">var </span><span class="s1">hash = window.location &amp;&amp; window.location.hash; 
                        </span><span class="s2">return </span><span class="s1">hash &amp;&amp; hash.slice( </span><span class="s4">1 </span><span class="s1">) === elem.id; 
                    }, 
 
                    </span><span class="s3">&quot;root&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">elem === docElem; 
                    }, 
 
                    </span><span class="s3">&quot;focus&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">elem === document.activeElement &amp;&amp; (!document.hasFocus || document.hasFocus()) &amp;&amp; !!(elem.type || elem.href || ~elem.tabIndex); 
                    }, 
 
                    </span><span class="s0">// Boolean properties</span><span class="s1"> 
                    </span><span class="s3">&quot;enabled&quot;</span><span class="s1">: createDisabledPseudo( </span><span class="s2">false </span><span class="s1">), 
                    </span><span class="s3">&quot;disabled&quot;</span><span class="s1">: createDisabledPseudo( </span><span class="s2">true </span><span class="s1">), 
 
                    </span><span class="s3">&quot;checked&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s0">// In CSS3, :checked should return both checked and selected elements</span><span class="s1"> 
                        </span><span class="s0">// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked</span><span class="s1"> 
                        </span><span class="s2">var </span><span class="s1">nodeName = elem.nodeName.toLowerCase(); 
                        </span><span class="s2">return </span><span class="s1">(nodeName === </span><span class="s3">&quot;input&quot; </span><span class="s1">&amp;&amp; !!elem.checked) || (nodeName === </span><span class="s3">&quot;option&quot; </span><span class="s1">&amp;&amp; !!elem.selected); 
                    }, 
 
                    </span><span class="s3">&quot;selected&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s0">// Accessing this property makes selected-by-default</span><span class="s1"> 
                        </span><span class="s0">// options in Safari work properly</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( elem.parentNode ) { 
                            elem.parentNode.selectedIndex; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">elem.selected === </span><span class="s2">true</span><span class="s1">; 
                    }, 
 
                    </span><span class="s0">// Contents</span><span class="s1"> 
                    </span><span class="s3">&quot;empty&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s0">// http://www.w3.org/TR/selectors/#empty-pseudo</span><span class="s1"> 
                        </span><span class="s0">// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),</span><span class="s1"> 
                        </span><span class="s0">//   but not by others (comment: 8; processing instruction: 7; etc.)</span><span class="s1"> 
                        </span><span class="s0">// nodeType &lt; 6 works because attributes (2) do not appear as children</span><span class="s1"> 
                        </span><span class="s2">for </span><span class="s1">( elem = elem.firstChild; elem; elem = elem.nextSibling ) { 
                            </span><span class="s2">if </span><span class="s1">( elem.nodeType &lt; </span><span class="s4">6 </span><span class="s1">) { 
                                </span><span class="s2">return false</span><span class="s1">; 
                            } 
                        } 
                        </span><span class="s2">return true</span><span class="s1">; 
                    }, 
 
                    </span><span class="s3">&quot;parent&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">!Expr.pseudos[</span><span class="s3">&quot;empty&quot;</span><span class="s1">]( elem ); 
                    }, 
 
                    </span><span class="s0">// Element/input types</span><span class="s1"> 
                    </span><span class="s3">&quot;header&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">rheader.test( elem.nodeName ); 
                    }, 
 
                    </span><span class="s3">&quot;input&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">rinputs.test( elem.nodeName ); 
                    }, 
 
                    </span><span class="s3">&quot;button&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">var </span><span class="s1">name = elem.nodeName.toLowerCase(); 
                        </span><span class="s2">return </span><span class="s1">name === </span><span class="s3">&quot;input&quot; </span><span class="s1">&amp;&amp; elem.type === </span><span class="s3">&quot;button&quot; </span><span class="s1">|| name === </span><span class="s3">&quot;button&quot;</span><span class="s1">; 
                    }, 
 
                    </span><span class="s3">&quot;text&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">var </span><span class="s1">attr; 
                        </span><span class="s2">return </span><span class="s1">elem.nodeName.toLowerCase() === </span><span class="s3">&quot;input&quot; </span><span class="s1">&amp;&amp; 
                            elem.type === </span><span class="s3">&quot;text&quot; </span><span class="s1">&amp;&amp; 
 
                                </span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
                                </span><span class="s0">// New HTML5 attribute values (e.g., &quot;search&quot;) appear with elem.type === &quot;text&quot;</span><span class="s1"> 
                            ( (attr = elem.getAttribute(</span><span class="s3">&quot;type&quot;</span><span class="s1">)) == </span><span class="s2">null </span><span class="s1">|| attr.toLowerCase() === </span><span class="s3">&quot;text&quot; </span><span class="s1">); 
                    }, 
 
                    </span><span class="s0">// Position-in-collection</span><span class="s1"> 
                    </span><span class="s3">&quot;first&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">return </span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">]; 
                    }), 
 
                    </span><span class="s3">&quot;last&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes, length ) { 
                        </span><span class="s2">return </span><span class="s1">[ length - </span><span class="s4">1 </span><span class="s1">]; 
                    }), 
 
                    </span><span class="s3">&quot;eq&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes, length, argument ) { 
                        </span><span class="s2">return </span><span class="s1">[ argument &lt; </span><span class="s4">0 </span><span class="s1">? argument + length : argument ]; 
                    }), 
 
                    </span><span class="s3">&quot;even&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes, length ) { 
                        </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; 
                        </span><span class="s2">for </span><span class="s1">( ; i &lt; length; i += </span><span class="s4">2 </span><span class="s1">) { 
                            matchIndexes.push( i ); 
                        } 
                        </span><span class="s2">return </span><span class="s1">matchIndexes; 
                    }), 
 
                    </span><span class="s3">&quot;odd&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes, length ) { 
                        </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">1</span><span class="s1">; 
                        </span><span class="s2">for </span><span class="s1">( ; i &lt; length; i += </span><span class="s4">2 </span><span class="s1">) { 
                            matchIndexes.push( i ); 
                        } 
                        </span><span class="s2">return </span><span class="s1">matchIndexes; 
                    }), 
 
                    </span><span class="s3">&quot;lt&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes, length, argument ) { 
                        </span><span class="s2">var </span><span class="s1">i = argument &lt; </span><span class="s4">0 </span><span class="s1">? argument + length : argument; 
                        </span><span class="s2">for </span><span class="s1">( ; --i &gt;= </span><span class="s4">0</span><span class="s1">; ) { 
                            matchIndexes.push( i ); 
                        } 
                        </span><span class="s2">return </span><span class="s1">matchIndexes; 
                    }), 
 
                    </span><span class="s3">&quot;gt&quot;</span><span class="s1">: createPositionalPseudo(</span><span class="s2">function</span><span class="s1">( matchIndexes, length, argument ) { 
                        </span><span class="s2">var </span><span class="s1">i = argument &lt; </span><span class="s4">0 </span><span class="s1">? argument + length : argument; 
                        </span><span class="s2">for </span><span class="s1">( ; ++i &lt; length; ) { 
                            matchIndexes.push( i ); 
                        } 
                        </span><span class="s2">return </span><span class="s1">matchIndexes; 
                    }) 
                } 
            }; 
 
            Expr.pseudos[</span><span class="s3">&quot;nth&quot;</span><span class="s1">] = Expr.pseudos[</span><span class="s3">&quot;eq&quot;</span><span class="s1">]; 
 
</span><span class="s0">// Add button/input type pseudos</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">{ radio: </span><span class="s2">true</span><span class="s1">, checkbox: </span><span class="s2">true</span><span class="s1">, file: </span><span class="s2">true</span><span class="s1">, password: </span><span class="s2">true</span><span class="s1">, image: </span><span class="s2">true </span><span class="s1">} ) { 
                Expr.pseudos[ i ] = createInputPseudo( i ); 
            } 
            </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">{ submit: </span><span class="s2">true</span><span class="s1">, reset: </span><span class="s2">true </span><span class="s1">} ) { 
                Expr.pseudos[ i ] = createButtonPseudo( i ); 
            } 
 
</span><span class="s0">// Easy API for creating new setFilters</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">setFilters() {} 
            setFilters.prototype = Expr.filters = Expr.pseudos; 
            Expr.setFilters = </span><span class="s2">new </span><span class="s1">setFilters(); 
 
            tokenize = Sizzle.tokenize = </span><span class="s2">function</span><span class="s1">( selector, parseOnly ) { 
                </span><span class="s2">var </span><span class="s1">matched, match, tokens, type, 
                    soFar, groups, preFilters, 
                    cached = tokenCache[ selector + </span><span class="s3">&quot; &quot; </span><span class="s1">]; 
 
                </span><span class="s2">if </span><span class="s1">( cached ) { 
                    </span><span class="s2">return </span><span class="s1">parseOnly ? </span><span class="s4">0 </span><span class="s1">: cached.slice( </span><span class="s4">0 </span><span class="s1">); 
                } 
 
                soFar = selector; 
                groups = []; 
                preFilters = Expr.preFilter; 
 
                </span><span class="s2">while </span><span class="s1">( soFar ) { 
 
                    </span><span class="s0">// Comma and first run</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !matched || (match = rcomma.exec( soFar )) ) { 
                        </span><span class="s2">if </span><span class="s1">( match ) { 
                            </span><span class="s0">// Don't consume trailing commas as valid</span><span class="s1"> 
                            soFar = soFar.slice( match[</span><span class="s4">0</span><span class="s1">].length ) || soFar; 
                        } 
                        groups.push( (tokens = []) ); 
                    } 
 
                    matched = </span><span class="s2">false</span><span class="s1">; 
 
                    </span><span class="s0">// Combinators</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( (match = rcombinators.exec( soFar )) ) { 
                        matched = match.shift(); 
                        tokens.push({ 
                            value: matched, 
                            </span><span class="s0">// Cast descendant combinators to space</span><span class="s1"> 
                            type: match[</span><span class="s4">0</span><span class="s1">].replace( rtrim, </span><span class="s3">&quot; &quot; </span><span class="s1">) 
                        }); 
                        soFar = soFar.slice( matched.length ); 
                    } 
 
                    </span><span class="s0">// Filters</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">Expr.filter ) { 
                        </span><span class="s2">if </span><span class="s1">( (match = matchExpr[ type ].exec( soFar )) &amp;&amp; (!preFilters[ type ] || 
                            (match = preFilters[ type ]( match ))) ) { 
                            matched = match.shift(); 
                            tokens.push({ 
                                value: matched, 
                                type: type, 
                                matches: match 
                            }); 
                            soFar = soFar.slice( matched.length ); 
                        } 
                    } 
 
                    </span><span class="s2">if </span><span class="s1">( !matched ) { 
                        </span><span class="s2">break</span><span class="s1">; 
                    } 
                } 
 
                </span><span class="s0">// Return the length of the invalid excess</span><span class="s1"> 
                </span><span class="s0">// if we're just parsing</span><span class="s1"> 
                </span><span class="s0">// Otherwise, throw an error or return tokens</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">parseOnly ? 
                    soFar.length : 
                    soFar ? 
                        Sizzle.error( selector ) : 
                        </span><span class="s0">// Cache the tokens</span><span class="s1"> 
                        tokenCache( selector, groups ).slice( </span><span class="s4">0 </span><span class="s1">); 
            }; 
 
            </span><span class="s2">function </span><span class="s1">toSelector( tokens ) { 
                </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, 
                    len = tokens.length, 
                    selector = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                    selector += tokens[i].value; 
                } 
                </span><span class="s2">return </span><span class="s1">selector; 
            } 
 
            </span><span class="s2">function </span><span class="s1">addCombinator( matcher, combinator, base ) { 
                </span><span class="s2">var </span><span class="s1">dir = combinator.dir, 
                    skip = combinator.next, 
                    key = skip || dir, 
                    checkNonElements = base &amp;&amp; key === </span><span class="s3">&quot;parentNode&quot;</span><span class="s1">, 
                    doneName = done++; 
 
                </span><span class="s2">return </span><span class="s1">combinator.first ? 
                    </span><span class="s0">// Check against closest ancestor/preceding element</span><span class="s1"> 
                    </span><span class="s2">function</span><span class="s1">( elem, context, xml ) { 
                        </span><span class="s2">while </span><span class="s1">( (elem = elem[ dir ]) ) { 
                            </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">|| checkNonElements ) { 
                                </span><span class="s2">return </span><span class="s1">matcher( elem, context, xml ); 
                            } 
                        } 
                        </span><span class="s2">return false</span><span class="s1">; 
                    } : 
 
                    </span><span class="s0">// Check against all ancestor/preceding elements</span><span class="s1"> 
                    </span><span class="s2">function</span><span class="s1">( elem, context, xml ) { 
                        </span><span class="s2">var </span><span class="s1">oldCache, uniqueCache, outerCache, 
                            newCache = [ dirruns, doneName ]; 
 
                        </span><span class="s0">// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( xml ) { 
                            </span><span class="s2">while </span><span class="s1">( (elem = elem[ dir ]) ) { 
                                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">|| checkNonElements ) { 
                                    </span><span class="s2">if </span><span class="s1">( matcher( elem, context, xml ) ) { 
                                        </span><span class="s2">return true</span><span class="s1">; 
                                    } 
                                } 
                            } 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            </span><span class="s2">while </span><span class="s1">( (elem = elem[ dir ]) ) { 
                                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">|| checkNonElements ) { 
                                    outerCache = elem[ expando ] || (elem[ expando ] = {}); 
 
                                    </span><span class="s0">// Support: IE &lt;9 only</span><span class="s1"> 
                                    </span><span class="s0">// Defend against cloned attroperties (jQuery gh-1709)</span><span class="s1"> 
                                    uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {}); 
 
                                    </span><span class="s2">if </span><span class="s1">( skip &amp;&amp; skip === elem.nodeName.toLowerCase() ) { 
                                        elem = elem[ dir ] || elem; 
                                    } </span><span class="s2">else if </span><span class="s1">( (oldCache = uniqueCache[ key ]) &amp;&amp; 
                                        oldCache[ </span><span class="s4">0 </span><span class="s1">] === dirruns &amp;&amp; oldCache[ </span><span class="s4">1 </span><span class="s1">] === doneName ) { 
 
                                        </span><span class="s0">// Assign to newCache so results back-propagate to previous elements</span><span class="s1"> 
                                        </span><span class="s2">return </span><span class="s1">(newCache[ </span><span class="s4">2 </span><span class="s1">] = oldCache[ </span><span class="s4">2 </span><span class="s1">]); 
                                    } </span><span class="s2">else </span><span class="s1">{ 
                                        </span><span class="s0">// Reuse newcache so results back-propagate to previous elements</span><span class="s1"> 
                                        uniqueCache[ key ] = newCache; 
 
                                        </span><span class="s0">// A match means we're done; a fail means we have to keep checking</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( (newCache[ </span><span class="s4">2 </span><span class="s1">] = matcher( elem, context, xml )) ) { 
                                            </span><span class="s2">return true</span><span class="s1">; 
                                        } 
                                    } 
                                } 
                            } 
                        } 
                        </span><span class="s2">return false</span><span class="s1">; 
                    }; 
            } 
 
            </span><span class="s2">function </span><span class="s1">elementMatcher( matchers ) { 
                </span><span class="s2">return </span><span class="s1">matchers.length &gt; </span><span class="s4">1 </span><span class="s1">? 
                    </span><span class="s2">function</span><span class="s1">( elem, context, xml ) { 
                        </span><span class="s2">var </span><span class="s1">i = matchers.length; 
                        </span><span class="s2">while </span><span class="s1">( i-- ) { 
                            </span><span class="s2">if </span><span class="s1">( !matchers[i]( elem, context, xml ) ) { 
                                </span><span class="s2">return false</span><span class="s1">; 
                            } 
                        } 
                        </span><span class="s2">return true</span><span class="s1">; 
                    } : 
                    matchers[</span><span class="s4">0</span><span class="s1">]; 
            } 
 
            </span><span class="s2">function </span><span class="s1">multipleContexts( selector, contexts, results ) { 
                </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, 
                    len = contexts.length; 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                    Sizzle( selector, contexts[i], results ); 
                } 
                </span><span class="s2">return </span><span class="s1">results; 
            } 
 
            </span><span class="s2">function </span><span class="s1">condense( unmatched, map, filter, context, xml ) { 
                </span><span class="s2">var </span><span class="s1">elem, 
                    newUnmatched = [], 
                    i = </span><span class="s4">0</span><span class="s1">, 
                    len = unmatched.length, 
                    mapped = map != </span><span class="s2">null</span><span class="s1">; 
 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                    </span><span class="s2">if </span><span class="s1">( (elem = unmatched[i]) ) { 
                        </span><span class="s2">if </span><span class="s1">( !filter || filter( elem, context, xml ) ) { 
                            newUnmatched.push( elem ); 
                            </span><span class="s2">if </span><span class="s1">( mapped ) { 
                                map.push( i ); 
                            } 
                        } 
                    } 
                } 
 
                </span><span class="s2">return </span><span class="s1">newUnmatched; 
            } 
 
            </span><span class="s2">function </span><span class="s1">setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) { 
                </span><span class="s2">if </span><span class="s1">( postFilter &amp;&amp; !postFilter[ expando ] ) { 
                    postFilter = setMatcher( postFilter ); 
                } 
                </span><span class="s2">if </span><span class="s1">( postFinder &amp;&amp; !postFinder[ expando ] ) { 
                    postFinder = setMatcher( postFinder, postSelector ); 
                } 
                </span><span class="s2">return </span><span class="s1">markFunction(</span><span class="s2">function</span><span class="s1">( seed, results, context, xml ) { 
                    </span><span class="s2">var </span><span class="s1">temp, i, elem, 
                        preMap = [], 
                        postMap = [], 
                        preexisting = results.length, 
 
                    </span><span class="s0">// Get initial elements from seed or context</span><span class="s1"> 
                        elems = seed || multipleContexts( selector || </span><span class="s3">&quot;*&quot;</span><span class="s1">, context.nodeType ? [ context ] : context, [] ), 
 
                    </span><span class="s0">// Prefilter to get matcher input, preserving a map for seed-results synchronization</span><span class="s1"> 
                        matcherIn = preFilter &amp;&amp; ( seed || !selector ) ? 
                            condense( elems, preMap, preFilter, context, xml ) : 
                            elems, 
 
                        matcherOut = matcher ? 
                            </span><span class="s0">// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,</span><span class="s1"> 
                            postFinder || ( seed ? preFilter : preexisting || postFilter ) ? 
 
                                </span><span class="s0">// ...intermediate processing is necessary</span><span class="s1"> 
                                [] : 
 
                                </span><span class="s0">// ...otherwise use results directly</span><span class="s1"> 
                                results : 
                            matcherIn; 
 
                    </span><span class="s0">// Find primary matches</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( matcher ) { 
                        matcher( matcherIn, matcherOut, context, xml ); 
                    } 
 
                    </span><span class="s0">// Apply postFilter</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( postFilter ) { 
                        temp = condense( matcherOut, postMap ); 
                        postFilter( temp, [], context, xml ); 
 
                        </span><span class="s0">// Un-match failing elements by moving them back to matcherIn</span><span class="s1"> 
                        i = temp.length; 
                        </span><span class="s2">while </span><span class="s1">( i-- ) { 
                            </span><span class="s2">if </span><span class="s1">( (elem = temp[i]) ) { 
                                matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem); 
                            } 
                        } 
                    } 
 
                    </span><span class="s2">if </span><span class="s1">( seed ) { 
                        </span><span class="s2">if </span><span class="s1">( postFinder || preFilter ) { 
                            </span><span class="s2">if </span><span class="s1">( postFinder ) { 
                                </span><span class="s0">// Get the final matcherOut by condensing this intermediate into postFinder contexts</span><span class="s1"> 
                                temp = []; 
                                i = matcherOut.length; 
                                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                                    </span><span class="s2">if </span><span class="s1">( (elem = matcherOut[i]) ) { 
                                        </span><span class="s0">// Restore matcherIn since elem is not yet a final match</span><span class="s1"> 
                                        temp.push( (matcherIn[i] = elem) ); 
                                    } 
                                } 
                                postFinder( </span><span class="s2">null</span><span class="s1">, (matcherOut = []), temp, xml ); 
                            } 
 
                            </span><span class="s0">// Move matched elements from seed to results to keep them synchronized</span><span class="s1"> 
                            i = matcherOut.length; 
                            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                                </span><span class="s2">if </span><span class="s1">( (elem = matcherOut[i]) &amp;&amp; 
                                    (temp = postFinder ? indexOf( seed, elem ) : preMap[i]) &gt; -</span><span class="s4">1 </span><span class="s1">) { 
 
                                    seed[temp] = !(results[temp] = elem); 
                                } 
                            } 
                        } 
 
                        </span><span class="s0">// Add elements to results, through postFinder if defined</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        matcherOut = condense( 
                            matcherOut === results ? 
                                matcherOut.splice( preexisting, matcherOut.length ) : 
                                matcherOut 
                        ); 
                        </span><span class="s2">if </span><span class="s1">( postFinder ) { 
                            postFinder( </span><span class="s2">null</span><span class="s1">, results, matcherOut, xml ); 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            push.apply( results, matcherOut ); 
                        } 
                    } 
                }); 
            } 
 
            </span><span class="s2">function </span><span class="s1">matcherFromTokens( tokens ) { 
                </span><span class="s2">var </span><span class="s1">checkContext, matcher, j, 
                    len = tokens.length, 
                    leadingRelative = Expr.relative[ tokens[</span><span class="s4">0</span><span class="s1">].type ], 
                    implicitRelative = leadingRelative || Expr.relative[</span><span class="s3">&quot; &quot;</span><span class="s1">], 
                    i = leadingRelative ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">, 
 
                </span><span class="s0">// The foundational matcher ensures that elements are reachable from top-level context(s)</span><span class="s1"> 
                    matchContext = addCombinator( </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">elem === checkContext; 
                    }, implicitRelative, </span><span class="s2">true </span><span class="s1">), 
                    matchAnyContext = addCombinator( </span><span class="s2">function</span><span class="s1">( elem ) { 
                        </span><span class="s2">return </span><span class="s1">indexOf( checkContext, elem ) &gt; -</span><span class="s4">1</span><span class="s1">; 
                    }, implicitRelative, </span><span class="s2">true </span><span class="s1">), 
                    matchers = [ </span><span class="s2">function</span><span class="s1">( elem, context, xml ) { 
                        </span><span class="s2">var </span><span class="s1">ret = ( !leadingRelative &amp;&amp; ( xml || context !== outermostContext ) ) || ( 
                                (checkContext = context).nodeType ? 
                                    matchContext( elem, context, xml ) : 
                                    matchAnyContext( elem, context, xml ) ); 
                        </span><span class="s0">// Avoid hanging onto element (issue #299)</span><span class="s1"> 
                        checkContext = </span><span class="s2">null</span><span class="s1">; 
                        </span><span class="s2">return </span><span class="s1">ret; 
                    } ]; 
 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                    </span><span class="s2">if </span><span class="s1">( (matcher = Expr.relative[ tokens[i].type ]) ) { 
                        matchers = [ addCombinator(elementMatcher( matchers ), matcher) ]; 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        matcher = Expr.filter[ tokens[i].type ].apply( </span><span class="s2">null</span><span class="s1">, tokens[i].matches ); 
 
                        </span><span class="s0">// Return special upon seeing a positional matcher</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( matcher[ expando ] ) { 
                            </span><span class="s0">// Find the next relative operator (if any) for proper handling</span><span class="s1"> 
                            j = ++i; 
                            </span><span class="s2">for </span><span class="s1">( ; j &lt; len; j++ ) { 
                                </span><span class="s2">if </span><span class="s1">( Expr.relative[ tokens[j].type ] ) { 
                                    </span><span class="s2">break</span><span class="s1">; 
                                } 
                            } 
                            </span><span class="s2">return </span><span class="s1">setMatcher( 
                                i &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; elementMatcher( matchers ), 
                                i &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; toSelector( 
                                    </span><span class="s0">// If the preceding token was a descendant combinator, insert an implicit any-element `*`</span><span class="s1"> 
                                    tokens.slice( </span><span class="s4">0</span><span class="s1">, i - </span><span class="s4">1 </span><span class="s1">).concat({ value: tokens[ i - </span><span class="s4">2 </span><span class="s1">].type === </span><span class="s3">&quot; &quot; </span><span class="s1">? </span><span class="s3">&quot;*&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot; </span><span class="s1">}) 
                                ).replace( rtrim, </span><span class="s3">&quot;$1&quot; </span><span class="s1">), 
                                matcher, 
                                i &lt; j &amp;&amp; matcherFromTokens( tokens.slice( i, j ) ), 
                                j &lt; len &amp;&amp; matcherFromTokens( (tokens = tokens.slice( j )) ), 
                                j &lt; len &amp;&amp; toSelector( tokens ) 
                            ); 
                        } 
                        matchers.push( matcher ); 
                    } 
                } 
 
                </span><span class="s2">return </span><span class="s1">elementMatcher( matchers ); 
            } 
 
            </span><span class="s2">function </span><span class="s1">matcherFromGroupMatchers( elementMatchers, setMatchers ) { 
                </span><span class="s2">var </span><span class="s1">bySet = setMatchers.length &gt; </span><span class="s4">0</span><span class="s1">, 
                    byElement = elementMatchers.length &gt; </span><span class="s4">0</span><span class="s1">, 
                    superMatcher = </span><span class="s2">function</span><span class="s1">( seed, context, xml, results, outermost ) { 
                        </span><span class="s2">var </span><span class="s1">elem, j, matcher, 
                            matchedCount = </span><span class="s4">0</span><span class="s1">, 
                            i = </span><span class="s3">&quot;0&quot;</span><span class="s1">, 
                            unmatched = seed &amp;&amp; [], 
                            setMatched = [], 
                            contextBackup = outermostContext, 
                        </span><span class="s0">// We must always have either seed elements or outermost context</span><span class="s1"> 
                            elems = seed || byElement &amp;&amp; Expr.find[</span><span class="s3">&quot;TAG&quot;</span><span class="s1">]( </span><span class="s3">&quot;*&quot;</span><span class="s1">, outermost ), 
                        </span><span class="s0">// Use integer dirruns iff this is the outermost matcher</span><span class="s1"> 
                            dirrunsUnique = (dirruns += contextBackup == </span><span class="s2">null </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: Math.random() || </span><span class="s4">0.1</span><span class="s1">), 
                            len = elems.length; 
 
                        </span><span class="s2">if </span><span class="s1">( outermost ) { 
                            outermostContext = context === document || context || outermost; 
                        } 
 
                        </span><span class="s0">// Add elements passing elementMatchers directly to results</span><span class="s1"> 
                        </span><span class="s0">// Support: IE&lt;9, Safari</span><span class="s1"> 
                        </span><span class="s0">// Tolerate NodeList properties (IE: &quot;length&quot;; Safari: &lt;number&gt;) matching elements by id</span><span class="s1"> 
                        </span><span class="s2">for </span><span class="s1">( ; i !== len &amp;&amp; (elem = elems[i]) != </span><span class="s2">null</span><span class="s1">; i++ ) { 
                            </span><span class="s2">if </span><span class="s1">( byElement &amp;&amp; elem ) { 
                                j = </span><span class="s4">0</span><span class="s1">; 
                                </span><span class="s2">if </span><span class="s1">( !context &amp;&amp; elem.ownerDocument !== document ) { 
                                    setDocument( elem ); 
                                    xml = !documentIsHTML; 
                                } 
                                </span><span class="s2">while </span><span class="s1">( (matcher = elementMatchers[j++]) ) { 
                                    </span><span class="s2">if </span><span class="s1">( matcher( elem, context || document, xml) ) { 
                                        results.push( elem ); 
                                        </span><span class="s2">break</span><span class="s1">; 
                                    } 
                                } 
                                </span><span class="s2">if </span><span class="s1">( outermost ) { 
                                    dirruns = dirrunsUnique; 
                                } 
                            } 
 
                            </span><span class="s0">// Track unmatched elements for set filters</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( bySet ) { 
                                </span><span class="s0">// They will have gone through all possible matchers</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( (elem = !matcher &amp;&amp; elem) ) { 
                                    matchedCount--; 
                                } 
 
                                </span><span class="s0">// Lengthen the array for every element, matched or not</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( seed ) { 
                                    unmatched.push( elem ); 
                                } 
                            } 
                        } 
 
                        </span><span class="s0">// `i` is now the count of elements visited above, and adding it to `matchedCount`</span><span class="s1"> 
                        </span><span class="s0">// makes the latter nonnegative.</span><span class="s1"> 
                        matchedCount += i; 
 
                        </span><span class="s0">// Apply set filters to unmatched elements</span><span class="s1"> 
                        </span><span class="s0">// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`</span><span class="s1"> 
                        </span><span class="s0">// equals `i`), unless we didn't visit _any_ elements in the above loop because we have</span><span class="s1"> 
                        </span><span class="s0">// no element matchers and no seed.</span><span class="s1"> 
                        </span><span class="s0">// Incrementing an initially-string &quot;0&quot; `i` allows `i` to remain a string only in that</span><span class="s1"> 
                        </span><span class="s0">// case, which will result in a &quot;00&quot; `matchedCount` that differs from `i` but is also</span><span class="s1"> 
                        </span><span class="s0">// numerically zero.</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( bySet &amp;&amp; i !== matchedCount ) { 
                            j = </span><span class="s4">0</span><span class="s1">; 
                            </span><span class="s2">while </span><span class="s1">( (matcher = setMatchers[j++]) ) { 
                                matcher( unmatched, setMatched, context, xml ); 
                            } 
 
                            </span><span class="s2">if </span><span class="s1">( seed ) { 
                                </span><span class="s0">// Reintegrate element matches to eliminate the need for sorting</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( matchedCount &gt; </span><span class="s4">0 </span><span class="s1">) { 
                                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                                        </span><span class="s2">if </span><span class="s1">( !(unmatched[i] || setMatched[i]) ) { 
                                            setMatched[i] = pop.call( results ); 
                                        } 
                                    } 
                                } 
 
                                </span><span class="s0">// Discard index placeholder values to get only actual matches</span><span class="s1"> 
                                setMatched = condense( setMatched ); 
                            } 
 
                            </span><span class="s0">// Add matches to results</span><span class="s1"> 
                            push.apply( results, setMatched ); 
 
                            </span><span class="s0">// Seedless set matches succeeding multiple successful matchers stipulate sorting</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( outermost &amp;&amp; !seed &amp;&amp; setMatched.length &gt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; 
                                ( matchedCount + setMatchers.length ) &gt; </span><span class="s4">1 </span><span class="s1">) { 
 
                                Sizzle.uniqueSort( results ); 
                            } 
                        } 
 
                        </span><span class="s0">// Override manipulation of globals by nested matchers</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( outermost ) { 
                            dirruns = dirrunsUnique; 
                            outermostContext = contextBackup; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">unmatched; 
                    }; 
 
                </span><span class="s2">return </span><span class="s1">bySet ? 
                    markFunction( superMatcher ) : 
                    superMatcher; 
            } 
 
            compile = Sizzle.compile = </span><span class="s2">function</span><span class="s1">( selector, match </span><span class="s0">/* Internal Use Only */ </span><span class="s1">) { 
                </span><span class="s2">var </span><span class="s1">i, 
                    setMatchers = [], 
                    elementMatchers = [], 
                    cached = compilerCache[ selector + </span><span class="s3">&quot; &quot; </span><span class="s1">]; 
 
                </span><span class="s2">if </span><span class="s1">( !cached ) { 
                    </span><span class="s0">// Generate a function of recursive functions that can be used to check each element</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !match ) { 
                        match = tokenize( selector ); 
                    } 
                    i = match.length; 
                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                        cached = matcherFromTokens( match[i] ); 
                        </span><span class="s2">if </span><span class="s1">( cached[ expando ] ) { 
                            setMatchers.push( cached ); 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            elementMatchers.push( cached ); 
                        } 
                    } 
 
                    </span><span class="s0">// Cache the compiled function</span><span class="s1"> 
                    cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) ); 
 
                    </span><span class="s0">// Save selector and tokenization</span><span class="s1"> 
                    cached.selector = selector; 
                } 
                </span><span class="s2">return </span><span class="s1">cached; 
            }; 
 
            </span><span class="s0">/** 
             * A low-level selection function that works with Sizzle's compiled 
             *  selector functions 
             * </span><span class="s5">@param </span><span class="s0">{String|Function} selector A selector or a pre-compiled 
             *  selector function built with Sizzle.compile 
             * </span><span class="s5">@param </span><span class="s0">{Element} context 
             * </span><span class="s5">@param </span><span class="s0">{Array} [results] 
             * </span><span class="s5">@param </span><span class="s0">{Array} [seed] A set of elements to match against 
             */</span><span class="s1"> 
            select = Sizzle.select = </span><span class="s2">function</span><span class="s1">( selector, context, results, seed ) { 
                </span><span class="s2">var </span><span class="s1">i, tokens, token, type, find, 
                    compiled = </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp; selector, 
                    match = !seed &amp;&amp; tokenize( (selector = compiled.selector || selector) ); 
 
                results = results || []; 
 
                </span><span class="s0">// Try to minimize operations if there is only one selector in the list and no seed</span><span class="s1"> 
                </span><span class="s0">// (the latter of which guarantees us context)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( match.length === </span><span class="s4">1 </span><span class="s1">) { 
 
                    </span><span class="s0">// Reduce context if the leading compound selector is an ID</span><span class="s1"> 
                    tokens = match[</span><span class="s4">0</span><span class="s1">] = match[</span><span class="s4">0</span><span class="s1">].slice( </span><span class="s4">0 </span><span class="s1">); 
                    </span><span class="s2">if </span><span class="s1">( tokens.length &gt; </span><span class="s4">2 </span><span class="s1">&amp;&amp; (token = tokens[</span><span class="s4">0</span><span class="s1">]).type === </span><span class="s3">&quot;ID&quot; </span><span class="s1">&amp;&amp; 
                        context.nodeType === </span><span class="s4">9 </span><span class="s1">&amp;&amp; documentIsHTML &amp;&amp; Expr.relative[ tokens[</span><span class="s4">1</span><span class="s1">].type ] ) { 
 
                        context = ( Expr.find[</span><span class="s3">&quot;ID&quot;</span><span class="s1">]( token.matches[</span><span class="s4">0</span><span class="s1">].replace(runescape, funescape), context ) || [] )[</span><span class="s4">0</span><span class="s1">]; 
                        </span><span class="s2">if </span><span class="s1">( !context ) { 
                            </span><span class="s2">return </span><span class="s1">results; 
 
                            </span><span class="s0">// Precompiled matchers will still verify ancestry, so step up a level</span><span class="s1"> 
                        } </span><span class="s2">else if </span><span class="s1">( compiled ) { 
                            context = context.parentNode; 
                        } 
 
                        selector = selector.slice( tokens.shift().value.length ); 
                    } 
 
                    </span><span class="s0">// Fetch a seed set for right-to-left matching</span><span class="s1"> 
                    i = matchExpr[</span><span class="s3">&quot;needsContext&quot;</span><span class="s1">].test( selector ) ? </span><span class="s4">0 </span><span class="s1">: tokens.length; 
                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                        token = tokens[i]; 
 
                        </span><span class="s0">// Abort if we hit a combinator</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( Expr.relative[ (type = token.type) ] ) { 
                            </span><span class="s2">break</span><span class="s1">; 
                        } 
                        </span><span class="s2">if </span><span class="s1">( (find = Expr.find[ type ]) ) { 
                            </span><span class="s0">// Search, expanding context for leading sibling combinators</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( (seed = find( 
                                    token.matches[</span><span class="s4">0</span><span class="s1">].replace( runescape, funescape ), 
                                    rsibling.test( tokens[</span><span class="s4">0</span><span class="s1">].type ) &amp;&amp; testContext( context.parentNode ) || context 
                                )) ) { 
 
                                </span><span class="s0">// If seed is empty or no tokens remain, we can return early</span><span class="s1"> 
                                tokens.splice( i, </span><span class="s4">1 </span><span class="s1">); 
                                selector = seed.length &amp;&amp; toSelector( tokens ); 
                                </span><span class="s2">if </span><span class="s1">( !selector ) { 
                                    push.apply( results, seed ); 
                                    </span><span class="s2">return </span><span class="s1">results; 
                                } 
 
                                </span><span class="s2">break</span><span class="s1">; 
                            } 
                        } 
                    } 
                } 
 
                </span><span class="s0">// Compile and execute a filtering function if one is not provided</span><span class="s1"> 
                </span><span class="s0">// Provide `match` to avoid retokenization if we modified the selector above</span><span class="s1"> 
                ( compiled || compile( selector, match ) )( 
                    seed, 
                    context, 
                    !documentIsHTML, 
                    results, 
                    !context || rsibling.test( selector ) &amp;&amp; testContext( context.parentNode ) || context 
                ); 
                </span><span class="s2">return </span><span class="s1">results; 
            }; 
 
</span><span class="s0">// One-time assignments</span><span class="s1"> 
 
</span><span class="s0">// Sort stability</span><span class="s1"> 
            support.sortStable = expando.split(</span><span class="s3">&quot;&quot;</span><span class="s1">).sort( sortOrder ).join(</span><span class="s3">&quot;&quot;</span><span class="s1">) === expando; 
 
</span><span class="s0">// Support: Chrome 14-35+</span><span class="s1"> 
</span><span class="s0">// Always assume duplicates if they aren't passed to the comparison function</span><span class="s1"> 
            support.detectDuplicates = !!hasDuplicate; 
 
</span><span class="s0">// Initialize against the default document</span><span class="s1"> 
            setDocument(); 
 
</span><span class="s0">// Support: Webkit&lt;537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)</span><span class="s1"> 
</span><span class="s0">// Detached nodes confoundingly follow *each other*</span><span class="s1"> 
            support.sortDetached = assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                </span><span class="s0">// Should return 1, but returns 4 (following)</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">el.compareDocumentPosition( document.createElement(</span><span class="s3">&quot;fieldset&quot;</span><span class="s1">) ) &amp; </span><span class="s4">1</span><span class="s1">; 
            }); 
 
</span><span class="s0">// Support: IE&lt;8</span><span class="s1"> 
</span><span class="s0">// Prevent attribute/property &quot;interpolation&quot;</span><span class="s1"> 
</span><span class="s0">// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                    el.innerHTML = </span><span class="s3">&quot;&lt;a href='#'&gt;&lt;/a&gt;&quot;</span><span class="s1">; 
                    </span><span class="s2">return </span><span class="s1">el.firstChild.getAttribute(</span><span class="s3">&quot;href&quot;</span><span class="s1">) === </span><span class="s3">&quot;#&quot; </span><span class="s1">; 
                }) ) { 
                addHandle( </span><span class="s3">&quot;type|href|height|width&quot;</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( elem, name, isXML ) { 
                    </span><span class="s2">if </span><span class="s1">( !isXML ) { 
                        </span><span class="s2">return </span><span class="s1">elem.getAttribute( name, name.toLowerCase() === </span><span class="s3">&quot;type&quot; </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">2 </span><span class="s1">); 
                    } 
                }); 
            } 
 
</span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
</span><span class="s0">// Use defaultValue in place of getAttribute(&quot;value&quot;)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !support.attributes || !assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                    el.innerHTML = </span><span class="s3">&quot;&lt;input/&gt;&quot;</span><span class="s1">; 
                    el.firstChild.setAttribute( </span><span class="s3">&quot;value&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
                    </span><span class="s2">return </span><span class="s1">el.firstChild.getAttribute( </span><span class="s3">&quot;value&quot; </span><span class="s1">) === </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                }) ) { 
                addHandle( </span><span class="s3">&quot;value&quot;</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( elem, name, isXML ) { 
                    </span><span class="s2">if </span><span class="s1">( !isXML &amp;&amp; elem.nodeName.toLowerCase() === </span><span class="s3">&quot;input&quot; </span><span class="s1">) { 
                        </span><span class="s2">return </span><span class="s1">elem.defaultValue; 
                    } 
                }); 
            } 
 
</span><span class="s0">// Support: IE&lt;9</span><span class="s1"> 
</span><span class="s0">// Use getAttributeNode to fetch booleans when getAttribute lies</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !assert(</span><span class="s2">function</span><span class="s1">( el ) { 
                    </span><span class="s2">return </span><span class="s1">el.getAttribute(</span><span class="s3">&quot;disabled&quot;</span><span class="s1">) == </span><span class="s2">null</span><span class="s1">; 
                }) ) { 
                addHandle( booleans, </span><span class="s2">function</span><span class="s1">( elem, name, isXML ) { 
                    </span><span class="s2">var </span><span class="s1">val; 
                    </span><span class="s2">if </span><span class="s1">( !isXML ) { 
                        </span><span class="s2">return </span><span class="s1">elem[ name ] === </span><span class="s2">true </span><span class="s1">? name.toLowerCase() : 
                            (val = elem.getAttributeNode( name )) &amp;&amp; val.specified ? 
                                val.value : 
                                </span><span class="s2">null</span><span class="s1">; 
                    } 
                }); 
            } 
 
            </span><span class="s2">return </span><span class="s1">Sizzle; 
 
        })( window ); 
 
 
 
    jQuery.find = Sizzle; 
    jQuery.expr = Sizzle.selectors; 
 
</span><span class="s0">// Deprecated</span><span class="s1"> 
    jQuery.expr[ </span><span class="s3">&quot;:&quot; </span><span class="s1">] = jQuery.expr.pseudos; 
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort; 
    jQuery.text = Sizzle.getText; 
    jQuery.isXMLDoc = Sizzle.isXML; 
    jQuery.contains = Sizzle.contains; 
    jQuery.escapeSelector = Sizzle.escape; 
 
 
 
 
    </span><span class="s2">var </span><span class="s1">dir = </span><span class="s2">function</span><span class="s1">( elem, dir, until ) { 
        </span><span class="s2">var </span><span class="s1">matched = [], 
            truncate = until !== undefined; 
 
        </span><span class="s2">while </span><span class="s1">( ( elem = elem[ dir ] ) &amp;&amp; elem.nodeType !== </span><span class="s4">9 </span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( truncate &amp;&amp; jQuery( elem ).is( until ) ) { 
                    </span><span class="s2">break</span><span class="s1">; 
                } 
                matched.push( elem ); 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">matched; 
    }; 
 
 
    </span><span class="s2">var </span><span class="s1">siblings = </span><span class="s2">function</span><span class="s1">( n, elem ) { 
        </span><span class="s2">var </span><span class="s1">matched = []; 
 
        </span><span class="s2">for </span><span class="s1">( ; n; n = n.nextSibling ) { 
            </span><span class="s2">if </span><span class="s1">( n.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; n !== elem ) { 
                matched.push( n ); 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">matched; 
    }; 
 
 
    </span><span class="s2">var </span><span class="s1">rneedsContext = jQuery.expr.match.needsContext; 
 
    </span><span class="s2">var </span><span class="s1">rsingleTag = ( </span><span class="s4">/^&lt;([a-z][^\/\0&gt;:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?&gt;(?:&lt;\/\1&gt;|)$/i </span><span class="s1">); 
 
 
 
    </span><span class="s2">var </span><span class="s1">risSimple = </span><span class="s4">/^.[^:#\[\.,]*$/</span><span class="s1">; 
 
</span><span class="s0">// Implement the identical functionality for filter and not</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">winnow( elements, qualifier, not ) { 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( qualifier ) ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.grep( elements, </span><span class="s2">function</span><span class="s1">( elem, i ) { 
                </span><span class="s2">return </span><span class="s1">!!qualifier.call( elem, i, elem ) !== not; 
            } ); 
        } 
 
        </span><span class="s0">// Single element</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( qualifier.nodeType ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.grep( elements, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">( elem === qualifier ) !== not; 
            } ); 
        } 
 
        </span><span class="s0">// Arraylike of elements (jQuery, arguments, Array)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">qualifier !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">jQuery.grep( elements, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">( indexOf.call( qualifier, elem ) &gt; -</span><span class="s4">1 </span><span class="s1">) !== not; 
            } ); 
        } 
 
        </span><span class="s0">// Simple selector that can be filtered directly, removing non-Elements</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( risSimple.test( qualifier ) ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.filter( qualifier, elements, not ); 
        } 
 
        </span><span class="s0">// Complex selector, compare the two sets, removing non-Elements</span><span class="s1"> 
        qualifier = jQuery.filter( qualifier, elements ); 
        </span><span class="s2">return </span><span class="s1">jQuery.grep( elements, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">( indexOf.call( qualifier, elem ) &gt; -</span><span class="s4">1 </span><span class="s1">) !== not &amp;&amp; elem.nodeType === </span><span class="s4">1</span><span class="s1">; 
        } ); 
    } 
 
    jQuery.filter = </span><span class="s2">function</span><span class="s1">( expr, elems, not ) { 
        </span><span class="s2">var </span><span class="s1">elem = elems[ </span><span class="s4">0 </span><span class="s1">]; 
 
        </span><span class="s2">if </span><span class="s1">( not ) { 
            expr = </span><span class="s3">&quot;:not(&quot; </span><span class="s1">+ expr + </span><span class="s3">&quot;)&quot;</span><span class="s1">; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( elems.length === </span><span class="s4">1 </span><span class="s1">&amp;&amp; elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : []; 
        } 
 
        </span><span class="s2">return </span><span class="s1">jQuery.find.matches( expr, jQuery.grep( elems, </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem.nodeType === </span><span class="s4">1</span><span class="s1">; 
        } ) ); 
    }; 
 
    jQuery.fn.extend( { 
        find: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">var </span><span class="s1">i, ret, 
                len = </span><span class="s2">this</span><span class="s1">.length, 
                self = </span><span class="s2">this</span><span class="s1">; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s2">return this</span><span class="s1">.pushStack( jQuery( selector ).filter( </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++ ) { 
                        </span><span class="s2">if </span><span class="s1">( jQuery.contains( self[ i ], </span><span class="s2">this </span><span class="s1">) ) { 
                            </span><span class="s2">return true</span><span class="s1">; 
                        } 
                    } 
                } ) ); 
            } 
 
            ret = </span><span class="s2">this</span><span class="s1">.pushStack( [] ); 
 
            </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">; i &lt; len; i++ ) { 
                jQuery.find( selector, self[ i ], ret ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">len &gt; </span><span class="s4">1 </span><span class="s1">? jQuery.uniqueSort( ret ) : ret; 
        }, 
        filter: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return this</span><span class="s1">.pushStack( winnow( </span><span class="s2">this</span><span class="s1">, selector || [], </span><span class="s2">false </span><span class="s1">) ); 
        }, 
        not: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return this</span><span class="s1">.pushStack( winnow( </span><span class="s2">this</span><span class="s1">, selector || [], </span><span class="s2">true </span><span class="s1">) ); 
        }, 
        is: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return </span><span class="s1">!!winnow( 
                </span><span class="s2">this</span><span class="s1">, 
 
                </span><span class="s0">// If this is a positional/relative selector, check membership in the returned set</span><span class="s1"> 
                </span><span class="s0">// so $(&quot;p:first&quot;).is(&quot;p:last&quot;) won't return true for a doc with two &quot;p&quot;.</span><span class="s1"> 
                </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; rneedsContext.test( selector ) ? 
                    jQuery( selector ) : 
                selector || [], 
                </span><span class="s2">false</span><span class="s1"> 
            ).length; 
        } 
    } ); 
 
 
</span><span class="s0">// Initialize a jQuery object</span><span class="s1"> 
 
 
</span><span class="s0">// A central reference to the root jQuery(document)</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">rootjQuery, 
 
    </span><span class="s0">// A simple way to check for HTML strings</span><span class="s1"> 
    </span><span class="s0">// Prioritize #id over &lt;tag&gt; to avoid XSS via location.hash (#9521)</span><span class="s1"> 
    </span><span class="s0">// Strict HTML recognition (#11290: must start with &lt;)</span><span class="s1"> 
    </span><span class="s0">// Shortcut simple #id case for speed</span><span class="s1"> 
        rquickExpr = </span><span class="s4">/^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]+))$/</span><span class="s1">, 
 
        init = jQuery.fn.init = </span><span class="s2">function</span><span class="s1">( selector, context, root ) { 
            </span><span class="s2">var </span><span class="s1">match, elem; 
 
            </span><span class="s0">// HANDLE: $(&quot;&quot;), $(null), $(undefined), $(false)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !selector ) { 
                </span><span class="s2">return this</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Method init() accepts an alternate rootjQuery</span><span class="s1"> 
            </span><span class="s0">// so migrate can support jQuery.sub (gh-2101)</span><span class="s1"> 
            root = root || rootjQuery; 
 
            </span><span class="s0">// Handle HTML strings</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( selector[ </span><span class="s4">0 </span><span class="s1">] === </span><span class="s3">&quot;&lt;&quot; </span><span class="s1">&amp;&amp; 
                    selector[ selector.length - </span><span class="s4">1 </span><span class="s1">] === </span><span class="s3">&quot;&gt;&quot; </span><span class="s1">&amp;&amp; 
                    selector.length &gt;= </span><span class="s4">3 </span><span class="s1">) { 
 
                    </span><span class="s0">// Assume that strings that start and end with &lt;&gt; are HTML and skip the regex check</span><span class="s1"> 
                    match = [ </span><span class="s2">null</span><span class="s1">, selector, </span><span class="s2">null </span><span class="s1">]; 
 
                } </span><span class="s2">else </span><span class="s1">{ 
                    match = rquickExpr.exec( selector ); 
                } 
 
                </span><span class="s0">// Match html or make sure no context is specified for #id</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( match &amp;&amp; ( match[ </span><span class="s4">1 </span><span class="s1">] || !context ) ) { 
 
                    </span><span class="s0">// HANDLE: $(html) -&gt; $(array)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( match[ </span><span class="s4">1 </span><span class="s1">] ) { 
                        context = context </span><span class="s2">instanceof </span><span class="s1">jQuery ? context[ </span><span class="s4">0 </span><span class="s1">] : context; 
 
                        </span><span class="s0">// Option to run scripts is true for back-compat</span><span class="s1"> 
                        </span><span class="s0">// Intentionally let the error be thrown if parseHTML is not present</span><span class="s1"> 
                        jQuery.merge( </span><span class="s2">this</span><span class="s1">, jQuery.parseHTML( 
                            match[ </span><span class="s4">1 </span><span class="s1">], 
                            context &amp;&amp; context.nodeType ? context.ownerDocument || context : document, 
                            </span><span class="s2">true</span><span class="s1"> 
                        ) ); 
 
                        </span><span class="s0">// HANDLE: $(html, props)</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( rsingleTag.test( match[ </span><span class="s4">1 </span><span class="s1">] ) &amp;&amp; jQuery.isPlainObject( context ) ) { 
                            </span><span class="s2">for </span><span class="s1">( match </span><span class="s2">in </span><span class="s1">context ) { 
 
                                </span><span class="s0">// Properties of context are called as methods if possible</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( </span><span class="s2">this</span><span class="s1">[ match ] ) ) { 
                                    </span><span class="s2">this</span><span class="s1">[ match ]( context[ match ] ); 
 
                                    </span><span class="s0">// ...and otherwise set as attributes</span><span class="s1"> 
                                } </span><span class="s2">else </span><span class="s1">{ 
                                    </span><span class="s2">this</span><span class="s1">.attr( match, context[ match ] ); 
                                } 
                            } 
                        } 
 
                        </span><span class="s2">return this</span><span class="s1">; 
 
                        </span><span class="s0">// HANDLE: $(#id)</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        elem = document.getElementById( match[ </span><span class="s4">2 </span><span class="s1">] ); 
 
                        </span><span class="s2">if </span><span class="s1">( elem ) { 
 
                            </span><span class="s0">// Inject the element directly into the jQuery object</span><span class="s1"> 
                            </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] = elem; 
                            </span><span class="s2">this</span><span class="s1">.length = </span><span class="s4">1</span><span class="s1">; 
                        } 
                        </span><span class="s2">return this</span><span class="s1">; 
                    } 
 
                    </span><span class="s0">// HANDLE: $(expr, $(...))</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( !context || context.jquery ) { 
                    </span><span class="s2">return </span><span class="s1">( context || root ).find( selector ); 
 
                    </span><span class="s0">// HANDLE: $(expr, context)</span><span class="s1"> 
                    </span><span class="s0">// (which is just equivalent to: $(context).find(expr)</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    </span><span class="s2">return this</span><span class="s1">.constructor( context ).find( selector ); 
                } 
 
                </span><span class="s0">// HANDLE: $(DOMElement)</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( selector.nodeType ) { 
                </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] = selector; 
                </span><span class="s2">this</span><span class="s1">.length = </span><span class="s4">1</span><span class="s1">; 
                </span><span class="s2">return this</span><span class="s1">; 
 
                </span><span class="s0">// HANDLE: $(function)</span><span class="s1"> 
                </span><span class="s0">// Shortcut for document ready</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( jQuery.isFunction( selector ) ) { 
                </span><span class="s2">return </span><span class="s1">root.ready !== undefined ? 
                    root.ready( selector ) : 
 
                    </span><span class="s0">// Execute immediately if ready is not present</span><span class="s1"> 
                    selector( jQuery ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">jQuery.makeArray( selector, </span><span class="s2">this </span><span class="s1">); 
        }; 
 
</span><span class="s0">// Give the init function the jQuery prototype for later instantiation</span><span class="s1"> 
    init.prototype = jQuery.fn; 
 
</span><span class="s0">// Initialize central reference</span><span class="s1"> 
    rootjQuery = jQuery( document ); 
 
 
    </span><span class="s2">var </span><span class="s1">rparentsprev = </span><span class="s4">/^(?:parents|prev(?:Until|All))/</span><span class="s1">, 
 
    </span><span class="s0">// Methods guaranteed to produce a unique set when starting from a unique set</span><span class="s1"> 
        guaranteedUnique = { 
            children: </span><span class="s2">true</span><span class="s1">, 
            contents: </span><span class="s2">true</span><span class="s1">, 
            next: </span><span class="s2">true</span><span class="s1">, 
            prev: </span><span class="s2">true</span><span class="s1"> 
        }; 
 
    jQuery.fn.extend( { 
        has: </span><span class="s2">function</span><span class="s1">( target ) { 
            </span><span class="s2">var </span><span class="s1">targets = jQuery( target, </span><span class="s2">this </span><span class="s1">), 
                l = targets.length; 
 
            </span><span class="s2">return this</span><span class="s1">.filter( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">; 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; l; i++ ) { 
                    </span><span class="s2">if </span><span class="s1">( jQuery.contains( </span><span class="s2">this</span><span class="s1">, targets[ i ] ) ) { 
                        </span><span class="s2">return true</span><span class="s1">; 
                    } 
                } 
            } ); 
        }, 
 
        closest: </span><span class="s2">function</span><span class="s1">( selectors, context ) { 
            </span><span class="s2">var </span><span class="s1">cur, 
                i = </span><span class="s4">0</span><span class="s1">, 
                l = </span><span class="s2">this</span><span class="s1">.length, 
                matched = [], 
                targets = </span><span class="s2">typeof </span><span class="s1">selectors !== </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; jQuery( selectors ); 
 
            </span><span class="s0">// Positional selectors never match, since there's no _selection_ context</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !rneedsContext.test( selectors ) ) { 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; l; i++ ) { 
                    </span><span class="s2">for </span><span class="s1">( cur = </span><span class="s2">this</span><span class="s1">[ i ]; cur &amp;&amp; cur !== context; cur = cur.parentNode ) { 
 
                        </span><span class="s0">// Always skip document fragments</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( cur.nodeType &lt; </span><span class="s4">11 </span><span class="s1">&amp;&amp; ( targets ? 
                            targets.index( cur ) &gt; -</span><span class="s4">1 </span><span class="s1">: 
 
                                </span><span class="s0">// Don't pass non-elements to Sizzle</span><span class="s1"> 
                            cur.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; 
                            jQuery.find.matchesSelector( cur, selectors ) ) ) { 
 
                            matched.push( cur ); 
                            </span><span class="s2">break</span><span class="s1">; 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.pushStack( matched.length &gt; </span><span class="s4">1 </span><span class="s1">? jQuery.uniqueSort( matched ) : matched ); 
        }, 
 
        </span><span class="s0">// Determine the position of an element within the set</span><span class="s1"> 
        index: </span><span class="s2">function</span><span class="s1">( elem ) { 
 
            </span><span class="s0">// No argument, return index in parent</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !elem ) { 
                </span><span class="s2">return </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] &amp;&amp; </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">].parentNode ) ? </span><span class="s2">this</span><span class="s1">.first().prevAll().length : -</span><span class="s4">1</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Index in selector</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">indexOf.call( jQuery( elem ), </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] ); 
            } 
 
            </span><span class="s0">// Locate the position of the desired element</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">indexOf.call( </span><span class="s2">this</span><span class="s1">, 
 
                </span><span class="s0">// If it receives a jQuery object, the first element is used</span><span class="s1"> 
                elem.jquery ? elem[ </span><span class="s4">0 </span><span class="s1">] : elem 
            ); 
        }, 
 
        add: </span><span class="s2">function</span><span class="s1">( selector, context ) { 
            </span><span class="s2">return this</span><span class="s1">.pushStack( 
                jQuery.uniqueSort( 
                    jQuery.merge( </span><span class="s2">this</span><span class="s1">.get(), jQuery( selector, context ) ) 
                ) 
            ); 
        }, 
 
        addBack: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return this</span><span class="s1">.add( selector == </span><span class="s2">null </span><span class="s1">? 
                </span><span class="s2">this</span><span class="s1">.prevObject : </span><span class="s2">this</span><span class="s1">.prevObject.filter( selector ) 
            ); 
        } 
    } ); 
 
    </span><span class="s2">function </span><span class="s1">sibling( cur, dir ) { 
        </span><span class="s2">while </span><span class="s1">( ( cur = cur[ dir ] ) &amp;&amp; cur.nodeType !== </span><span class="s4">1 </span><span class="s1">) {} 
        </span><span class="s2">return </span><span class="s1">cur; 
    } 
 
    jQuery.each( { 
        parent: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">var </span><span class="s1">parent = elem.parentNode; 
            </span><span class="s2">return </span><span class="s1">parent &amp;&amp; parent.nodeType !== </span><span class="s4">11 </span><span class="s1">? parent : </span><span class="s2">null</span><span class="s1">; 
        }, 
        parents: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">dir( elem, </span><span class="s3">&quot;parentNode&quot; </span><span class="s1">); 
        }, 
        parentsUntil: </span><span class="s2">function</span><span class="s1">( elem, i, until ) { 
            </span><span class="s2">return </span><span class="s1">dir( elem, </span><span class="s3">&quot;parentNode&quot;</span><span class="s1">, until ); 
        }, 
        next: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">sibling( elem, </span><span class="s3">&quot;nextSibling&quot; </span><span class="s1">); 
        }, 
        prev: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">sibling( elem, </span><span class="s3">&quot;previousSibling&quot; </span><span class="s1">); 
        }, 
        nextAll: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">dir( elem, </span><span class="s3">&quot;nextSibling&quot; </span><span class="s1">); 
        }, 
        prevAll: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">dir( elem, </span><span class="s3">&quot;previousSibling&quot; </span><span class="s1">); 
        }, 
        nextUntil: </span><span class="s2">function</span><span class="s1">( elem, i, until ) { 
            </span><span class="s2">return </span><span class="s1">dir( elem, </span><span class="s3">&quot;nextSibling&quot;</span><span class="s1">, until ); 
        }, 
        prevUntil: </span><span class="s2">function</span><span class="s1">( elem, i, until ) { 
            </span><span class="s2">return </span><span class="s1">dir( elem, </span><span class="s3">&quot;previousSibling&quot;</span><span class="s1">, until ); 
        }, 
        siblings: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">siblings( ( elem.parentNode || {} ).firstChild, elem ); 
        }, 
        children: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">siblings( elem.firstChild ); 
        }, 
        contents: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">elem.contentDocument || jQuery.merge( [], elem.childNodes ); 
        } 
    }, </span><span class="s2">function</span><span class="s1">( name, fn ) { 
        jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( until, selector ) { 
            </span><span class="s2">var </span><span class="s1">matched = jQuery.map( </span><span class="s2">this</span><span class="s1">, fn, until ); 
 
            </span><span class="s2">if </span><span class="s1">( name.slice( -</span><span class="s4">5 </span><span class="s1">) !== </span><span class="s3">&quot;Until&quot; </span><span class="s1">) { 
                selector = until; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( selector &amp;&amp; </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                matched = jQuery.filter( selector, matched ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.length &gt; </span><span class="s4">1 </span><span class="s1">) { 
 
                </span><span class="s0">// Remove duplicates</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !guaranteedUnique[ name ] ) { 
                    jQuery.uniqueSort( matched ); 
                } 
 
                </span><span class="s0">// Reverse order for parents* and prev-derivatives</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( rparentsprev.test( name ) ) { 
                    matched.reverse(); 
                } 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.pushStack( matched ); 
        }; 
    } ); 
    </span><span class="s2">var </span><span class="s1">rnothtmlwhite = ( </span><span class="s4">/[^\x20\t\r\n\f]+/g </span><span class="s1">); 
 
 
 
</span><span class="s0">// Convert String-formatted options into Object-formatted ones</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">createOptions( options ) { 
        </span><span class="s2">var </span><span class="s1">object = {}; 
        jQuery.each( options.match( rnothtmlwhite ) || [], </span><span class="s2">function</span><span class="s1">( _, flag ) { 
            object[ flag ] = </span><span class="s2">true</span><span class="s1">; 
        } ); 
        </span><span class="s2">return </span><span class="s1">object; 
    } 
 
    </span><span class="s0">/* 
     * Create a callback list using the following parameters: 
     * 
     *  options: an optional list of space-separated options that will change how 
     *          the callback list behaves or a more traditional option object 
     * 
     * By default a callback list will act like an event callback list and can be 
     * &quot;fired&quot; multiple times. 
     * 
     * Possible options: 
     * 
     *  once:           will ensure the callback list can only be fired once (like a Deferred) 
     * 
     *  memory:         will keep track of previous values and will call any callback added 
     *                  after the list has been fired right away with the latest &quot;memorized&quot; 
     *                  values (like a Deferred) 
     * 
     *  unique:         will ensure a callback can only be added once (no duplicate in the list) 
     * 
     *  stopOnFalse:    interrupt callings when a callback returns false 
     * 
     */</span><span class="s1"> 
    jQuery.Callbacks = </span><span class="s2">function</span><span class="s1">( options ) { 
 
        </span><span class="s0">// Convert options from String-formatted to Object-formatted if needed</span><span class="s1"> 
        </span><span class="s0">// (we check in cache first)</span><span class="s1"> 
        options = </span><span class="s2">typeof </span><span class="s1">options === </span><span class="s3">&quot;string&quot; </span><span class="s1">? 
            createOptions( options ) : 
            jQuery.extend( {}, options ); 
 
        </span><span class="s2">var </span><span class="s0">// Flag to know if list is currently firing</span><span class="s1"> 
            firing, 
 
        </span><span class="s0">// Last fire value for non-forgettable lists</span><span class="s1"> 
            memory, 
 
        </span><span class="s0">// Flag to know if list was already fired</span><span class="s1"> 
            fired, 
 
        </span><span class="s0">// Flag to prevent firing</span><span class="s1"> 
            locked, 
 
        </span><span class="s0">// Actual callback list</span><span class="s1"> 
            list = [], 
 
        </span><span class="s0">// Queue of execution data for repeatable lists</span><span class="s1"> 
            queue = [], 
 
        </span><span class="s0">// Index of currently firing callback (modified by add/remove as needed)</span><span class="s1"> 
            firingIndex = -</span><span class="s4">1</span><span class="s1">, 
 
        </span><span class="s0">// Fire callbacks</span><span class="s1"> 
            fire = </span><span class="s2">function</span><span class="s1">() { 
 
                </span><span class="s0">// Enforce single-firing</span><span class="s1"> 
                locked = options.once; 
 
                </span><span class="s0">// Execute callbacks for all pending executions,</span><span class="s1"> 
                </span><span class="s0">// respecting firingIndex overrides and runtime changes</span><span class="s1"> 
                fired = firing = </span><span class="s2">true</span><span class="s1">; 
                </span><span class="s2">for </span><span class="s1">( ; queue.length; firingIndex = -</span><span class="s4">1 </span><span class="s1">) { 
                    memory = queue.shift(); 
                    </span><span class="s2">while </span><span class="s1">( ++firingIndex &lt; list.length ) { 
 
                        </span><span class="s0">// Run callback and check for early termination</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( list[ firingIndex ].apply( memory[ </span><span class="s4">0 </span><span class="s1">], memory[ </span><span class="s4">1 </span><span class="s1">] ) === </span><span class="s2">false </span><span class="s1">&amp;&amp; 
                            options.stopOnFalse ) { 
 
                            </span><span class="s0">// Jump to end and forget the data so .add doesn't re-fire</span><span class="s1"> 
                            firingIndex = list.length; 
                            memory = </span><span class="s2">false</span><span class="s1">; 
                        } 
                    } 
                } 
 
                </span><span class="s0">// Forget the data if we're done with it</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !options.memory ) { 
                    memory = </span><span class="s2">false</span><span class="s1">; 
                } 
 
                firing = </span><span class="s2">false</span><span class="s1">; 
 
                </span><span class="s0">// Clean up if we're done firing for good</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( locked ) { 
 
                    </span><span class="s0">// Keep an empty list if we have data for future add calls</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( memory ) { 
                        list = []; 
 
                        </span><span class="s0">// Otherwise, this object is spent</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        list = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                    } 
                } 
            }, 
 
        </span><span class="s0">// Actual Callbacks object</span><span class="s1"> 
            self = { 
 
                </span><span class="s0">// Add a callback or a collection of callbacks to the list</span><span class="s1"> 
                add: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( list ) { 
 
                        </span><span class="s0">// If we have memory from a past run, we should fire after adding</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( memory &amp;&amp; !firing ) { 
                            firingIndex = list.length - </span><span class="s4">1</span><span class="s1">; 
                            queue.push( memory ); 
                        } 
 
                        ( </span><span class="s2">function </span><span class="s1">add( args ) { 
                            jQuery.each( args, </span><span class="s2">function</span><span class="s1">( _, arg ) { 
                                </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( arg ) ) { 
                                    </span><span class="s2">if </span><span class="s1">( !options.unique || !self.has( arg ) ) { 
                                        list.push( arg ); 
                                    } 
                                } </span><span class="s2">else if </span><span class="s1">( arg &amp;&amp; arg.length &amp;&amp; jQuery.type( arg ) !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
 
                                    </span><span class="s0">// Inspect recursively</span><span class="s1"> 
                                    add( arg ); 
                                } 
                            } ); 
                        } )( arguments ); 
 
                        </span><span class="s2">if </span><span class="s1">( memory &amp;&amp; !firing ) { 
                            fire(); 
                        } 
                    } 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
 
                </span><span class="s0">// Remove a callback from the list</span><span class="s1"> 
                remove: </span><span class="s2">function</span><span class="s1">() { 
                    jQuery.each( arguments, </span><span class="s2">function</span><span class="s1">( _, arg ) { 
                        </span><span class="s2">var </span><span class="s1">index; 
                        </span><span class="s2">while </span><span class="s1">( ( index = jQuery.inArray( arg, list, index ) ) &gt; -</span><span class="s4">1 </span><span class="s1">) { 
                            list.splice( index, </span><span class="s4">1 </span><span class="s1">); 
 
                            </span><span class="s0">// Handle firing indexes</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( index &lt;= firingIndex ) { 
                                firingIndex--; 
                            } 
                        } 
                    } ); 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
 
                </span><span class="s0">// Check if a given callback is in the list.</span><span class="s1"> 
                </span><span class="s0">// If no argument is given, return whether or not list has callbacks attached.</span><span class="s1"> 
                has: </span><span class="s2">function</span><span class="s1">( fn ) { 
                    </span><span class="s2">return </span><span class="s1">fn ? 
                    jQuery.inArray( fn, list ) &gt; -</span><span class="s4">1 </span><span class="s1">: 
                    list.length &gt; </span><span class="s4">0</span><span class="s1">; 
                }, 
 
                </span><span class="s0">// Remove all callbacks from the list</span><span class="s1"> 
                empty: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( list ) { 
                        list = []; 
                    } 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
 
                </span><span class="s0">// Disable .fire and .add</span><span class="s1"> 
                </span><span class="s0">// Abort any current/pending executions</span><span class="s1"> 
                </span><span class="s0">// Clear all callbacks and values</span><span class="s1"> 
                disable: </span><span class="s2">function</span><span class="s1">() { 
                    locked = queue = []; 
                    list = memory = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
                disabled: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">!list; 
                }, 
 
                </span><span class="s0">// Disable .fire</span><span class="s1"> 
                </span><span class="s0">// Also disable .add unless we have memory (since it would have no effect)</span><span class="s1"> 
                </span><span class="s0">// Abort any pending executions</span><span class="s1"> 
                lock: </span><span class="s2">function</span><span class="s1">() { 
                    locked = queue = []; 
                    </span><span class="s2">if </span><span class="s1">( !memory &amp;&amp; !firing ) { 
                        list = memory = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                    } 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
                locked: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">!!locked; 
                }, 
 
                </span><span class="s0">// Call all callbacks with the given context and arguments</span><span class="s1"> 
                fireWith: </span><span class="s2">function</span><span class="s1">( context, args ) { 
                    </span><span class="s2">if </span><span class="s1">( !locked ) { 
                        args = args || []; 
                        args = [ context, args.slice ? args.slice() : args ]; 
                        queue.push( args ); 
                        </span><span class="s2">if </span><span class="s1">( !firing ) { 
                            fire(); 
                        } 
                    } 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
 
                </span><span class="s0">// Call all the callbacks with the given arguments</span><span class="s1"> 
                fire: </span><span class="s2">function</span><span class="s1">() { 
                    self.fireWith( </span><span class="s2">this</span><span class="s1">, arguments ); 
                    </span><span class="s2">return this</span><span class="s1">; 
                }, 
 
                </span><span class="s0">// To know if the callbacks have already been called at least once</span><span class="s1"> 
                fired: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">!!fired; 
                } 
            }; 
 
        </span><span class="s2">return </span><span class="s1">self; 
    }; 
 
 
    </span><span class="s2">function </span><span class="s1">Identity( v ) { 
        </span><span class="s2">return </span><span class="s1">v; 
    } 
    </span><span class="s2">function </span><span class="s1">Thrower( ex ) { 
        </span><span class="s2">throw </span><span class="s1">ex; 
    } 
 
    </span><span class="s2">function </span><span class="s1">adoptValue( value, resolve, reject ) { 
        </span><span class="s2">var </span><span class="s1">method; 
 
        </span><span class="s2">try </span><span class="s1">{ 
 
            </span><span class="s0">// Check for promise aspect first to privilege synchronous behavior</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( value &amp;&amp; jQuery.isFunction( ( method = value.promise ) ) ) { 
                method.call( value ).done( resolve ).fail( reject ); 
 
                </span><span class="s0">// Other thenables</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( value &amp;&amp; jQuery.isFunction( ( method = value.then ) ) ) { 
                method.call( value, resolve, reject ); 
 
                </span><span class="s0">// Other non-thenables</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
 
                </span><span class="s0">// Support: Android 4.0 only</span><span class="s1"> 
                </span><span class="s0">// Strict mode functions invoked without .call/.apply get global-object context</span><span class="s1"> 
                resolve.call( undefined, value ); 
            } 
 
            </span><span class="s0">// For Promises/A+, convert exceptions into rejections</span><span class="s1"> 
            </span><span class="s0">// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in</span><span class="s1"> 
            </span><span class="s0">// Deferred#then to conditionally suppress rejection.</span><span class="s1"> 
        } </span><span class="s2">catch </span><span class="s1">( value ) { 
 
            </span><span class="s0">// Support: Android 4.0 only</span><span class="s1"> 
            </span><span class="s0">// Strict mode functions invoked without .call/.apply get global-object context</span><span class="s1"> 
            reject.call( undefined, value ); 
        } 
    } 
 
    jQuery.extend( { 
 
        Deferred: </span><span class="s2">function</span><span class="s1">( func ) { 
            </span><span class="s2">var </span><span class="s1">tuples = [ 
 
                    </span><span class="s0">// action, add listener, callbacks,</span><span class="s1"> 
                    </span><span class="s0">// ... .then handlers, argument index, [final state]</span><span class="s1"> 
                    [ </span><span class="s3">&quot;notify&quot;</span><span class="s1">, </span><span class="s3">&quot;progress&quot;</span><span class="s1">, jQuery.Callbacks( </span><span class="s3">&quot;memory&quot; </span><span class="s1">), 
                        jQuery.Callbacks( </span><span class="s3">&quot;memory&quot; </span><span class="s1">), </span><span class="s4">2 </span><span class="s1">], 
                    [ </span><span class="s3">&quot;resolve&quot;</span><span class="s1">, </span><span class="s3">&quot;done&quot;</span><span class="s1">, jQuery.Callbacks( </span><span class="s3">&quot;once memory&quot; </span><span class="s1">), 
                        jQuery.Callbacks( </span><span class="s3">&quot;once memory&quot; </span><span class="s1">), </span><span class="s4">0</span><span class="s1">, </span><span class="s3">&quot;resolved&quot; </span><span class="s1">], 
                    [ </span><span class="s3">&quot;reject&quot;</span><span class="s1">, </span><span class="s3">&quot;fail&quot;</span><span class="s1">, jQuery.Callbacks( </span><span class="s3">&quot;once memory&quot; </span><span class="s1">), 
                        jQuery.Callbacks( </span><span class="s3">&quot;once memory&quot; </span><span class="s1">), </span><span class="s4">1</span><span class="s1">, </span><span class="s3">&quot;rejected&quot; </span><span class="s1">] 
                ], 
                state = </span><span class="s3">&quot;pending&quot;</span><span class="s1">, 
                promise = { 
                    state: </span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">return </span><span class="s1">state; 
                    }, 
                    always: </span><span class="s2">function</span><span class="s1">() { 
                        deferred.done( arguments ).fail( arguments ); 
                        </span><span class="s2">return this</span><span class="s1">; 
                    }, 
                    </span><span class="s3">&quot;catch&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( fn ) { 
                        </span><span class="s2">return </span><span class="s1">promise.then( </span><span class="s2">null</span><span class="s1">, fn ); 
                    }, 
 
                    </span><span class="s0">// Keep pipe for back-compat</span><span class="s1"> 
                    pipe: </span><span class="s2">function</span><span class="s1">( </span><span class="s0">/* fnDone, fnFail, fnProgress */ </span><span class="s1">) { 
                        </span><span class="s2">var </span><span class="s1">fns = arguments; 
 
                        </span><span class="s2">return </span><span class="s1">jQuery.Deferred( </span><span class="s2">function</span><span class="s1">( newDefer ) { 
                            jQuery.each( tuples, </span><span class="s2">function</span><span class="s1">( i, tuple ) { 
 
                                </span><span class="s0">// Map tuples (progress, done, fail) to arguments (done, fail, progress)</span><span class="s1"> 
                                </span><span class="s2">var </span><span class="s1">fn = jQuery.isFunction( fns[ tuple[ </span><span class="s4">4 </span><span class="s1">] ] ) &amp;&amp; fns[ tuple[ </span><span class="s4">4 </span><span class="s1">] ]; 
 
                                </span><span class="s0">// deferred.progress(function() { bind to newDefer or newDefer.notify })</span><span class="s1"> 
                                </span><span class="s0">// deferred.done(function() { bind to newDefer or newDefer.resolve })</span><span class="s1"> 
                                </span><span class="s0">// deferred.fail(function() { bind to newDefer or newDefer.reject })</span><span class="s1"> 
                                deferred[ tuple[ </span><span class="s4">1 </span><span class="s1">] ]( </span><span class="s2">function</span><span class="s1">() { 
                                    </span><span class="s2">var </span><span class="s1">returned = fn &amp;&amp; fn.apply( </span><span class="s2">this</span><span class="s1">, arguments ); 
                                    </span><span class="s2">if </span><span class="s1">( returned &amp;&amp; jQuery.isFunction( returned.promise ) ) { 
                                        returned.promise() 
                                            .progress( newDefer.notify ) 
                                            .done( newDefer.resolve ) 
                                            .fail( newDefer.reject ); 
                                    } </span><span class="s2">else </span><span class="s1">{ 
                                        newDefer[ tuple[ </span><span class="s4">0 </span><span class="s1">] + </span><span class="s3">&quot;With&quot; </span><span class="s1">]( 
                                            </span><span class="s2">this</span><span class="s1">, 
                                            fn ? [ returned ] : arguments 
                                        ); 
                                    } 
                                } ); 
                            } ); 
                            fns = </span><span class="s2">null</span><span class="s1">; 
                        } ).promise(); 
                    }, 
                    then: </span><span class="s2">function</span><span class="s1">( onFulfilled, onRejected, onProgress ) { 
                        </span><span class="s2">var </span><span class="s1">maxDepth = </span><span class="s4">0</span><span class="s1">; 
                        </span><span class="s2">function </span><span class="s1">resolve( depth, deferred, handler, special ) { 
                            </span><span class="s2">return function</span><span class="s1">() { 
                                </span><span class="s2">var </span><span class="s1">that = </span><span class="s2">this</span><span class="s1">, 
                                    args = arguments, 
                                    mightThrow = </span><span class="s2">function</span><span class="s1">() { 
                                        </span><span class="s2">var </span><span class="s1">returned, then; 
 
                                        </span><span class="s0">// Support: Promises/A+ section 2.3.3.3.3</span><span class="s1"> 
                                        </span><span class="s0">// https://promisesaplus.com/#point-59</span><span class="s1"> 
                                        </span><span class="s0">// Ignore double-resolution attempts</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( depth &lt; maxDepth ) { 
                                            </span><span class="s2">return</span><span class="s1">; 
                                        } 
 
                                        returned = handler.apply( that, args ); 
 
                                        </span><span class="s0">// Support: Promises/A+ section 2.3.1</span><span class="s1"> 
                                        </span><span class="s0">// https://promisesaplus.com/#point-48</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( returned === deferred.promise() ) { 
                                            </span><span class="s2">throw new </span><span class="s1">TypeError( </span><span class="s3">&quot;Thenable self-resolution&quot; </span><span class="s1">); 
                                        } 
 
                                        </span><span class="s0">// Support: Promises/A+ sections 2.3.3.1, 3.5</span><span class="s1"> 
                                        </span><span class="s0">// https://promisesaplus.com/#point-54</span><span class="s1"> 
                                        </span><span class="s0">// https://promisesaplus.com/#point-75</span><span class="s1"> 
                                        </span><span class="s0">// Retrieve `then` only once</span><span class="s1"> 
                                        then = returned &amp;&amp; 
 
                                                </span><span class="s0">// Support: Promises/A+ section 2.3.4</span><span class="s1"> 
                                                </span><span class="s0">// https://promisesaplus.com/#point-64</span><span class="s1"> 
                                                </span><span class="s0">// Only check objects and functions for thenability</span><span class="s1"> 
                                            ( </span><span class="s2">typeof </span><span class="s1">returned === </span><span class="s3">&quot;object&quot; </span><span class="s1">|| 
                                            </span><span class="s2">typeof </span><span class="s1">returned === </span><span class="s3">&quot;function&quot; </span><span class="s1">) &amp;&amp; 
                                            returned.then; 
 
                                        </span><span class="s0">// Handle a returned thenable</span><span class="s1"> 
                                        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( then ) ) { 
 
                                            </span><span class="s0">// Special processors (notify) just wait for resolution</span><span class="s1"> 
                                            </span><span class="s2">if </span><span class="s1">( special ) { 
                                                then.call( 
                                                    returned, 
                                                    resolve( maxDepth, deferred, Identity, special ), 
                                                    resolve( maxDepth, deferred, Thrower, special ) 
                                                ); 
 
                                                </span><span class="s0">// Normal processors (resolve) also hook into progress</span><span class="s1"> 
                                            } </span><span class="s2">else </span><span class="s1">{ 
 
                                                </span><span class="s0">// ...and disregard older resolution values</span><span class="s1"> 
                                                maxDepth++; 
 
                                                then.call( 
                                                    returned, 
                                                    resolve( maxDepth, deferred, Identity, special ), 
                                                    resolve( maxDepth, deferred, Thrower, special ), 
                                                    resolve( maxDepth, deferred, Identity, 
                                                        deferred.notifyWith ) 
                                                ); 
                                            } 
 
                                            </span><span class="s0">// Handle all other returned values</span><span class="s1"> 
                                        } </span><span class="s2">else </span><span class="s1">{ 
 
                                            </span><span class="s0">// Only substitute handlers pass on context</span><span class="s1"> 
                                            </span><span class="s0">// and multiple values (non-spec behavior)</span><span class="s1"> 
                                            </span><span class="s2">if </span><span class="s1">( handler !== Identity ) { 
                                                that = undefined; 
                                                args = [ returned ]; 
                                            } 
 
                                            </span><span class="s0">// Process the value(s)</span><span class="s1"> 
                                            </span><span class="s0">// Default process is resolve</span><span class="s1"> 
                                            ( special || deferred.resolveWith )( that, args ); 
                                        } 
                                    }, 
 
                                </span><span class="s0">// Only normal processors (resolve) catch and reject exceptions</span><span class="s1"> 
                                    process = special ? 
                                        mightThrow : 
                                        </span><span class="s2">function</span><span class="s1">() { 
                                            </span><span class="s2">try </span><span class="s1">{ 
                                                mightThrow(); 
                                            } </span><span class="s2">catch </span><span class="s1">( e ) { 
 
                                                </span><span class="s2">if </span><span class="s1">( jQuery.Deferred.exceptionHook ) { 
                                                    jQuery.Deferred.exceptionHook( e, 
                                                        process.stackTrace ); 
                                                } 
 
                                                </span><span class="s0">// Support: Promises/A+ section 2.3.3.3.4.1</span><span class="s1"> 
                                                </span><span class="s0">// https://promisesaplus.com/#point-61</span><span class="s1"> 
                                                </span><span class="s0">// Ignore post-resolution exceptions</span><span class="s1"> 
                                                </span><span class="s2">if </span><span class="s1">( depth + </span><span class="s4">1 </span><span class="s1">&gt;= maxDepth ) { 
 
                                                    </span><span class="s0">// Only substitute handlers pass on context</span><span class="s1"> 
                                                    </span><span class="s0">// and multiple values (non-spec behavior)</span><span class="s1"> 
                                                    </span><span class="s2">if </span><span class="s1">( handler !== Thrower ) { 
                                                        that = undefined; 
                                                        args = [ e ]; 
                                                    } 
 
                                                    deferred.rejectWith( that, args ); 
                                                } 
                                            } 
                                        }; 
 
                                </span><span class="s0">// Support: Promises/A+ section 2.3.3.3.1</span><span class="s1"> 
                                </span><span class="s0">// https://promisesaplus.com/#point-57</span><span class="s1"> 
                                </span><span class="s0">// Re-resolve promises immediately to dodge false rejection from</span><span class="s1"> 
                                </span><span class="s0">// subsequent errors</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( depth ) { 
                                    process(); 
                                } </span><span class="s2">else </span><span class="s1">{ 
 
                                    </span><span class="s0">// Call an optional hook to record the stack, in case of exception</span><span class="s1"> 
                                    </span><span class="s0">// since it's otherwise lost when execution goes async</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( jQuery.Deferred.getStackHook ) { 
                                        process.stackTrace = jQuery.Deferred.getStackHook(); 
                                    } 
                                    window.setTimeout( process ); 
                                } 
                            }; 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">jQuery.Deferred( </span><span class="s2">function</span><span class="s1">( newDefer ) { 
 
                            </span><span class="s0">// progress_handlers.add( ... )</span><span class="s1"> 
                            tuples[ </span><span class="s4">0 </span><span class="s1">][ </span><span class="s4">3 </span><span class="s1">].add( 
                                resolve( 
                                    </span><span class="s4">0</span><span class="s1">, 
                                    newDefer, 
                                    jQuery.isFunction( onProgress ) ? 
                                        onProgress : 
                                        Identity, 
                                    newDefer.notifyWith 
                                ) 
                            ); 
 
                            </span><span class="s0">// fulfilled_handlers.add( ... )</span><span class="s1"> 
                            tuples[ </span><span class="s4">1 </span><span class="s1">][ </span><span class="s4">3 </span><span class="s1">].add( 
                                resolve( 
                                    </span><span class="s4">0</span><span class="s1">, 
                                    newDefer, 
                                    jQuery.isFunction( onFulfilled ) ? 
                                        onFulfilled : 
                                        Identity 
                                ) 
                            ); 
 
                            </span><span class="s0">// rejected_handlers.add( ... )</span><span class="s1"> 
                            tuples[ </span><span class="s4">2 </span><span class="s1">][ </span><span class="s4">3 </span><span class="s1">].add( 
                                resolve( 
                                    </span><span class="s4">0</span><span class="s1">, 
                                    newDefer, 
                                    jQuery.isFunction( onRejected ) ? 
                                        onRejected : 
                                        Thrower 
                                ) 
                            ); 
                        } ).promise(); 
                    }, 
 
                    </span><span class="s0">// Get a promise for this deferred</span><span class="s1"> 
                    </span><span class="s0">// If obj is provided, the promise aspect is added to the object</span><span class="s1"> 
                    promise: </span><span class="s2">function</span><span class="s1">( obj ) { 
                        </span><span class="s2">return </span><span class="s1">obj != </span><span class="s2">null </span><span class="s1">? jQuery.extend( obj, promise ) : promise; 
                    } 
                }, 
                deferred = {}; 
 
            </span><span class="s0">// Add list-specific methods</span><span class="s1"> 
            jQuery.each( tuples, </span><span class="s2">function</span><span class="s1">( i, tuple ) { 
                </span><span class="s2">var </span><span class="s1">list = tuple[ </span><span class="s4">2 </span><span class="s1">], 
                    stateString = tuple[ </span><span class="s4">5 </span><span class="s1">]; 
 
                </span><span class="s0">// promise.progress = list.add</span><span class="s1"> 
                </span><span class="s0">// promise.done = list.add</span><span class="s1"> 
                </span><span class="s0">// promise.fail = list.add</span><span class="s1"> 
                promise[ tuple[ </span><span class="s4">1 </span><span class="s1">] ] = list.add; 
 
                </span><span class="s0">// Handle state</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( stateString ) { 
                    list.add( 
                        </span><span class="s2">function</span><span class="s1">() { 
 
                            </span><span class="s0">// state = &quot;resolved&quot; (i.e., fulfilled)</span><span class="s1"> 
                            </span><span class="s0">// state = &quot;rejected&quot;</span><span class="s1"> 
                            state = stateString; 
                        }, 
 
                        </span><span class="s0">// rejected_callbacks.disable</span><span class="s1"> 
                        </span><span class="s0">// fulfilled_callbacks.disable</span><span class="s1"> 
                        tuples[ </span><span class="s4">3 </span><span class="s1">- i ][ </span><span class="s4">2 </span><span class="s1">].disable, 
 
                        </span><span class="s0">// progress_callbacks.lock</span><span class="s1"> 
                        tuples[ </span><span class="s4">0 </span><span class="s1">][ </span><span class="s4">2 </span><span class="s1">].lock 
                    ); 
                } 
 
                </span><span class="s0">// progress_handlers.fire</span><span class="s1"> 
                </span><span class="s0">// fulfilled_handlers.fire</span><span class="s1"> 
                </span><span class="s0">// rejected_handlers.fire</span><span class="s1"> 
                list.add( tuple[ </span><span class="s4">3 </span><span class="s1">].fire ); 
 
                </span><span class="s0">// deferred.notify = function() { deferred.notifyWith(...) }</span><span class="s1"> 
                </span><span class="s0">// deferred.resolve = function() { deferred.resolveWith(...) }</span><span class="s1"> 
                </span><span class="s0">// deferred.reject = function() { deferred.rejectWith(...) }</span><span class="s1"> 
                deferred[ tuple[ </span><span class="s4">0 </span><span class="s1">] ] = </span><span class="s2">function</span><span class="s1">() { 
                    deferred[ tuple[ </span><span class="s4">0 </span><span class="s1">] + </span><span class="s3">&quot;With&quot; </span><span class="s1">]( </span><span class="s2">this </span><span class="s1">=== deferred ? undefined : </span><span class="s2">this</span><span class="s1">, arguments ); 
                    </span><span class="s2">return this</span><span class="s1">; 
                }; 
 
                </span><span class="s0">// deferred.notifyWith = list.fireWith</span><span class="s1"> 
                </span><span class="s0">// deferred.resolveWith = list.fireWith</span><span class="s1"> 
                </span><span class="s0">// deferred.rejectWith = list.fireWith</span><span class="s1"> 
                deferred[ tuple[ </span><span class="s4">0 </span><span class="s1">] + </span><span class="s3">&quot;With&quot; </span><span class="s1">] = list.fireWith; 
            } ); 
 
            </span><span class="s0">// Make the deferred a promise</span><span class="s1"> 
            promise.promise( deferred ); 
 
            </span><span class="s0">// Call given func if any</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( func ) { 
                func.call( deferred, deferred ); 
            } 
 
            </span><span class="s0">// All done!</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">deferred; 
        }, 
 
        </span><span class="s0">// Deferred helper</span><span class="s1"> 
        when: </span><span class="s2">function</span><span class="s1">( singleValue ) { 
            </span><span class="s2">var</span><span class="s1"> 
 
            </span><span class="s0">// count of uncompleted subordinates</span><span class="s1"> 
                remaining = arguments.length, 
 
            </span><span class="s0">// count of unprocessed arguments</span><span class="s1"> 
                i = remaining, 
 
            </span><span class="s0">// subordinate fulfillment data</span><span class="s1"> 
                resolveContexts = Array( i ), 
                resolveValues = slice.call( arguments ), 
 
            </span><span class="s0">// the master Deferred</span><span class="s1"> 
                master = jQuery.Deferred(), 
 
            </span><span class="s0">// subordinate callback factory</span><span class="s1"> 
                updateFunc = </span><span class="s2">function</span><span class="s1">( i ) { 
                    </span><span class="s2">return function</span><span class="s1">( value ) { 
                        resolveContexts[ i ] = </span><span class="s2">this</span><span class="s1">; 
                        resolveValues[ i ] = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">? slice.call( arguments ) : value; 
                        </span><span class="s2">if </span><span class="s1">( !( --remaining ) ) { 
                            master.resolveWith( resolveContexts, resolveValues ); 
                        } 
                    }; 
                }; 
 
            </span><span class="s0">// Single- and empty arguments are adopted like Promise.resolve</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( remaining &lt;= </span><span class="s4">1 </span><span class="s1">) { 
                adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject ); 
 
                </span><span class="s0">// Use .then() to unwrap secondary thenables (cf. gh-3000)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( master.state() === </span><span class="s3">&quot;pending&quot; </span><span class="s1">|| 
                    jQuery.isFunction( resolveValues[ i ] &amp;&amp; resolveValues[ i ].then ) ) { 
 
                    </span><span class="s2">return </span><span class="s1">master.then(); 
                } 
            } 
 
            </span><span class="s0">// Multiple arguments are aggregated like Promise.all array elements</span><span class="s1"> 
            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                adoptValue( resolveValues[ i ], updateFunc( i ), master.reject ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">master.promise(); 
        } 
    } ); 
 
 
</span><span class="s0">// These usually indicate a programmer mistake during development,</span><span class="s1"> 
</span><span class="s0">// warn about them ASAP rather than swallowing them by default.</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">rerrorNames = </span><span class="s4">/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/</span><span class="s1">; 
 
    jQuery.Deferred.exceptionHook = </span><span class="s2">function</span><span class="s1">( error, stack ) { 
 
        </span><span class="s0">// Support: IE 8 - 9 only</span><span class="s1"> 
        </span><span class="s0">// Console exists when dev tools are open, which can happen at any time</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( window.console &amp;&amp; window.console.warn &amp;&amp; error &amp;&amp; rerrorNames.test( error.name ) ) { 
            window.console.warn( </span><span class="s3">&quot;jQuery.Deferred exception: &quot; </span><span class="s1">+ error.message, error.stack, stack ); 
        } 
    }; 
 
 
 
 
    jQuery.readyException = </span><span class="s2">function</span><span class="s1">( error ) { 
        window.setTimeout( </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">throw </span><span class="s1">error; 
        } ); 
    }; 
 
 
 
 
</span><span class="s0">// The deferred used on DOM ready</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">readyList = jQuery.Deferred(); 
 
    jQuery.fn.ready = </span><span class="s2">function</span><span class="s1">( fn ) { 
 
        readyList 
            .then( fn ) 
 
            </span><span class="s0">// Wrap jQuery.readyException in a function so that the lookup</span><span class="s1"> 
            </span><span class="s0">// happens at the time of error handling instead of callback</span><span class="s1"> 
            </span><span class="s0">// registration.</span><span class="s1"> 
            .catch( </span><span class="s2">function</span><span class="s1">( error ) { 
                jQuery.readyException( error ); 
            } ); 
 
        </span><span class="s2">return this</span><span class="s1">; 
    }; 
 
    jQuery.extend( { 
 
        </span><span class="s0">// Is the DOM ready to be used? Set to true once it occurs.</span><span class="s1"> 
        isReady: </span><span class="s2">false</span><span class="s1">, 
 
        </span><span class="s0">// A counter to track how many items to wait for before</span><span class="s1"> 
        </span><span class="s0">// the ready event fires. See #6781</span><span class="s1"> 
        readyWait: </span><span class="s4">1</span><span class="s1">, 
 
        </span><span class="s0">// Hold (or release) the ready event</span><span class="s1"> 
        holdReady: </span><span class="s2">function</span><span class="s1">( hold ) { 
            </span><span class="s2">if </span><span class="s1">( hold ) { 
                jQuery.readyWait++; 
            } </span><span class="s2">else </span><span class="s1">{ 
                jQuery.ready( </span><span class="s2">true </span><span class="s1">); 
            } 
        }, 
 
        </span><span class="s0">// Handle when the DOM is ready</span><span class="s1"> 
        ready: </span><span class="s2">function</span><span class="s1">( wait ) { 
 
            </span><span class="s0">// Abort if there are pending holds or we're already ready</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( wait === </span><span class="s2">true </span><span class="s1">? --jQuery.readyWait : jQuery.isReady ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Remember that the DOM is ready</span><span class="s1"> 
            jQuery.isReady = </span><span class="s2">true</span><span class="s1">; 
 
            </span><span class="s0">// If a normal DOM Ready event fired, decrement, and wait if need be</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( wait !== </span><span class="s2">true </span><span class="s1">&amp;&amp; --jQuery.readyWait &gt; </span><span class="s4">0 </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// If there are functions bound, to execute</span><span class="s1"> 
            readyList.resolveWith( document, [ jQuery ] ); 
        } 
    } ); 
 
    jQuery.ready.then = readyList.then; 
 
</span><span class="s0">// The ready event handler and self cleanup method</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">completed() { 
        document.removeEventListener( </span><span class="s3">&quot;DOMContentLoaded&quot;</span><span class="s1">, completed ); 
        window.removeEventListener( </span><span class="s3">&quot;load&quot;</span><span class="s1">, completed ); 
        jQuery.ready(); 
    } 
 
</span><span class="s0">// Catch cases where $(document).ready() is called</span><span class="s1"> 
</span><span class="s0">// after the browser event has already occurred.</span><span class="s1"> 
</span><span class="s0">// Support: IE &lt;=9 - 10 only</span><span class="s1"> 
</span><span class="s0">// Older IE sometimes signals &quot;interactive&quot; too soon</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( document.readyState === </span><span class="s3">&quot;complete&quot; </span><span class="s1">|| 
        ( document.readyState !== </span><span class="s3">&quot;loading&quot; </span><span class="s1">&amp;&amp; !document.documentElement.doScroll ) ) { 
 
        </span><span class="s0">// Handle it asynchronously to allow scripts the opportunity to delay ready</span><span class="s1"> 
        window.setTimeout( jQuery.ready ); 
 
    } </span><span class="s2">else </span><span class="s1">{ 
 
        </span><span class="s0">// Use the handy event callback</span><span class="s1"> 
        document.addEventListener( </span><span class="s3">&quot;DOMContentLoaded&quot;</span><span class="s1">, completed ); 
 
        </span><span class="s0">// A fallback to window.onload, that will always work</span><span class="s1"> 
        window.addEventListener( </span><span class="s3">&quot;load&quot;</span><span class="s1">, completed ); 
    } 
 
 
 
 
</span><span class="s0">// Multifunctional method to get and set values of a collection</span><span class="s1"> 
</span><span class="s0">// The value/s can optionally be executed if it's a function</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">access = </span><span class="s2">function</span><span class="s1">( elems, fn, key, value, chainable, emptyGet, raw ) { 
        </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, 
            len = elems.length, 
            bulk = key == </span><span class="s2">null</span><span class="s1">; 
 
        </span><span class="s0">// Sets many values</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.type( key ) === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
            chainable = </span><span class="s2">true</span><span class="s1">; 
            </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">key ) { 
                access( elems, fn, i, key[ i ], </span><span class="s2">true</span><span class="s1">, emptyGet, raw ); 
            } 
 
            </span><span class="s0">// Sets one value</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( value !== undefined ) { 
            chainable = </span><span class="s2">true</span><span class="s1">; 
 
            </span><span class="s2">if </span><span class="s1">( !jQuery.isFunction( value ) ) { 
                raw = </span><span class="s2">true</span><span class="s1">; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( bulk ) { 
 
                </span><span class="s0">// Bulk operations run against the entire set</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( raw ) { 
                    fn.call( elems, value ); 
                    fn = </span><span class="s2">null</span><span class="s1">; 
 
                    </span><span class="s0">// ...except when executing function values</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    bulk = fn; 
                    fn = </span><span class="s2">function</span><span class="s1">( elem, key, value ) { 
                        </span><span class="s2">return </span><span class="s1">bulk.call( jQuery( elem ), value ); 
                    }; 
                } 
            } 
 
            </span><span class="s2">if </span><span class="s1">( fn ) { 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                    fn( 
                        elems[ i ], key, raw ? 
                            value : 
                            value.call( elems[ i ], i, fn( elems[ i ], key ) ) 
                    ); 
                } 
            } 
        } 
 
        </span><span class="s2">if </span><span class="s1">( chainable ) { 
            </span><span class="s2">return </span><span class="s1">elems; 
        } 
 
        </span><span class="s0">// Gets</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( bulk ) { 
            </span><span class="s2">return </span><span class="s1">fn.call( elems ); 
        } 
 
        </span><span class="s2">return </span><span class="s1">len ? fn( elems[ </span><span class="s4">0 </span><span class="s1">], key ) : emptyGet; 
    }; 
    </span><span class="s2">var </span><span class="s1">acceptData = </span><span class="s2">function</span><span class="s1">( owner ) { 
 
        </span><span class="s0">// Accepts only:</span><span class="s1"> 
        </span><span class="s0">//  - Node</span><span class="s1"> 
        </span><span class="s0">//    - Node.ELEMENT_NODE</span><span class="s1"> 
        </span><span class="s0">//    - Node.DOCUMENT_NODE</span><span class="s1"> 
        </span><span class="s0">//  - Object</span><span class="s1"> 
        </span><span class="s0">//    - Any</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">owner.nodeType === </span><span class="s4">1 </span><span class="s1">|| owner.nodeType === </span><span class="s4">9 </span><span class="s1">|| !( +owner.nodeType ); 
    }; 
 
 
 
 
    </span><span class="s2">function </span><span class="s1">Data() { 
        </span><span class="s2">this</span><span class="s1">.expando = jQuery.expando + Data.uid++; 
    } 
 
    Data.uid = </span><span class="s4">1</span><span class="s1">; 
 
    Data.prototype = { 
 
        cache: </span><span class="s2">function</span><span class="s1">( owner ) { 
 
            </span><span class="s0">// Check if the owner object already has a cache</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">value = owner[ </span><span class="s2">this</span><span class="s1">.expando ]; 
 
            </span><span class="s0">// If not, create one</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !value ) { 
                value = {}; 
 
                </span><span class="s0">// We can accept data for non-element nodes in modern browsers,</span><span class="s1"> 
                </span><span class="s0">// but we should not, see #8335.</span><span class="s1"> 
                </span><span class="s0">// Always return an empty object.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( acceptData( owner ) ) { 
 
                    </span><span class="s0">// If it is a node unlikely to be stringify-ed or looped over</span><span class="s1"> 
                    </span><span class="s0">// use plain assignment</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( owner.nodeType ) { 
                        owner[ </span><span class="s2">this</span><span class="s1">.expando ] = value; 
 
                        </span><span class="s0">// Otherwise secure it in a non-enumerable property</span><span class="s1"> 
                        </span><span class="s0">// configurable must be true to allow the property to be</span><span class="s1"> 
                        </span><span class="s0">// deleted when data is removed</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        Object.defineProperty( owner, </span><span class="s2">this</span><span class="s1">.expando, { 
                            value: value, 
                            configurable: </span><span class="s2">true</span><span class="s1"> 
                        } ); 
                    } 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">value; 
        }, 
        </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( owner, data, value ) { 
            </span><span class="s2">var </span><span class="s1">prop, 
                cache = </span><span class="s2">this</span><span class="s1">.cache( owner ); 
 
            </span><span class="s0">// Handle: [ owner, key, value ] args</span><span class="s1"> 
            </span><span class="s0">// Always use camelCase key (gh-2257)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">data === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                cache[ jQuery.camelCase( data ) ] = value; 
 
                </span><span class="s0">// Handle: [ owner, { properties } ] args</span><span class="s1"> 
            } </span><span class="s2">else </span><span class="s1">{ 
 
                </span><span class="s0">// Copy the properties one-by-one to the cache object</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">data ) { 
                    cache[ jQuery.camelCase( prop ) ] = data[ prop ]; 
                } 
            } 
            </span><span class="s2">return </span><span class="s1">cache; 
        }, 
        </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( owner, key ) { 
            </span><span class="s2">return </span><span class="s1">key === undefined ? 
                </span><span class="s2">this</span><span class="s1">.cache( owner ) : 
 
                </span><span class="s0">// Always use camelCase key (gh-2257)</span><span class="s1"> 
            owner[ </span><span class="s2">this</span><span class="s1">.expando ] &amp;&amp; owner[ </span><span class="s2">this</span><span class="s1">.expando ][ jQuery.camelCase( key ) ]; 
        }, 
        access: </span><span class="s2">function</span><span class="s1">( owner, key, value ) { 
 
            </span><span class="s0">// In cases where either:</span><span class="s1"> 
            </span><span class="s0">//</span><span class="s1"> 
            </span><span class="s0">//   1. No key was specified</span><span class="s1"> 
            </span><span class="s0">//   2. A string key was specified, but no value provided</span><span class="s1"> 
            </span><span class="s0">//</span><span class="s1"> 
            </span><span class="s0">// Take the &quot;read&quot; path and allow the get method to determine</span><span class="s1"> 
            </span><span class="s0">// which value to return, respectively either:</span><span class="s1"> 
            </span><span class="s0">//</span><span class="s1"> 
            </span><span class="s0">//   1. The entire cache object</span><span class="s1"> 
            </span><span class="s0">//   2. The data stored at the key</span><span class="s1"> 
            </span><span class="s0">//</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( key === undefined || 
                ( ( key &amp;&amp; </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">&quot;string&quot; </span><span class="s1">) &amp;&amp; value === undefined ) ) { 
 
                </span><span class="s2">return this</span><span class="s1">.get( owner, key ); 
            } 
 
            </span><span class="s0">// When the key is not a string, or both a key and value</span><span class="s1"> 
            </span><span class="s0">// are specified, set or extend (existing objects) with either:</span><span class="s1"> 
            </span><span class="s0">//</span><span class="s1"> 
            </span><span class="s0">//   1. An object of properties</span><span class="s1"> 
            </span><span class="s0">//   2. A key and value</span><span class="s1"> 
            </span><span class="s0">//</span><span class="s1"> 
            </span><span class="s2">this</span><span class="s1">.set( owner, key, value ); 
 
            </span><span class="s0">// Since the &quot;set&quot; path can have two possible entry points</span><span class="s1"> 
            </span><span class="s0">// return the expected data based on which path was taken[*]</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">value !== undefined ? value : key; 
        }, 
        remove: </span><span class="s2">function</span><span class="s1">( owner, key ) { 
            </span><span class="s2">var </span><span class="s1">i, 
                cache = owner[ </span><span class="s2">this</span><span class="s1">.expando ]; 
 
            </span><span class="s2">if </span><span class="s1">( cache === undefined ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( key !== undefined ) { 
 
                </span><span class="s0">// Support array or space separated string of keys</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( jQuery.isArray( key ) ) { 
 
                    </span><span class="s0">// If key is an array of keys...</span><span class="s1"> 
                    </span><span class="s0">// We always set camelCase keys, so remove that.</span><span class="s1"> 
                    key = key.map( jQuery.camelCase ); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    key = jQuery.camelCase( key ); 
 
                    </span><span class="s0">// If a key with the spaces exists, use it.</span><span class="s1"> 
                    </span><span class="s0">// Otherwise, create an array by matching non-whitespace</span><span class="s1"> 
                    key = key </span><span class="s2">in </span><span class="s1">cache ? 
                        [ key ] : 
                        ( key.match( rnothtmlwhite ) || [] ); 
                } 
 
                i = key.length; 
 
                </span><span class="s2">while </span><span class="s1">( i-- ) { 
                    </span><span class="s2">delete </span><span class="s1">cache[ key[ i ] ]; 
                } 
            } 
 
            </span><span class="s0">// Remove the expando if there's no more data</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( key === undefined || jQuery.isEmptyObject( cache ) ) { 
 
                </span><span class="s0">// Support: Chrome &lt;=35 - 45</span><span class="s1"> 
                </span><span class="s0">// Webkit &amp; Blink performance suffers when deleting properties</span><span class="s1"> 
                </span><span class="s0">// from DOM nodes, so set to undefined instead</span><span class="s1"> 
                </span><span class="s0">// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( owner.nodeType ) { 
                    owner[ </span><span class="s2">this</span><span class="s1">.expando ] = undefined; 
                } </span><span class="s2">else </span><span class="s1">{ 
                    </span><span class="s2">delete </span><span class="s1">owner[ </span><span class="s2">this</span><span class="s1">.expando ]; 
                } 
            } 
        }, 
        hasData: </span><span class="s2">function</span><span class="s1">( owner ) { 
            </span><span class="s2">var </span><span class="s1">cache = owner[ </span><span class="s2">this</span><span class="s1">.expando ]; 
            </span><span class="s2">return </span><span class="s1">cache !== undefined &amp;&amp; !jQuery.isEmptyObject( cache ); 
        } 
    }; 
    </span><span class="s2">var </span><span class="s1">dataPriv = </span><span class="s2">new </span><span class="s1">Data(); 
 
    </span><span class="s2">var </span><span class="s1">dataUser = </span><span class="s2">new </span><span class="s1">Data(); 
 
 
 
</span><span class="s0">//  Implementation Summary</span><span class="s1"> 
</span><span class="s0">//</span><span class="s1"> 
</span><span class="s0">//  1. Enforce API surface and semantic compatibility with 1.9.x branch</span><span class="s1"> 
</span><span class="s0">//  2. Improve the module's maintainability by reducing the storage</span><span class="s1"> 
</span><span class="s0">//      paths to a single mechanism.</span><span class="s1"> 
</span><span class="s0">//  3. Use the same single mechanism to support &quot;private&quot; and &quot;user&quot; data.</span><span class="s1"> 
</span><span class="s0">//  4. _Never_ expose &quot;private&quot; data to user code (TODO: Drop _data, _removeData)</span><span class="s1"> 
</span><span class="s0">//  5. Avoid exposing implementation details on user objects (eg. expando properties)</span><span class="s1"> 
</span><span class="s0">//  6. Provide a clear path for implementation upgrade to WeakMap in 2014</span><span class="s1"> 
 
    </span><span class="s2">var </span><span class="s1">rbrace = </span><span class="s4">/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/</span><span class="s1">, 
        rmultiDash = </span><span class="s4">/[A-Z]/g</span><span class="s1">; 
 
    </span><span class="s2">function </span><span class="s1">getData( data ) { 
        </span><span class="s2">if </span><span class="s1">( data === </span><span class="s3">&quot;true&quot; </span><span class="s1">) { 
            </span><span class="s2">return true</span><span class="s1">; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( data === </span><span class="s3">&quot;false&quot; </span><span class="s1">) { 
            </span><span class="s2">return false</span><span class="s1">; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( data === </span><span class="s3">&quot;null&quot; </span><span class="s1">) { 
            </span><span class="s2">return null</span><span class="s1">; 
        } 
 
        </span><span class="s0">// Only convert to a number if it doesn't change the string</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( data === +data + </span><span class="s3">&quot;&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">+data; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( rbrace.test( data ) ) { 
            </span><span class="s2">return </span><span class="s1">JSON.parse( data ); 
        } 
 
        </span><span class="s2">return </span><span class="s1">data; 
    } 
 
    </span><span class="s2">function </span><span class="s1">dataAttr( elem, key, data ) { 
        </span><span class="s2">var </span><span class="s1">name; 
 
        </span><span class="s0">// If nothing was found internally, try to fetch any</span><span class="s1"> 
        </span><span class="s0">// data from the HTML5 data-* attribute</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( data === undefined &amp;&amp; elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
            name = </span><span class="s3">&quot;data-&quot; </span><span class="s1">+ key.replace( rmultiDash, </span><span class="s3">&quot;-$&amp;&quot; </span><span class="s1">).toLowerCase(); 
            data = elem.getAttribute( name ); 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">data === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s2">try </span><span class="s1">{ 
                    data = getData( data ); 
                } </span><span class="s2">catch </span><span class="s1">( e ) {} 
 
                </span><span class="s0">// Make sure we set the data so it isn't changed later</span><span class="s1"> 
                dataUser.set( elem, key, data ); 
            } </span><span class="s2">else </span><span class="s1">{ 
                data = undefined; 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">data; 
    } 
 
    jQuery.extend( { 
        hasData: </span><span class="s2">function</span><span class="s1">( elem ) { 
            </span><span class="s2">return </span><span class="s1">dataUser.hasData( elem ) || dataPriv.hasData( elem ); 
        }, 
 
        data: </span><span class="s2">function</span><span class="s1">( elem, name, data ) { 
            </span><span class="s2">return </span><span class="s1">dataUser.access( elem, name, data ); 
        }, 
 
        removeData: </span><span class="s2">function</span><span class="s1">( elem, name ) { 
            dataUser.remove( elem, name ); 
        }, 
 
        </span><span class="s0">// TODO: Now that all calls to _data and _removeData have been replaced</span><span class="s1"> 
        </span><span class="s0">// with direct calls to dataPriv methods, these can be deprecated.</span><span class="s1"> 
        _data: </span><span class="s2">function</span><span class="s1">( elem, name, data ) { 
            </span><span class="s2">return </span><span class="s1">dataPriv.access( elem, name, data ); 
        }, 
 
        _removeData: </span><span class="s2">function</span><span class="s1">( elem, name ) { 
            dataPriv.remove( elem, name ); 
        } 
    } ); 
 
    jQuery.fn.extend( { 
        data: </span><span class="s2">function</span><span class="s1">( key, value ) { 
            </span><span class="s2">var </span><span class="s1">i, name, data, 
                elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">], 
                attrs = elem &amp;&amp; elem.attributes; 
 
            </span><span class="s0">// Gets all values</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( key === undefined ) { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.length ) { 
                    data = dataUser.get( elem ); 
 
                    </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; !dataPriv.get( elem, </span><span class="s3">&quot;hasDataAttrs&quot; </span><span class="s1">) ) { 
                        i = attrs.length; 
                        </span><span class="s2">while </span><span class="s1">( i-- ) { 
 
                            </span><span class="s0">// Support: IE 11 only</span><span class="s1"> 
                            </span><span class="s0">// The attrs elements can be null (#14894)</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( attrs[ i ] ) { 
                                name = attrs[ i ].name; 
                                </span><span class="s2">if </span><span class="s1">( name.indexOf( </span><span class="s3">&quot;data-&quot; </span><span class="s1">) === </span><span class="s4">0 </span><span class="s1">) { 
                                    name = jQuery.camelCase( name.slice( </span><span class="s4">5 </span><span class="s1">) ); 
                                    dataAttr( elem, name, data[ name ] ); 
                                } 
                            } 
                        } 
                        dataPriv.set( elem, </span><span class="s3">&quot;hasDataAttrs&quot;</span><span class="s1">, </span><span class="s2">true </span><span class="s1">); 
                    } 
                } 
 
                </span><span class="s2">return </span><span class="s1">data; 
            } 
 
            </span><span class="s0">// Sets multiple values</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">key === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
                </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                    dataUser.set( </span><span class="s2">this</span><span class="s1">, key ); 
                } ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( value ) { 
                </span><span class="s2">var </span><span class="s1">data; 
 
                </span><span class="s0">// The calling jQuery object (element matches) is not empty</span><span class="s1"> 
                </span><span class="s0">// (and therefore has an element appears at this[ 0 ]) and the</span><span class="s1"> 
                </span><span class="s0">// `value` parameter was not undefined. An empty jQuery object</span><span class="s1"> 
                </span><span class="s0">// will result in `undefined` for elem = this[ 0 ] which will</span><span class="s1"> 
                </span><span class="s0">// throw an exception if an attempt to read a data cache is made.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( elem &amp;&amp; value === undefined ) { 
 
                    </span><span class="s0">// Attempt to get data from the cache</span><span class="s1"> 
                    </span><span class="s0">// The key will always be camelCased in Data</span><span class="s1"> 
                    data = dataUser.get( elem, key ); 
                    </span><span class="s2">if </span><span class="s1">( data !== undefined ) { 
                        </span><span class="s2">return </span><span class="s1">data; 
                    } 
 
                    </span><span class="s0">// Attempt to &quot;discover&quot; the data in</span><span class="s1"> 
                    </span><span class="s0">// HTML5 custom data-* attrs</span><span class="s1"> 
                    data = dataAttr( elem, key ); 
                    </span><span class="s2">if </span><span class="s1">( data !== undefined ) { 
                        </span><span class="s2">return </span><span class="s1">data; 
                    } 
 
                    </span><span class="s0">// We tried really hard, but the data doesn't exist.</span><span class="s1"> 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
 
                </span><span class="s0">// Set the data...</span><span class="s1"> 
                </span><span class="s2">this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
 
                    </span><span class="s0">// We always store the camelCased key</span><span class="s1"> 
                    dataUser.set( </span><span class="s2">this</span><span class="s1">, key, value ); 
                } ); 
            }, </span><span class="s2">null</span><span class="s1">, value, arguments.length &gt; </span><span class="s4">1</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, </span><span class="s2">true </span><span class="s1">); 
        }, 
 
        removeData: </span><span class="s2">function</span><span class="s1">( key ) { 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                dataUser.remove( </span><span class="s2">this</span><span class="s1">, key ); 
            } ); 
        } 
    } ); 
 
 
    jQuery.extend( { 
        queue: </span><span class="s2">function</span><span class="s1">( elem, type, data ) { 
            </span><span class="s2">var </span><span class="s1">queue; 
 
            </span><span class="s2">if </span><span class="s1">( elem ) { 
                type = ( type || </span><span class="s3">&quot;fx&quot; </span><span class="s1">) + </span><span class="s3">&quot;queue&quot;</span><span class="s1">; 
                queue = dataPriv.get( elem, type ); 
 
                </span><span class="s0">// Speed up dequeue by getting out quickly if this is just a lookup</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( data ) { 
                    </span><span class="s2">if </span><span class="s1">( !queue || jQuery.isArray( data ) ) { 
                        queue = dataPriv.access( elem, type, jQuery.makeArray( data ) ); 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        queue.push( data ); 
                    } 
                } 
                </span><span class="s2">return </span><span class="s1">queue || []; 
            } 
        }, 
 
        dequeue: </span><span class="s2">function</span><span class="s1">( elem, type ) { 
            type = type || </span><span class="s3">&quot;fx&quot;</span><span class="s1">; 
 
            </span><span class="s2">var </span><span class="s1">queue = jQuery.queue( elem, type ), 
                startLength = queue.length, 
                fn = queue.shift(), 
                hooks = jQuery._queueHooks( elem, type ), 
                next = </span><span class="s2">function</span><span class="s1">() { 
                    jQuery.dequeue( elem, type ); 
                }; 
 
            </span><span class="s0">// If the fx queue is dequeued, always remove the progress sentinel</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( fn === </span><span class="s3">&quot;inprogress&quot; </span><span class="s1">) { 
                fn = queue.shift(); 
                startLength--; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( fn ) { 
 
                </span><span class="s0">// Add a progress sentinel to prevent the fx queue from being</span><span class="s1"> 
                </span><span class="s0">// automatically dequeued</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;fx&quot; </span><span class="s1">) { 
                    queue.unshift( </span><span class="s3">&quot;inprogress&quot; </span><span class="s1">); 
                } 
 
                </span><span class="s0">// Clear up the last queue stop function</span><span class="s1"> 
                </span><span class="s2">delete </span><span class="s1">hooks.stop; 
                fn.call( elem, next, hooks ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( !startLength &amp;&amp; hooks ) { 
                hooks.empty.fire(); 
            } 
        }, 
 
        </span><span class="s0">// Not public - generate a queueHooks object, or return the current one</span><span class="s1"> 
        _queueHooks: </span><span class="s2">function</span><span class="s1">( elem, type ) { 
            </span><span class="s2">var </span><span class="s1">key = type + </span><span class="s3">&quot;queueHooks&quot;</span><span class="s1">; 
            </span><span class="s2">return </span><span class="s1">dataPriv.get( elem, key ) || dataPriv.access( elem, key, { 
                    empty: jQuery.Callbacks( </span><span class="s3">&quot;once memory&quot; </span><span class="s1">).add( </span><span class="s2">function</span><span class="s1">() { 
                        dataPriv.remove( elem, [ type + </span><span class="s3">&quot;queue&quot;</span><span class="s1">, key ] ); 
                    } ) 
                } ); 
        } 
    } ); 
 
    jQuery.fn.extend( { 
        queue: </span><span class="s2">function</span><span class="s1">( type, data ) { 
            </span><span class="s2">var </span><span class="s1">setter = </span><span class="s4">2</span><span class="s1">; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">type !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                data = type; 
                type = </span><span class="s3">&quot;fx&quot;</span><span class="s1">; 
                setter--; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( arguments.length &lt; setter ) { 
                </span><span class="s2">return </span><span class="s1">jQuery.queue( </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">], type ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">data === undefined ? 
                </span><span class="s2">this </span><span class="s1">: 
                </span><span class="s2">this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">var </span><span class="s1">queue = jQuery.queue( </span><span class="s2">this</span><span class="s1">, type, data ); 
 
                    </span><span class="s0">// Ensure a hooks for this queue</span><span class="s1"> 
                    jQuery._queueHooks( </span><span class="s2">this</span><span class="s1">, type ); 
 
                    </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;fx&quot; </span><span class="s1">&amp;&amp; queue[ </span><span class="s4">0 </span><span class="s1">] !== </span><span class="s3">&quot;inprogress&quot; </span><span class="s1">) { 
                        jQuery.dequeue( </span><span class="s2">this</span><span class="s1">, type ); 
                    } 
                } ); 
        }, 
        dequeue: </span><span class="s2">function</span><span class="s1">( type ) { 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                jQuery.dequeue( </span><span class="s2">this</span><span class="s1">, type ); 
            } ); 
        }, 
        clearQueue: </span><span class="s2">function</span><span class="s1">( type ) { 
            </span><span class="s2">return this</span><span class="s1">.queue( type || </span><span class="s3">&quot;fx&quot;</span><span class="s1">, [] ); 
        }, 
 
        </span><span class="s0">// Get a promise resolved when queues of a certain type</span><span class="s1"> 
        </span><span class="s0">// are emptied (fx is the type by default)</span><span class="s1"> 
        promise: </span><span class="s2">function</span><span class="s1">( type, obj ) { 
            </span><span class="s2">var </span><span class="s1">tmp, 
                count = </span><span class="s4">1</span><span class="s1">, 
                defer = jQuery.Deferred(), 
                elements = </span><span class="s2">this</span><span class="s1">, 
                i = </span><span class="s2">this</span><span class="s1">.length, 
                resolve = </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( !( --count ) ) { 
                        defer.resolveWith( elements, [ elements ] ); 
                    } 
                }; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">type !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                obj = type; 
                type = undefined; 
            } 
            type = type || </span><span class="s3">&quot;fx&quot;</span><span class="s1">; 
 
            </span><span class="s2">while </span><span class="s1">( i-- ) { 
                tmp = dataPriv.get( elements[ i ], type + </span><span class="s3">&quot;queueHooks&quot; </span><span class="s1">); 
                </span><span class="s2">if </span><span class="s1">( tmp &amp;&amp; tmp.empty ) { 
                    count++; 
                    tmp.empty.add( resolve ); 
                } 
            } 
            resolve(); 
            </span><span class="s2">return </span><span class="s1">defer.promise( obj ); 
        } 
    } ); 
    </span><span class="s2">var </span><span class="s1">pnum = ( </span><span class="s4">/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ </span><span class="s1">).source; 
 
    </span><span class="s2">var </span><span class="s1">rcssNum = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^(?:([+-])=|)(&quot; </span><span class="s1">+ pnum + </span><span class="s3">&quot;)([a-z%]*)$&quot;</span><span class="s1">, </span><span class="s3">&quot;i&quot; </span><span class="s1">); 
 
 
    </span><span class="s2">var </span><span class="s1">cssExpand = [ </span><span class="s3">&quot;Top&quot;</span><span class="s1">, </span><span class="s3">&quot;Right&quot;</span><span class="s1">, </span><span class="s3">&quot;Bottom&quot;</span><span class="s1">, </span><span class="s3">&quot;Left&quot; </span><span class="s1">]; 
 
    </span><span class="s2">var </span><span class="s1">isHiddenWithinTree = </span><span class="s2">function</span><span class="s1">( elem, el ) { 
 
        </span><span class="s0">// isHiddenWithinTree might be called from jQuery#filter function;</span><span class="s1"> 
        </span><span class="s0">// in that case, element will be second argument</span><span class="s1"> 
        elem = el || elem; 
 
        </span><span class="s0">// Inline style trumps all</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">elem.style.display === </span><span class="s3">&quot;none&quot; </span><span class="s1">|| 
            elem.style.display === </span><span class="s3">&quot;&quot; </span><span class="s1">&amp;&amp; 
 
                </span><span class="s0">// Otherwise, check computed style</span><span class="s1"> 
                </span><span class="s0">// Support: Firefox &lt;=43 - 45</span><span class="s1"> 
                </span><span class="s0">// Disconnected elements can have computed display: none, so first confirm that elem is</span><span class="s1"> 
                </span><span class="s0">// in the document.</span><span class="s1"> 
            jQuery.contains( elem.ownerDocument, elem ) &amp;&amp; 
 
            jQuery.css( elem, </span><span class="s3">&quot;display&quot; </span><span class="s1">) === </span><span class="s3">&quot;none&quot;</span><span class="s1">; 
    }; 
 
    </span><span class="s2">var </span><span class="s1">swap = </span><span class="s2">function</span><span class="s1">( elem, options, callback, args ) { 
        </span><span class="s2">var </span><span class="s1">ret, name, 
            old = {}; 
 
        </span><span class="s0">// Remember the old values, and insert the new ones</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">options ) { 
            old[ name ] = elem.style[ name ]; 
            elem.style[ name ] = options[ name ]; 
        } 
 
        ret = callback.apply( elem, args || [] ); 
 
        </span><span class="s0">// Revert the old values</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">options ) { 
            elem.style[ name ] = old[ name ]; 
        } 
 
        </span><span class="s2">return </span><span class="s1">ret; 
    }; 
 
 
 
 
    </span><span class="s2">function </span><span class="s1">adjustCSS( elem, prop, valueParts, tween ) { 
        </span><span class="s2">var </span><span class="s1">adjusted, 
            scale = </span><span class="s4">1</span><span class="s1">, 
            maxIterations = </span><span class="s4">20</span><span class="s1">, 
            currentValue = tween ? 
                </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">tween.cur(); 
                } : 
                </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">return </span><span class="s1">jQuery.css( elem, prop, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
                }, 
            initial = currentValue(), 
            unit = valueParts &amp;&amp; valueParts[ </span><span class="s4">3 </span><span class="s1">] || ( jQuery.cssNumber[ prop ] ? </span><span class="s3">&quot;&quot; </span><span class="s1">: </span><span class="s3">&quot;px&quot; </span><span class="s1">), 
 
        </span><span class="s0">// Starting value computation is required for potential unit mismatches</span><span class="s1"> 
            initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== </span><span class="s3">&quot;px&quot; </span><span class="s1">&amp;&amp; +initial ) &amp;&amp; 
                rcssNum.exec( jQuery.css( elem, prop ) ); 
 
        </span><span class="s2">if </span><span class="s1">( initialInUnit &amp;&amp; initialInUnit[ </span><span class="s4">3 </span><span class="s1">] !== unit ) { 
 
            </span><span class="s0">// Trust units reported by jQuery.css</span><span class="s1"> 
            unit = unit || initialInUnit[ </span><span class="s4">3 </span><span class="s1">]; 
 
            </span><span class="s0">// Make sure we update the tween properties later on</span><span class="s1"> 
            valueParts = valueParts || []; 
 
            </span><span class="s0">// Iteratively approximate from a nonzero starting point</span><span class="s1"> 
            initialInUnit = +initial || </span><span class="s4">1</span><span class="s1">; 
 
            </span><span class="s2">do </span><span class="s1">{ 
 
                </span><span class="s0">// If previous iteration zeroed out, double until we get *something*.</span><span class="s1"> 
                </span><span class="s0">// Use string for doubling so we don't accidentally see scale as unchanged below</span><span class="s1"> 
                scale = scale || </span><span class="s3">&quot;.5&quot;</span><span class="s1">; 
 
                </span><span class="s0">// Adjust and apply</span><span class="s1"> 
                initialInUnit = initialInUnit / scale; 
                jQuery.style( elem, prop, initialInUnit + unit ); 
 
                </span><span class="s0">// Update scale, tolerating zero or NaN from tween.cur()</span><span class="s1"> 
                </span><span class="s0">// Break the loop if scale is unchanged or perfect, or if we've just had enough.</span><span class="s1"> 
            } </span><span class="s2">while </span><span class="s1">( 
            scale !== ( scale = currentValue() / initial ) &amp;&amp; scale !== </span><span class="s4">1 </span><span class="s1">&amp;&amp; --maxIterations 
                ); 
        } 
 
        </span><span class="s2">if </span><span class="s1">( valueParts ) { 
            initialInUnit = +initialInUnit || +initial || </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s0">// Apply relative offset (+=/-=) if specified</span><span class="s1"> 
            adjusted = valueParts[ </span><span class="s4">1 </span><span class="s1">] ? 
            initialInUnit + ( valueParts[ </span><span class="s4">1 </span><span class="s1">] + </span><span class="s4">1 </span><span class="s1">) * valueParts[ </span><span class="s4">2 </span><span class="s1">] : 
                +valueParts[ </span><span class="s4">2 </span><span class="s1">]; 
            </span><span class="s2">if </span><span class="s1">( tween ) { 
                tween.unit = unit; 
                tween.start = initialInUnit; 
                tween.end = adjusted; 
            } 
        } 
        </span><span class="s2">return </span><span class="s1">adjusted; 
    } 
 
 
    </span><span class="s2">var </span><span class="s1">defaultDisplayMap = {}; 
 
    </span><span class="s2">function </span><span class="s1">getDefaultDisplay( elem ) { 
        </span><span class="s2">var </span><span class="s1">temp, 
            doc = elem.ownerDocument, 
            nodeName = elem.nodeName, 
            display = defaultDisplayMap[ nodeName ]; 
 
        </span><span class="s2">if </span><span class="s1">( display ) { 
            </span><span class="s2">return </span><span class="s1">display; 
        } 
 
        temp = doc.body.appendChild( doc.createElement( nodeName ) ); 
        display = jQuery.css( temp, </span><span class="s3">&quot;display&quot; </span><span class="s1">); 
 
        temp.parentNode.removeChild( temp ); 
 
        </span><span class="s2">if </span><span class="s1">( display === </span><span class="s3">&quot;none&quot; </span><span class="s1">) { 
            display = </span><span class="s3">&quot;block&quot;</span><span class="s1">; 
        } 
        defaultDisplayMap[ nodeName ] = display; 
 
        </span><span class="s2">return </span><span class="s1">display; 
    } 
 
    </span><span class="s2">function </span><span class="s1">showHide( elements, show ) { 
        </span><span class="s2">var </span><span class="s1">display, elem, 
            values = [], 
            index = </span><span class="s4">0</span><span class="s1">, 
            length = elements.length; 
 
        </span><span class="s0">// Determine new display value for elements that need to change</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( ; index &lt; length; index++ ) { 
            elem = elements[ index ]; 
            </span><span class="s2">if </span><span class="s1">( !elem.style ) { 
                </span><span class="s2">continue</span><span class="s1">; 
            } 
 
            display = elem.style.display; 
            </span><span class="s2">if </span><span class="s1">( show ) { 
 
                </span><span class="s0">// Since we force visibility upon cascade-hidden elements, an immediate (and slow)</span><span class="s1"> 
                </span><span class="s0">// check is required in this first loop unless we have a nonempty display value (either</span><span class="s1"> 
                </span><span class="s0">// inline or about-to-be-restored)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( display === </span><span class="s3">&quot;none&quot; </span><span class="s1">) { 
                    values[ index ] = dataPriv.get( elem, </span><span class="s3">&quot;display&quot; </span><span class="s1">) || </span><span class="s2">null</span><span class="s1">; 
                    </span><span class="s2">if </span><span class="s1">( !values[ index ] ) { 
                        elem.style.display = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                    } 
                } 
                </span><span class="s2">if </span><span class="s1">( elem.style.display === </span><span class="s3">&quot;&quot; </span><span class="s1">&amp;&amp; isHiddenWithinTree( elem ) ) { 
                    values[ index ] = getDefaultDisplay( elem ); 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">if </span><span class="s1">( display !== </span><span class="s3">&quot;none&quot; </span><span class="s1">) { 
                    values[ index ] = </span><span class="s3">&quot;none&quot;</span><span class="s1">; 
 
                    </span><span class="s0">// Remember what we're overwriting</span><span class="s1"> 
                    dataPriv.set( elem, </span><span class="s3">&quot;display&quot;</span><span class="s1">, display ); 
                } 
            } 
        } 
 
        </span><span class="s0">// Set the display of the elements in a second loop to avoid constant reflow</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( index = </span><span class="s4">0</span><span class="s1">; index &lt; length; index++ ) { 
            </span><span class="s2">if </span><span class="s1">( values[ index ] != </span><span class="s2">null </span><span class="s1">) { 
                elements[ index ].style.display = values[ index ]; 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">elements; 
    } 
 
    jQuery.fn.extend( { 
        show: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">showHide( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">true </span><span class="s1">); 
        }, 
        hide: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">showHide( </span><span class="s2">this </span><span class="s1">); 
        }, 
        toggle: </span><span class="s2">function</span><span class="s1">( state ) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">state === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">state ? </span><span class="s2">this</span><span class="s1">.show() : </span><span class="s2">this</span><span class="s1">.hide(); 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( isHiddenWithinTree( </span><span class="s2">this </span><span class="s1">) ) { 
                    jQuery( </span><span class="s2">this </span><span class="s1">).show(); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    jQuery( </span><span class="s2">this </span><span class="s1">).hide(); 
                } 
            } ); 
        } 
    } ); 
    </span><span class="s2">var </span><span class="s1">rcheckableType = ( </span><span class="s4">/^(?:checkbox|radio)$/i </span><span class="s1">); 
 
    </span><span class="s2">var </span><span class="s1">rtagName = ( </span><span class="s4">/&lt;([a-z][^\/\0&gt;\x20\t\r\n\f]+)/i </span><span class="s1">); 
 
    </span><span class="s2">var </span><span class="s1">rscriptType = ( </span><span class="s4">/^$|\/(?:java|ecma)script/i </span><span class="s1">); 
 
 
 
</span><span class="s0">// We have to close these tags to support XHTML (#13200)</span><span class="s1"> 
    </span><span class="s2">var </span><span class="s1">wrapMap = { 
 
        </span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
        option: [ </span><span class="s4">1</span><span class="s1">, </span><span class="s3">&quot;&lt;select multiple='multiple'&gt;&quot;</span><span class="s1">, </span><span class="s3">&quot;&lt;/select&gt;&quot; </span><span class="s1">], 
 
        </span><span class="s0">// XHTML parsers do not magically insert elements in the</span><span class="s1"> 
        </span><span class="s0">// same way that tag soup parsers do. So we cannot shorten</span><span class="s1"> 
        </span><span class="s0">// this by omitting &lt;tbody&gt; or other required elements.</span><span class="s1"> 
        thead: [ </span><span class="s4">1</span><span class="s1">, </span><span class="s3">&quot;&lt;table&gt;&quot;</span><span class="s1">, </span><span class="s3">&quot;&lt;/table&gt;&quot; </span><span class="s1">], 
        col: [ </span><span class="s4">2</span><span class="s1">, </span><span class="s3">&quot;&lt;table&gt;&lt;colgroup&gt;&quot;</span><span class="s1">, </span><span class="s3">&quot;&lt;/colgroup&gt;&lt;/table&gt;&quot; </span><span class="s1">], 
        tr: [ </span><span class="s4">2</span><span class="s1">, </span><span class="s3">&quot;&lt;table&gt;&lt;tbody&gt;&quot;</span><span class="s1">, </span><span class="s3">&quot;&lt;/tbody&gt;&lt;/table&gt;&quot; </span><span class="s1">], 
        td: [ </span><span class="s4">3</span><span class="s1">, </span><span class="s3">&quot;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&quot;</span><span class="s1">, </span><span class="s3">&quot;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&quot; </span><span class="s1">], 
 
        _default: [ </span><span class="s4">0</span><span class="s1">, </span><span class="s3">&quot;&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot; </span><span class="s1">] 
    }; 
 
</span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
    wrapMap.optgroup = wrapMap.option; 
 
    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead; 
    wrapMap.th = wrapMap.td; 
 
 
    </span><span class="s2">function </span><span class="s1">getAll( context, tag ) { 
 
        </span><span class="s0">// Support: IE &lt;=9 - 11 only</span><span class="s1"> 
        </span><span class="s0">// Use typeof to avoid zero-argument method invocation on host objects (#15151)</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">ret; 
 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.getElementsByTagName !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">) { 
            ret = context.getElementsByTagName( tag || </span><span class="s3">&quot;*&quot; </span><span class="s1">); 
 
        } </span><span class="s2">else if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context.querySelectorAll !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">) { 
            ret = context.querySelectorAll( tag || </span><span class="s3">&quot;*&quot; </span><span class="s1">); 
 
        } </span><span class="s2">else </span><span class="s1">{ 
            ret = []; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( tag === undefined || tag &amp;&amp; jQuery.nodeName( context, tag ) ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.merge( [ context ], ret ); 
        } 
 
        </span><span class="s2">return </span><span class="s1">ret; 
    } 
 
 
</span><span class="s0">// Mark scripts as having already been evaluated</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">setGlobalEval( elems, refElements ) { 
        </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, 
            l = elems.length; 
 
        </span><span class="s2">for </span><span class="s1">( ; i &lt; l; i++ ) { 
            dataPriv.set( 
                elems[ i ], 
                </span><span class="s3">&quot;globalEval&quot;</span><span class="s1">, 
                !refElements || dataPriv.get( refElements[ i ], </span><span class="s3">&quot;globalEval&quot; </span><span class="s1">) 
            ); 
        } 
    } 
 
 
    </span><span class="s2">var </span><span class="s1">rhtml = </span><span class="s4">/&lt;|&amp;#?\w+;/</span><span class="s1">; 
 
    </span><span class="s2">function </span><span class="s1">buildFragment( elems, context, scripts, selection, ignored ) { 
        </span><span class="s2">var </span><span class="s1">elem, tmp, tag, wrap, contains, j, 
            fragment = context.createDocumentFragment(), 
            nodes = [], 
            i = </span><span class="s4">0</span><span class="s1">, 
            l = elems.length; 
 
        </span><span class="s2">for </span><span class="s1">( ; i &lt; l; i++ ) { 
            elem = elems[ i ]; 
 
            </span><span class="s2">if </span><span class="s1">( elem || elem === </span><span class="s4">0 </span><span class="s1">) { 
 
                </span><span class="s0">// Add nodes directly</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( jQuery.type( elem ) === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
 
                    </span><span class="s0">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span><span class="s1"> 
                    </span><span class="s0">// push.apply(_, arraylike) throws on ancient WebKit</span><span class="s1"> 
                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem ); 
 
                    </span><span class="s0">// Convert non-html into a text node</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( !rhtml.test( elem ) ) { 
                    nodes.push( context.createTextNode( elem ) ); 
 
                    </span><span class="s0">// Convert html into DOM nodes</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    tmp = tmp || fragment.appendChild( context.createElement( </span><span class="s3">&quot;div&quot; </span><span class="s1">) ); 
 
                    </span><span class="s0">// Deserialize a standard representation</span><span class="s1"> 
                    tag = ( rtagName.exec( elem ) || [ </span><span class="s3">&quot;&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot; </span><span class="s1">] )[ </span><span class="s4">1 </span><span class="s1">].toLowerCase(); 
                    wrap = wrapMap[ tag ] || wrapMap._default; 
                    tmp.innerHTML = wrap[ </span><span class="s4">1 </span><span class="s1">] + jQuery.htmlPrefilter( elem ) + wrap[ </span><span class="s4">2 </span><span class="s1">]; 
 
                    </span><span class="s0">// Descend through wrappers to the right content</span><span class="s1"> 
                    j = wrap[ </span><span class="s4">0 </span><span class="s1">]; 
                    </span><span class="s2">while </span><span class="s1">( j-- ) { 
                        tmp = tmp.lastChild; 
                    } 
 
                    </span><span class="s0">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span><span class="s1"> 
                    </span><span class="s0">// push.apply(_, arraylike) throws on ancient WebKit</span><span class="s1"> 
                    jQuery.merge( nodes, tmp.childNodes ); 
 
                    </span><span class="s0">// Remember the top-level container</span><span class="s1"> 
                    tmp = fragment.firstChild; 
 
                    </span><span class="s0">// Ensure the created nodes are orphaned (#12392)</span><span class="s1"> 
                    tmp.textContent = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                } 
            } 
        } 
 
        </span><span class="s0">// Remove wrapper from fragment</span><span class="s1"> 
        fragment.textContent = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
        i = </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s2">while </span><span class="s1">( ( elem = nodes[ i++ ] ) ) { 
 
            </span><span class="s0">// Skip elements already in the context collection (trac-4087)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( selection &amp;&amp; jQuery.inArray( elem, selection ) &gt; -</span><span class="s4">1 </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( ignored ) { 
                    ignored.push( elem ); 
                } 
                </span><span class="s2">continue</span><span class="s1">; 
            } 
 
            contains = jQuery.contains( elem.ownerDocument, elem ); 
 
            </span><span class="s0">// Append to fragment</span><span class="s1"> 
            tmp = getAll( fragment.appendChild( elem ), </span><span class="s3">&quot;script&quot; </span><span class="s1">); 
 
            </span><span class="s0">// Preserve script evaluation history</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( contains ) { 
                setGlobalEval( tmp ); 
            } 
 
            </span><span class="s0">// Capture executables</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( scripts ) { 
                j = </span><span class="s4">0</span><span class="s1">; 
                </span><span class="s2">while </span><span class="s1">( ( elem = tmp[ j++ ] ) ) { 
                    </span><span class="s2">if </span><span class="s1">( rscriptType.test( elem.type || </span><span class="s3">&quot;&quot; </span><span class="s1">) ) { 
                        scripts.push( elem ); 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">fragment; 
    } 
 
 
    ( </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">fragment = document.createDocumentFragment(), 
            div = fragment.appendChild( document.createElement( </span><span class="s3">&quot;div&quot; </span><span class="s1">) ), 
            input = document.createElement( </span><span class="s3">&quot;input&quot; </span><span class="s1">); 
 
        </span><span class="s0">// Support: Android 4.0 - 4.3 only</span><span class="s1"> 
        </span><span class="s0">// Check state lost if the name is set (#11217)</span><span class="s1"> 
        </span><span class="s0">// Support: Windows Web Apps (WWA)</span><span class="s1"> 
        </span><span class="s0">// `name` and `type` must use .setAttribute for WWA (#14901)</span><span class="s1"> 
        input.setAttribute( </span><span class="s3">&quot;type&quot;</span><span class="s1">, </span><span class="s3">&quot;radio&quot; </span><span class="s1">); 
        input.setAttribute( </span><span class="s3">&quot;checked&quot;</span><span class="s1">, </span><span class="s3">&quot;checked&quot; </span><span class="s1">); 
        input.setAttribute( </span><span class="s3">&quot;name&quot;</span><span class="s1">, </span><span class="s3">&quot;t&quot; </span><span class="s1">); 
 
        div.appendChild( input ); 
 
        </span><span class="s0">// Support: Android &lt;=4.1 only</span><span class="s1"> 
        </span><span class="s0">// Older WebKit doesn't clone checked state correctly in fragments</span><span class="s1"> 
        support.checkClone = div.cloneNode( </span><span class="s2">true </span><span class="s1">).cloneNode( </span><span class="s2">true </span><span class="s1">).lastChild.checked; 
 
        </span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
        </span><span class="s0">// Make sure textarea (and checkbox) defaultValue is properly cloned</span><span class="s1"> 
        div.innerHTML = </span><span class="s3">&quot;&lt;textarea&gt;x&lt;/textarea&gt;&quot;</span><span class="s1">; 
        support.noCloneChecked = !!div.cloneNode( </span><span class="s2">true </span><span class="s1">).lastChild.defaultValue; 
    } )(); 
    </span><span class="s2">var </span><span class="s1">documentElement = document.documentElement; 
 
 
 
    </span><span class="s2">var</span><span class="s1"> 
        rkeyEvent = </span><span class="s4">/^key/</span><span class="s1">, 
        rmouseEvent = </span><span class="s4">/^(?:mouse|pointer|contextmenu|drag|drop)|click/</span><span class="s1">, 
        rtypenamespace = </span><span class="s4">/^([^.]*)(?:\.(.+)|)/</span><span class="s1">; 
 
    </span><span class="s2">function </span><span class="s1">returnTrue() { 
        </span><span class="s2">return true</span><span class="s1">; 
    } 
 
    </span><span class="s2">function </span><span class="s1">returnFalse() { 
        </span><span class="s2">return false</span><span class="s1">; 
    } 
 
</span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
</span><span class="s0">// See #13393 for more info</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">safeActiveElement() { 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">return </span><span class="s1">document.activeElement; 
        } </span><span class="s2">catch </span><span class="s1">( err ) { } 
    } 
 
    </span><span class="s2">function </span><span class="s1">on( elem, types, selector, data, fn, one ) { 
        </span><span class="s2">var </span><span class="s1">origFn, type; 
 
        </span><span class="s0">// Types can be a map of types/handlers</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">types === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
 
            </span><span class="s0">// ( types-Object, selector, data )</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
 
                </span><span class="s0">// ( types-Object, data )</span><span class="s1"> 
                data = data || selector; 
                selector = undefined; 
            } 
            </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">types ) { 
                on( elem, type, selector, data, types[ type ], one ); 
            } 
            </span><span class="s2">return </span><span class="s1">elem; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( data == </span><span class="s2">null </span><span class="s1">&amp;&amp; fn == </span><span class="s2">null </span><span class="s1">) { 
 
            </span><span class="s0">// ( types, fn )</span><span class="s1"> 
            fn = selector; 
            data = selector = undefined; 
        } </span><span class="s2">else if </span><span class="s1">( fn == </span><span class="s2">null </span><span class="s1">) { 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
 
                </span><span class="s0">// ( types, selector, fn )</span><span class="s1"> 
                fn = data; 
                data = undefined; 
            } </span><span class="s2">else </span><span class="s1">{ 
 
                </span><span class="s0">// ( types, data, fn )</span><span class="s1"> 
                fn = data; 
                data = selector; 
                selector = undefined; 
            } 
        } 
        </span><span class="s2">if </span><span class="s1">( fn === </span><span class="s2">false </span><span class="s1">) { 
            fn = returnFalse; 
        } </span><span class="s2">else if </span><span class="s1">( !fn ) { 
            </span><span class="s2">return </span><span class="s1">elem; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( one === </span><span class="s4">1 </span><span class="s1">) { 
            origFn = fn; 
            fn = </span><span class="s2">function</span><span class="s1">( event ) { 
 
                </span><span class="s0">// Can use an empty set, since event contains the info</span><span class="s1"> 
                jQuery().off( event ); 
                </span><span class="s2">return </span><span class="s1">origFn.apply( </span><span class="s2">this</span><span class="s1">, arguments ); 
            }; 
 
            </span><span class="s0">// Use same guid so caller can remove using origFn</span><span class="s1"> 
            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ ); 
        } 
        </span><span class="s2">return </span><span class="s1">elem.each( </span><span class="s2">function</span><span class="s1">() { 
            jQuery.event.add( </span><span class="s2">this</span><span class="s1">, types, fn, data, selector ); 
        } ); 
    } 
 
    </span><span class="s0">/* 
     * Helper functions for managing events -- not part of the public interface. 
     * Props to Dean Edwards' addEvent library for many of the ideas. 
     */</span><span class="s1"> 
    jQuery.event = { 
 
        global: {}, 
 
        add: </span><span class="s2">function</span><span class="s1">( elem, types, handler, data, selector ) { 
 
            </span><span class="s2">var </span><span class="s1">handleObjIn, eventHandle, tmp, 
                events, t, handleObj, 
                special, handlers, type, namespaces, origType, 
                elemData = dataPriv.get( elem ); 
 
            </span><span class="s0">// Don't attach events to noData or text/comment nodes (but allow plain objects)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !elemData ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Caller can pass in an object of custom data in lieu of the handler</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( handler.handler ) { 
                handleObjIn = handler; 
                handler = handleObjIn.handler; 
                selector = handleObjIn.selector; 
            } 
 
            </span><span class="s0">// Ensure that invalid selectors throw exceptions at attach time</span><span class="s1"> 
            </span><span class="s0">// Evaluate against documentElement in case elem is a non-element node (e.g., document)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( selector ) { 
                jQuery.find.matchesSelector( documentElement, selector ); 
            } 
 
            </span><span class="s0">// Make sure that the handler has a unique ID, used to find/remove it later</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !handler.guid ) { 
                handler.guid = jQuery.guid++; 
            } 
 
            </span><span class="s0">// Init the element's event structure and main handler, if this is the first</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !( events = elemData.events ) ) { 
                events = elemData.events = {}; 
            } 
            </span><span class="s2">if </span><span class="s1">( !( eventHandle = elemData.handle ) ) { 
                eventHandle = elemData.handle = </span><span class="s2">function</span><span class="s1">( e ) { 
 
                    </span><span class="s0">// Discard the second event of a jQuery.event.trigger() and</span><span class="s1"> 
                    </span><span class="s0">// when an event is called after a page has unloaded</span><span class="s1"> 
                    </span><span class="s2">return typeof </span><span class="s1">jQuery !== </span><span class="s3">&quot;undefined&quot; </span><span class="s1">&amp;&amp; jQuery.event.triggered !== e.type ? 
                        jQuery.event.dispatch.apply( elem, arguments ) : undefined; 
                }; 
            } 
 
            </span><span class="s0">// Handle multiple events separated by a space</span><span class="s1"> 
            types = ( types || </span><span class="s3">&quot;&quot; </span><span class="s1">).match( rnothtmlwhite ) || [ </span><span class="s3">&quot;&quot; </span><span class="s1">]; 
            t = types.length; 
            </span><span class="s2">while </span><span class="s1">( t-- ) { 
                tmp = rtypenamespace.exec( types[ t ] ) || []; 
                type = origType = tmp[ </span><span class="s4">1 </span><span class="s1">]; 
                namespaces = ( tmp[ </span><span class="s4">2 </span><span class="s1">] || </span><span class="s3">&quot;&quot; </span><span class="s1">).split( </span><span class="s3">&quot;.&quot; </span><span class="s1">).sort(); 
 
                </span><span class="s0">// There *must* be a type, no attaching namespace-only handlers</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !type ) { 
                    </span><span class="s2">continue</span><span class="s1">; 
                } 
 
                </span><span class="s0">// If event changes its type, use the special event handlers for the changed type</span><span class="s1"> 
                special = jQuery.event.special[ type ] || {}; 
 
                </span><span class="s0">// If selector defined, determine special event api type, otherwise given type</span><span class="s1"> 
                type = ( selector ? special.delegateType : special.bindType ) || type; 
 
                </span><span class="s0">// Update special based on newly reset type</span><span class="s1"> 
                special = jQuery.event.special[ type ] || {}; 
 
                </span><span class="s0">// handleObj is passed to all event handlers</span><span class="s1"> 
                handleObj = jQuery.extend( { 
                    type: type, 
                    origType: origType, 
                    data: data, 
                    handler: handler, 
                    guid: handler.guid, 
                    selector: selector, 
                    needsContext: selector &amp;&amp; jQuery.expr.match.needsContext.test( selector ), 
                    namespace: namespaces.join( </span><span class="s3">&quot;.&quot; </span><span class="s1">) 
                }, handleObjIn ); 
 
                </span><span class="s0">// Init the event handler queue if we're the first</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !( handlers = events[ type ] ) ) { 
                    handlers = events[ type ] = []; 
                    handlers.delegateCount = </span><span class="s4">0</span><span class="s1">; 
 
                    </span><span class="s0">// Only use addEventListener if the special events handler returns false</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !special.setup || 
                        special.setup.call( elem, data, namespaces, eventHandle ) === </span><span class="s2">false </span><span class="s1">) { 
 
                        </span><span class="s2">if </span><span class="s1">( elem.addEventListener ) { 
                            elem.addEventListener( type, eventHandle ); 
                        } 
                    } 
                } 
 
                </span><span class="s2">if </span><span class="s1">( special.add ) { 
                    special.add.call( elem, handleObj ); 
 
                    </span><span class="s2">if </span><span class="s1">( !handleObj.handler.guid ) { 
                        handleObj.handler.guid = handler.guid; 
                    } 
                } 
 
                </span><span class="s0">// Add to the element's handler list, delegates in front</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( selector ) { 
                    handlers.splice( handlers.delegateCount++, </span><span class="s4">0</span><span class="s1">, handleObj ); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    handlers.push( handleObj ); 
                } 
 
                </span><span class="s0">// Keep track of which events have ever been used, for event optimization</span><span class="s1"> 
                jQuery.event.global[ type ] = </span><span class="s2">true</span><span class="s1">; 
            } 
 
        }, 
 
        </span><span class="s0">// Detach an event or set of events from an element</span><span class="s1"> 
        remove: </span><span class="s2">function</span><span class="s1">( elem, types, handler, selector, mappedTypes ) { 
 
            </span><span class="s2">var </span><span class="s1">j, origCount, tmp, 
                events, t, handleObj, 
                special, handlers, type, namespaces, origType, 
                elemData = dataPriv.hasData( elem ) &amp;&amp; dataPriv.get( elem ); 
 
            </span><span class="s2">if </span><span class="s1">( !elemData || !( events = elemData.events ) ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Once for each type.namespace in types; type may be omitted</span><span class="s1"> 
            types = ( types || </span><span class="s3">&quot;&quot; </span><span class="s1">).match( rnothtmlwhite ) || [ </span><span class="s3">&quot;&quot; </span><span class="s1">]; 
            t = types.length; 
            </span><span class="s2">while </span><span class="s1">( t-- ) { 
                tmp = rtypenamespace.exec( types[ t ] ) || []; 
                type = origType = tmp[ </span><span class="s4">1 </span><span class="s1">]; 
                namespaces = ( tmp[ </span><span class="s4">2 </span><span class="s1">] || </span><span class="s3">&quot;&quot; </span><span class="s1">).split( </span><span class="s3">&quot;.&quot; </span><span class="s1">).sort(); 
 
                </span><span class="s0">// Unbind all events (on this namespace, if provided) for the element</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !type ) { 
                    </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">events ) { 
                        jQuery.event.remove( elem, type + types[ t ], handler, selector, </span><span class="s2">true </span><span class="s1">); 
                    } 
                    </span><span class="s2">continue</span><span class="s1">; 
                } 
 
                special = jQuery.event.special[ type ] || {}; 
                type = ( selector ? special.delegateType : special.bindType ) || type; 
                handlers = events[ type ] || []; 
                tmp = tmp[ </span><span class="s4">2 </span><span class="s1">] &amp;&amp; 
                    </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;(^|</span><span class="s2">\\</span><span class="s3">.)&quot; </span><span class="s1">+ namespaces.join( </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">.(?:.*</span><span class="s2">\\</span><span class="s3">.|)&quot; </span><span class="s1">) + </span><span class="s3">&quot;(</span><span class="s2">\\</span><span class="s3">.|$)&quot; </span><span class="s1">); 
 
                </span><span class="s0">// Remove matching events</span><span class="s1"> 
                origCount = j = handlers.length; 
                </span><span class="s2">while </span><span class="s1">( j-- ) { 
                    handleObj = handlers[ j ]; 
 
                    </span><span class="s2">if </span><span class="s1">( ( mappedTypes || origType === handleObj.origType ) &amp;&amp; 
                        ( !handler || handler.guid === handleObj.guid ) &amp;&amp; 
                        ( !tmp || tmp.test( handleObj.namespace ) ) &amp;&amp; 
                        ( !selector || selector === handleObj.selector || 
                        selector === </span><span class="s3">&quot;**&quot; </span><span class="s1">&amp;&amp; handleObj.selector ) ) { 
                        handlers.splice( j, </span><span class="s4">1 </span><span class="s1">); 
 
                        </span><span class="s2">if </span><span class="s1">( handleObj.selector ) { 
                            handlers.delegateCount--; 
                        } 
                        </span><span class="s2">if </span><span class="s1">( special.remove ) { 
                            special.remove.call( elem, handleObj ); 
                        } 
                    } 
                } 
 
                </span><span class="s0">// Remove generic event handler if we removed something and no more handlers exist</span><span class="s1"> 
                </span><span class="s0">// (avoids potential for endless recursion during removal of special event handlers)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( origCount &amp;&amp; !handlers.length ) { 
                    </span><span class="s2">if </span><span class="s1">( !special.teardown || 
                        special.teardown.call( elem, namespaces, elemData.handle ) === </span><span class="s2">false </span><span class="s1">) { 
 
                        jQuery.removeEvent( elem, type, elemData.handle ); 
                    } 
 
                    </span><span class="s2">delete </span><span class="s1">events[ type ]; 
                } 
            } 
 
            </span><span class="s0">// Remove data and the expando if it's no longer used</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jQuery.isEmptyObject( events ) ) { 
                dataPriv.remove( elem, </span><span class="s3">&quot;handle events&quot; </span><span class="s1">); 
            } 
        }, 
 
        dispatch: </span><span class="s2">function</span><span class="s1">( nativeEvent ) { 
 
            </span><span class="s0">// Make a writable jQuery.Event from the native event object</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">event = jQuery.event.fix( nativeEvent ); 
 
            </span><span class="s2">var </span><span class="s1">i, j, ret, matched, handleObj, handlerQueue, 
                args = </span><span class="s2">new </span><span class="s1">Array( arguments.length ), 
                handlers = ( dataPriv.get( </span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;events&quot; </span><span class="s1">) || {} )[ event.type ] || [], 
                special = jQuery.event.special[ event.type ] || {}; 
 
            </span><span class="s0">// Use the fix-ed jQuery.Event rather than the (read-only) native event</span><span class="s1"> 
            args[ </span><span class="s4">0 </span><span class="s1">] = event; 
 
            </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">1</span><span class="s1">; i &lt; arguments.length; i++ ) { 
                args[ i ] = arguments[ i ]; 
            } 
 
            event.delegateTarget = </span><span class="s2">this</span><span class="s1">; 
 
            </span><span class="s0">// Call the preDispatch hook for the mapped type, and let it bail if desired</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( special.preDispatch &amp;&amp; special.preDispatch.call( </span><span class="s2">this</span><span class="s1">, event ) === </span><span class="s2">false </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Determine handlers</span><span class="s1"> 
            handlerQueue = jQuery.event.handlers.call( </span><span class="s2">this</span><span class="s1">, event, handlers ); 
 
            </span><span class="s0">// Run delegates first; they may want to stop propagation beneath us</span><span class="s1"> 
            i = </span><span class="s4">0</span><span class="s1">; 
            </span><span class="s2">while </span><span class="s1">( ( matched = handlerQueue[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) { 
                event.currentTarget = matched.elem; 
 
                j = </span><span class="s4">0</span><span class="s1">; 
                </span><span class="s2">while </span><span class="s1">( ( handleObj = matched.handlers[ j++ ] ) &amp;&amp; 
                !event.isImmediatePropagationStopped() ) { 
 
                    </span><span class="s0">// Triggered event must either 1) have no namespace, or 2) have namespace(s)</span><span class="s1"> 
                    </span><span class="s0">// a subset or equal to those in the bound event (both can have no namespace).</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) { 
 
                        event.handleObj = handleObj; 
                        event.data = handleObj.data; 
 
                        ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle || 
                        handleObj.handler ).apply( matched.elem, args ); 
 
                        </span><span class="s2">if </span><span class="s1">( ret !== undefined ) { 
                            </span><span class="s2">if </span><span class="s1">( ( event.result = ret ) === </span><span class="s2">false </span><span class="s1">) { 
                                event.preventDefault(); 
                                event.stopPropagation(); 
                            } 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s0">// Call the postDispatch hook for the mapped type</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( special.postDispatch ) { 
                special.postDispatch.call( </span><span class="s2">this</span><span class="s1">, event ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">event.result; 
        }, 
 
        handlers: </span><span class="s2">function</span><span class="s1">( event, handlers ) { 
            </span><span class="s2">var </span><span class="s1">i, handleObj, sel, matchedHandlers, matchedSelectors, 
                handlerQueue = [], 
                delegateCount = handlers.delegateCount, 
                cur = event.target; 
 
            </span><span class="s0">// Find delegate handlers</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( delegateCount &amp;&amp; 
 
                    </span><span class="s0">// Support: IE &lt;=9</span><span class="s1"> 
                    </span><span class="s0">// Black-hole SVG &lt;use&gt; instance trees (trac-13180)</span><span class="s1"> 
                cur.nodeType &amp;&amp; 
 
                    </span><span class="s0">// Support: Firefox &lt;=42</span><span class="s1"> 
                    </span><span class="s0">// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)</span><span class="s1"> 
                    </span><span class="s0">// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click</span><span class="s1"> 
                    </span><span class="s0">// Support: IE 11 only</span><span class="s1"> 
                    </span><span class="s0">// ...but not arrow key &quot;clicks&quot; of radio inputs, which can have `button` -1 (gh-2343)</span><span class="s1"> 
                !( event.type === </span><span class="s3">&quot;click&quot; </span><span class="s1">&amp;&amp; event.button &gt;= </span><span class="s4">1 </span><span class="s1">) ) { 
 
                </span><span class="s2">for </span><span class="s1">( ; cur !== </span><span class="s2">this</span><span class="s1">; cur = cur.parentNode || </span><span class="s2">this </span><span class="s1">) { 
 
                    </span><span class="s0">// Don't check non-elements (#13208)</span><span class="s1"> 
                    </span><span class="s0">// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( cur.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; !( event.type === </span><span class="s3">&quot;click&quot; </span><span class="s1">&amp;&amp; cur.disabled === </span><span class="s2">true </span><span class="s1">) ) { 
                        matchedHandlers = []; 
                        matchedSelectors = {}; 
                        </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">; i &lt; delegateCount; i++ ) { 
                            handleObj = handlers[ i ]; 
 
                            </span><span class="s0">// Don't conflict with Object.prototype properties (#13203)</span><span class="s1"> 
                            sel = handleObj.selector + </span><span class="s3">&quot; &quot;</span><span class="s1">; 
 
                            </span><span class="s2">if </span><span class="s1">( matchedSelectors[ sel ] === undefined ) { 
                                matchedSelectors[ sel ] = handleObj.needsContext ? 
                                jQuery( sel, </span><span class="s2">this </span><span class="s1">).index( cur ) &gt; -</span><span class="s4">1 </span><span class="s1">: 
                                    jQuery.find( sel, </span><span class="s2">this</span><span class="s1">, </span><span class="s2">null</span><span class="s1">, [ cur ] ).length; 
                            } 
                            </span><span class="s2">if </span><span class="s1">( matchedSelectors[ sel ] ) { 
                                matchedHandlers.push( handleObj ); 
                            } 
                        } 
                        </span><span class="s2">if </span><span class="s1">( matchedHandlers.length ) { 
                            handlerQueue.push( { elem: cur, handlers: matchedHandlers } ); 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s0">// Add the remaining (directly-bound) handlers</span><span class="s1"> 
            cur = </span><span class="s2">this</span><span class="s1">; 
            </span><span class="s2">if </span><span class="s1">( delegateCount &lt; handlers.length ) { 
                handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } ); 
            } 
 
            </span><span class="s2">return </span><span class="s1">handlerQueue; 
        }, 
 
        addProp: </span><span class="s2">function</span><span class="s1">( name, hook ) { 
            Object.defineProperty( jQuery.Event.prototype, name, { 
                enumerable: </span><span class="s2">true</span><span class="s1">, 
                configurable: </span><span class="s2">true</span><span class="s1">, 
 
                </span><span class="s2">get</span><span class="s1">: jQuery.isFunction( hook ) ? 
                    </span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.originalEvent ) { 
                            </span><span class="s2">return </span><span class="s1">hook( </span><span class="s2">this</span><span class="s1">.originalEvent ); 
                        } 
                    } : 
                    </span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.originalEvent ) { 
                            </span><span class="s2">return this</span><span class="s1">.originalEvent[ name ]; 
                        } 
                    }, 
 
                </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( value ) { 
                    Object.defineProperty( </span><span class="s2">this</span><span class="s1">, name, { 
                        enumerable: </span><span class="s2">true</span><span class="s1">, 
                        configurable: </span><span class="s2">true</span><span class="s1">, 
                        writable: </span><span class="s2">true</span><span class="s1">, 
                        value: value 
                    } ); 
                } 
            } ); 
        }, 
 
        fix: </span><span class="s2">function</span><span class="s1">( originalEvent ) { 
            </span><span class="s2">return </span><span class="s1">originalEvent[ jQuery.expando ] ? 
                originalEvent : 
                </span><span class="s2">new </span><span class="s1">jQuery.Event( originalEvent ); 
        }, 
 
        special: { 
            load: { 
 
                </span><span class="s0">// Prevent triggered image.load events from bubbling to window.load</span><span class="s1"> 
                noBubble: </span><span class="s2">true</span><span class="s1"> 
            }, 
            focus: { 
 
                </span><span class="s0">// Fire native event if possible so blur/focus sequence is correct</span><span class="s1"> 
                trigger: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this </span><span class="s1">!== safeActiveElement() &amp;&amp; </span><span class="s2">this</span><span class="s1">.focus ) { 
                        </span><span class="s2">this</span><span class="s1">.focus(); 
                        </span><span class="s2">return false</span><span class="s1">; 
                    } 
                }, 
                delegateType: </span><span class="s3">&quot;focusin&quot;</span><span class="s1"> 
            }, 
            blur: { 
                trigger: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this </span><span class="s1">=== safeActiveElement() &amp;&amp; </span><span class="s2">this</span><span class="s1">.blur ) { 
                        </span><span class="s2">this</span><span class="s1">.blur(); 
                        </span><span class="s2">return false</span><span class="s1">; 
                    } 
                }, 
                delegateType: </span><span class="s3">&quot;focusout&quot;</span><span class="s1"> 
            }, 
            click: { 
 
                </span><span class="s0">// For checkbox, fire native event so checked state will be right</span><span class="s1"> 
                trigger: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.type === </span><span class="s3">&quot;checkbox&quot; </span><span class="s1">&amp;&amp; </span><span class="s2">this</span><span class="s1">.click &amp;&amp; jQuery.nodeName( </span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;input&quot; </span><span class="s1">) ) { 
                        </span><span class="s2">this</span><span class="s1">.click(); 
                        </span><span class="s2">return false</span><span class="s1">; 
                    } 
                }, 
 
                </span><span class="s0">// For cross-browser consistency, don't fire native .click() on links</span><span class="s1"> 
                _default: </span><span class="s2">function</span><span class="s1">( event ) { 
                    </span><span class="s2">return </span><span class="s1">jQuery.nodeName( event.target, </span><span class="s3">&quot;a&quot; </span><span class="s1">); 
                } 
            }, 
 
            beforeunload: { 
                postDispatch: </span><span class="s2">function</span><span class="s1">( event ) { 
 
                    </span><span class="s0">// Support: Firefox 20+</span><span class="s1"> 
                    </span><span class="s0">// Firefox doesn't alert if the returnValue field is not set.</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( event.result !== undefined &amp;&amp; event.originalEvent ) { 
                        event.originalEvent.returnValue = event.result; 
                    } 
                } 
            } 
        } 
    }; 
 
    jQuery.removeEvent = </span><span class="s2">function</span><span class="s1">( elem, type, handle ) { 
 
        </span><span class="s0">// This &quot;if&quot; is needed for plain objects</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( elem.removeEventListener ) { 
            elem.removeEventListener( type, handle ); 
        } 
    }; 
 
    jQuery.Event = </span><span class="s2">function</span><span class="s1">( src, props ) { 
 
        </span><span class="s0">// Allow instantiation without the 'new' keyword</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !( </span><span class="s2">this instanceof </span><span class="s1">jQuery.Event ) ) { 
            </span><span class="s2">return new </span><span class="s1">jQuery.Event( src, props ); 
        } 
 
        </span><span class="s0">// Event object</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( src &amp;&amp; src.type ) { 
            </span><span class="s2">this</span><span class="s1">.originalEvent = src; 
            </span><span class="s2">this</span><span class="s1">.type = src.type; 
 
            </span><span class="s0">// Events bubbling up the document may have been marked as prevented</span><span class="s1"> 
            </span><span class="s0">// by a handler lower down the tree; reflect the correct value.</span><span class="s1"> 
            </span><span class="s2">this</span><span class="s1">.isDefaultPrevented = src.defaultPrevented || 
            src.defaultPrevented === undefined &amp;&amp; 
 
                </span><span class="s0">// Support: Android &lt;=2.3 only</span><span class="s1"> 
            src.returnValue === </span><span class="s2">false </span><span class="s1">? 
                returnTrue : 
                returnFalse; 
 
            </span><span class="s0">// Create target properties</span><span class="s1"> 
            </span><span class="s0">// Support: Safari &lt;=6 - 7 only</span><span class="s1"> 
            </span><span class="s0">// Target should not be a text node (#504, #13143)</span><span class="s1"> 
            </span><span class="s2">this</span><span class="s1">.target = ( src.target &amp;&amp; src.target.nodeType === </span><span class="s4">3 </span><span class="s1">) ? 
                src.target.parentNode : 
                src.target; 
 
            </span><span class="s2">this</span><span class="s1">.currentTarget = src.currentTarget; 
            </span><span class="s2">this</span><span class="s1">.relatedTarget = src.relatedTarget; 
 
            </span><span class="s0">// Event type</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">this</span><span class="s1">.type = src; 
        } 
 
        </span><span class="s0">// Put explicitly provided properties onto the event object</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( props ) { 
            jQuery.extend( </span><span class="s2">this</span><span class="s1">, props ); 
        } 
 
        </span><span class="s0">// Create a timestamp if incoming event doesn't have one</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">.timeStamp = src &amp;&amp; src.timeStamp || jQuery.now(); 
 
        </span><span class="s0">// Mark it as fixed</span><span class="s1"> 
        </span><span class="s2">this</span><span class="s1">[ jQuery.expando ] = </span><span class="s2">true</span><span class="s1">; 
    }; 
 
</span><span class="s0">// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding</span><span class="s1"> 
</span><span class="s0">// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html</span><span class="s1"> 
    jQuery.Event.prototype = { 
        constructor: jQuery.Event, 
        isDefaultPrevented: returnFalse, 
        isPropagationStopped: returnFalse, 
        isImmediatePropagationStopped: returnFalse, 
        isSimulated: </span><span class="s2">false</span><span class="s1">, 
 
        preventDefault: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">e = </span><span class="s2">this</span><span class="s1">.originalEvent; 
 
            </span><span class="s2">this</span><span class="s1">.isDefaultPrevented = returnTrue; 
 
            </span><span class="s2">if </span><span class="s1">( e &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isSimulated ) { 
                e.preventDefault(); 
            } 
        }, 
        stopPropagation: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">e = </span><span class="s2">this</span><span class="s1">.originalEvent; 
 
            </span><span class="s2">this</span><span class="s1">.isPropagationStopped = returnTrue; 
 
            </span><span class="s2">if </span><span class="s1">( e &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isSimulated ) { 
                e.stopPropagation(); 
            } 
        }, 
        stopImmediatePropagation: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">e = </span><span class="s2">this</span><span class="s1">.originalEvent; 
 
            </span><span class="s2">this</span><span class="s1">.isImmediatePropagationStopped = returnTrue; 
 
            </span><span class="s2">if </span><span class="s1">( e &amp;&amp; !</span><span class="s2">this</span><span class="s1">.isSimulated ) { 
                e.stopImmediatePropagation(); 
            } 
 
            </span><span class="s2">this</span><span class="s1">.stopPropagation(); 
        } 
    }; 
 
</span><span class="s0">// Includes all common event props including KeyEvent and MouseEvent specific props</span><span class="s1"> 
    jQuery.each( { 
        altKey: </span><span class="s2">true</span><span class="s1">, 
        bubbles: </span><span class="s2">true</span><span class="s1">, 
        cancelable: </span><span class="s2">true</span><span class="s1">, 
        changedTouches: </span><span class="s2">true</span><span class="s1">, 
        ctrlKey: </span><span class="s2">true</span><span class="s1">, 
        detail: </span><span class="s2">true</span><span class="s1">, 
        eventPhase: </span><span class="s2">true</span><span class="s1">, 
        metaKey: </span><span class="s2">true</span><span class="s1">, 
        pageX: </span><span class="s2">true</span><span class="s1">, 
        pageY: </span><span class="s2">true</span><span class="s1">, 
        shiftKey: </span><span class="s2">true</span><span class="s1">, 
        view: </span><span class="s2">true</span><span class="s1">, 
        </span><span class="s3">&quot;char&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
        charCode: </span><span class="s2">true</span><span class="s1">, 
        key: </span><span class="s2">true</span><span class="s1">, 
        keyCode: </span><span class="s2">true</span><span class="s1">, 
        button: </span><span class="s2">true</span><span class="s1">, 
        buttons: </span><span class="s2">true</span><span class="s1">, 
        clientX: </span><span class="s2">true</span><span class="s1">, 
        clientY: </span><span class="s2">true</span><span class="s1">, 
        offsetX: </span><span class="s2">true</span><span class="s1">, 
        offsetY: </span><span class="s2">true</span><span class="s1">, 
        pointerId: </span><span class="s2">true</span><span class="s1">, 
        pointerType: </span><span class="s2">true</span><span class="s1">, 
        screenX: </span><span class="s2">true</span><span class="s1">, 
        screenY: </span><span class="s2">true</span><span class="s1">, 
        targetTouches: </span><span class="s2">true</span><span class="s1">, 
        toElement: </span><span class="s2">true</span><span class="s1">, 
        touches: </span><span class="s2">true</span><span class="s1">, 
 
        which: </span><span class="s2">function</span><span class="s1">( event ) { 
            </span><span class="s2">var </span><span class="s1">button = event.button; 
 
            </span><span class="s0">// Add which for key events</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( event.which == </span><span class="s2">null </span><span class="s1">&amp;&amp; rkeyEvent.test( event.type ) ) { 
                </span><span class="s2">return </span><span class="s1">event.charCode != </span><span class="s2">null </span><span class="s1">? event.charCode : event.keyCode; 
            } 
 
            </span><span class="s0">// Add which for click: 1 === left; 2 === middle; 3 === right</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !event.which &amp;&amp; button !== undefined &amp;&amp; rmouseEvent.test( event.type ) ) { 
                </span><span class="s2">if </span><span class="s1">( button &amp; </span><span class="s4">1 </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s4">1</span><span class="s1">; 
                } 
 
                </span><span class="s2">if </span><span class="s1">( button &amp; </span><span class="s4">2 </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s4">3</span><span class="s1">; 
                } 
 
                </span><span class="s2">if </span><span class="s1">( button &amp; </span><span class="s4">4 </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s4">2</span><span class="s1">; 
                } 
 
                </span><span class="s2">return </span><span class="s4">0</span><span class="s1">; 
            } 
 
            </span><span class="s2">return </span><span class="s1">event.which; 
        } 
    }, jQuery.event.addProp ); 
 
</span><span class="s0">// Create mouseenter/leave events using mouseover/out and event-time checks</span><span class="s1"> 
</span><span class="s0">// so that event delegation works in jQuery.</span><span class="s1"> 
</span><span class="s0">// Do the same for pointerenter/pointerleave and pointerover/pointerout</span><span class="s1"> 
</span><span class="s0">//</span><span class="s1"> 
</span><span class="s0">// Support: Safari 7 only</span><span class="s1"> 
</span><span class="s0">// Safari sends mouseenter too often; see:</span><span class="s1"> 
</span><span class="s0">// https://bugs.chromium.org/p/chromium/issues/detail?id=470258</span><span class="s1"> 
</span><span class="s0">// for the description of the bug (it existed in older Chrome versions as well).</span><span class="s1"> 
    jQuery.each( { 
        mouseenter: </span><span class="s3">&quot;mouseover&quot;</span><span class="s1">, 
        mouseleave: </span><span class="s3">&quot;mouseout&quot;</span><span class="s1">, 
        pointerenter: </span><span class="s3">&quot;pointerover&quot;</span><span class="s1">, 
        pointerleave: </span><span class="s3">&quot;pointerout&quot;</span><span class="s1"> 
    }, </span><span class="s2">function</span><span class="s1">( orig, fix ) { 
        jQuery.event.special[ orig ] = { 
            delegateType: fix, 
            bindType: fix, 
 
            handle: </span><span class="s2">function</span><span class="s1">( event ) { 
                </span><span class="s2">var </span><span class="s1">ret, 
                    target = </span><span class="s2">this</span><span class="s1">, 
                    related = event.relatedTarget, 
                    handleObj = event.handleObj; 
 
                </span><span class="s0">// For mouseenter/leave call the handler if related is outside the target.</span><span class="s1"> 
                </span><span class="s0">// NB: No relatedTarget if the mouse left/entered the browser window</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !related || ( related !== target &amp;&amp; !jQuery.contains( target, related ) ) ) { 
                    event.type = handleObj.origType; 
                    ret = handleObj.handler.apply( </span><span class="s2">this</span><span class="s1">, arguments ); 
                    event.type = fix; 
                } 
                </span><span class="s2">return </span><span class="s1">ret; 
            } 
        }; 
    } ); 
 
    jQuery.fn.extend( { 
 
        on: </span><span class="s2">function</span><span class="s1">( types, selector, data, fn ) { 
            </span><span class="s2">return </span><span class="s1">on( </span><span class="s2">this</span><span class="s1">, types, selector, data, fn ); 
        }, 
        one: </span><span class="s2">function</span><span class="s1">( types, selector, data, fn ) { 
            </span><span class="s2">return </span><span class="s1">on( </span><span class="s2">this</span><span class="s1">, types, selector, data, fn, </span><span class="s4">1 </span><span class="s1">); 
        }, 
        off: </span><span class="s2">function</span><span class="s1">( types, selector, fn ) { 
            </span><span class="s2">var </span><span class="s1">handleObj, type; 
            </span><span class="s2">if </span><span class="s1">( types &amp;&amp; types.preventDefault &amp;&amp; types.handleObj ) { 
 
                </span><span class="s0">// ( event )  dispatched jQuery.Event</span><span class="s1"> 
                handleObj = types.handleObj; 
                jQuery( types.delegateTarget ).off( 
                    handleObj.namespace ? 
                    handleObj.origType + </span><span class="s3">&quot;.&quot; </span><span class="s1">+ handleObj.namespace : 
                        handleObj.origType, 
                    handleObj.selector, 
                    handleObj.handler 
                ); 
                </span><span class="s2">return this</span><span class="s1">; 
            } 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">types === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
 
                </span><span class="s0">// ( types-object [, selector] )</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">types ) { 
                    </span><span class="s2">this</span><span class="s1">.off( type, selector, types[ type ] ); 
                } 
                </span><span class="s2">return this</span><span class="s1">; 
            } 
            </span><span class="s2">if </span><span class="s1">( selector === </span><span class="s2">false </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">selector === </span><span class="s3">&quot;function&quot; </span><span class="s1">) { 
 
                </span><span class="s0">// ( types [, fn] )</span><span class="s1"> 
                fn = selector; 
                selector = undefined; 
            } 
            </span><span class="s2">if </span><span class="s1">( fn === </span><span class="s2">false </span><span class="s1">) { 
                fn = returnFalse; 
            } 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                jQuery.event.remove( </span><span class="s2">this</span><span class="s1">, types, fn, selector ); 
            } ); 
        } 
    } ); 
 
 
    </span><span class="s2">var</span><span class="s1"> 
 
    </span><span class="s0">/* eslint-disable max-len */</span><span class="s1"> 
 
    </span><span class="s0">// See https://github.com/eslint/eslint/issues/3229</span><span class="s1"> 
        rxhtmlTag = </span><span class="s4">/&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0&gt;\x20\t\r\n\f]*)[^&gt;]*)\/&gt;/gi</span><span class="s1">, 
 
    </span><span class="s0">/* eslint-enable */</span><span class="s1"> 
 
    </span><span class="s0">// Support: IE &lt;=10 - 11, Edge 12 - 13</span><span class="s1"> 
    </span><span class="s0">// In IE/Edge using regex groups here causes severe slowdowns.</span><span class="s1"> 
    </span><span class="s0">// See https://connect.microsoft.com/IE/feedback/details/1736512/</span><span class="s1"> 
        rnoInnerhtml = </span><span class="s4">/&lt;script|&lt;style|&lt;link/i</span><span class="s1">, 
 
    </span><span class="s0">// checked=&quot;checked&quot; or checked</span><span class="s1"> 
        rchecked = </span><span class="s4">/checked\s*(?:[^=]|=\s*.checked.)/i</span><span class="s1">, 
        rscriptTypeMasked = </span><span class="s4">/^true\/(.*)/</span><span class="s1">, 
        rcleanScript = </span><span class="s4">/^\s*&lt;!(?:\[CDATA\[|--)|(?:\]\]|--)&gt;\s*$/g</span><span class="s1">; 
 
    </span><span class="s2">function </span><span class="s1">manipulationTarget( elem, content ) { 
        </span><span class="s2">if </span><span class="s1">( jQuery.nodeName( elem, </span><span class="s3">&quot;table&quot; </span><span class="s1">) &amp;&amp; 
            jQuery.nodeName( content.nodeType !== </span><span class="s4">11 </span><span class="s1">? content : content.firstChild, </span><span class="s3">&quot;tr&quot; </span><span class="s1">) ) { 
 
            </span><span class="s2">return </span><span class="s1">elem.getElementsByTagName( </span><span class="s3">&quot;tbody&quot; </span><span class="s1">)[ </span><span class="s4">0 </span><span class="s1">] || elem; 
        } 
 
        </span><span class="s2">return </span><span class="s1">elem; 
    } 
 
</span><span class="s0">// Replace/restore the type attribute of script elements for safe DOM manipulation</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">disableScript( elem ) { 
        elem.type = ( elem.getAttribute( </span><span class="s3">&quot;type&quot; </span><span class="s1">) !== </span><span class="s2">null </span><span class="s1">) + </span><span class="s3">&quot;/&quot; </span><span class="s1">+ elem.type; 
        </span><span class="s2">return </span><span class="s1">elem; 
    } 
    </span><span class="s2">function </span><span class="s1">restoreScript( elem ) { 
        </span><span class="s2">var </span><span class="s1">match = rscriptTypeMasked.exec( elem.type ); 
 
        </span><span class="s2">if </span><span class="s1">( match ) { 
            elem.type = match[ </span><span class="s4">1 </span><span class="s1">]; 
        } </span><span class="s2">else </span><span class="s1">{ 
            elem.removeAttribute( </span><span class="s3">&quot;type&quot; </span><span class="s1">); 
        } 
 
        </span><span class="s2">return </span><span class="s1">elem; 
    } 
 
    </span><span class="s2">function </span><span class="s1">cloneCopyEvent( src, dest ) { 
        </span><span class="s2">var </span><span class="s1">i, l, type, pdataOld, pdataCur, udataOld, udataCur, events; 
 
        </span><span class="s2">if </span><span class="s1">( dest.nodeType !== </span><span class="s4">1 </span><span class="s1">) { 
            </span><span class="s2">return</span><span class="s1">; 
        } 
 
        </span><span class="s0">// 1. Copy private data: events, handlers, etc.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( dataPriv.hasData( src ) ) { 
            pdataOld = dataPriv.access( src ); 
            pdataCur = dataPriv.set( dest, pdataOld ); 
            events = pdataOld.events; 
 
            </span><span class="s2">if </span><span class="s1">( events ) { 
                </span><span class="s2">delete </span><span class="s1">pdataCur.handle; 
                pdataCur.events = {}; 
 
                </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">events ) { 
                    </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">, l = events[ type ].length; i &lt; l; i++ ) { 
                        jQuery.event.add( dest, type, events[ type ][ i ] ); 
                    } 
                } 
            } 
        } 
 
        </span><span class="s0">// 2. Copy user data</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( dataUser.hasData( src ) ) { 
            udataOld = dataUser.access( src ); 
            udataCur = jQuery.extend( {}, udataOld ); 
 
            dataUser.set( dest, udataCur ); 
        } 
    } 
 
</span><span class="s0">// Fix IE bugs, see support tests</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">fixInput( src, dest ) { 
        </span><span class="s2">var </span><span class="s1">nodeName = dest.nodeName.toLowerCase(); 
 
        </span><span class="s0">// Fails to persist the checked state of a cloned checkbox or radio button.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( nodeName === </span><span class="s3">&quot;input&quot; </span><span class="s1">&amp;&amp; rcheckableType.test( src.type ) ) { 
            dest.checked = src.checked; 
 
            </span><span class="s0">// Fails to return the selected option to the default selected state when cloning options</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( nodeName === </span><span class="s3">&quot;input&quot; </span><span class="s1">|| nodeName === </span><span class="s3">&quot;textarea&quot; </span><span class="s1">) { 
            dest.defaultValue = src.defaultValue; 
        } 
    } 
 
    </span><span class="s2">function </span><span class="s1">domManip( collection, args, callback, ignored ) { 
 
        </span><span class="s0">// Flatten any nested arrays</span><span class="s1"> 
        args = concat.apply( [], args ); 
 
        </span><span class="s2">var </span><span class="s1">fragment, first, scripts, hasScripts, node, doc, 
            i = </span><span class="s4">0</span><span class="s1">, 
            l = collection.length, 
            iNoClone = l - </span><span class="s4">1</span><span class="s1">, 
            value = args[ </span><span class="s4">0 </span><span class="s1">], 
            isFunction = jQuery.isFunction( value ); 
 
        </span><span class="s0">// We can't cloneNode fragments that contain checked, in WebKit</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( isFunction || 
            ( l &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; 
            !support.checkClone &amp;&amp; rchecked.test( value ) ) ) { 
            </span><span class="s2">return </span><span class="s1">collection.each( </span><span class="s2">function</span><span class="s1">( index ) { 
                </span><span class="s2">var </span><span class="s1">self = collection.eq( index ); 
                </span><span class="s2">if </span><span class="s1">( isFunction ) { 
                    args[ </span><span class="s4">0 </span><span class="s1">] = value.call( </span><span class="s2">this</span><span class="s1">, index, self.html() ); 
                } 
                domManip( self, args, callback, ignored ); 
            } ); 
        } 
 
        </span><span class="s2">if </span><span class="s1">( l ) { 
            fragment = buildFragment( args, collection[ </span><span class="s4">0 </span><span class="s1">].ownerDocument, </span><span class="s2">false</span><span class="s1">, collection, ignored ); 
            first = fragment.firstChild; 
 
            </span><span class="s2">if </span><span class="s1">( fragment.childNodes.length === </span><span class="s4">1 </span><span class="s1">) { 
                fragment = first; 
            } 
 
            </span><span class="s0">// Require either new content or an interest in ignored elements to invoke the callback</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( first || ignored ) { 
                scripts = jQuery.map( getAll( fragment, </span><span class="s3">&quot;script&quot; </span><span class="s1">), disableScript ); 
                hasScripts = scripts.length; 
 
                </span><span class="s0">// Use the original fragment for the last item</span><span class="s1"> 
                </span><span class="s0">// instead of the first because it can end up</span><span class="s1"> 
                </span><span class="s0">// being emptied incorrectly in certain situations (#8070).</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; l; i++ ) { 
                    node = fragment; 
 
                    </span><span class="s2">if </span><span class="s1">( i !== iNoClone ) { 
                        node = jQuery.clone( node, </span><span class="s2">true</span><span class="s1">, </span><span class="s2">true </span><span class="s1">); 
 
                        </span><span class="s0">// Keep references to cloned scripts for later restoration</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( hasScripts ) { 
 
                            </span><span class="s0">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span><span class="s1"> 
                            </span><span class="s0">// push.apply(_, arraylike) throws on ancient WebKit</span><span class="s1"> 
                            jQuery.merge( scripts, getAll( node, </span><span class="s3">&quot;script&quot; </span><span class="s1">) ); 
                        } 
                    } 
 
                    callback.call( collection[ i ], node, i ); 
                } 
 
                </span><span class="s2">if </span><span class="s1">( hasScripts ) { 
                    doc = scripts[ scripts.length - </span><span class="s4">1 </span><span class="s1">].ownerDocument; 
 
                    </span><span class="s0">// Reenable scripts</span><span class="s1"> 
                    jQuery.map( scripts, restoreScript ); 
 
                    </span><span class="s0">// Evaluate executable scripts on first document insertion</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">; i &lt; hasScripts; i++ ) { 
                        node = scripts[ i ]; 
                        </span><span class="s2">if </span><span class="s1">( rscriptType.test( node.type || </span><span class="s3">&quot;&quot; </span><span class="s1">) &amp;&amp; 
                            !dataPriv.access( node, </span><span class="s3">&quot;globalEval&quot; </span><span class="s1">) &amp;&amp; 
                            jQuery.contains( doc, node ) ) { 
 
                            </span><span class="s2">if </span><span class="s1">( node.src ) { 
 
                                </span><span class="s0">// Optional AJAX dependency, but won't run scripts if not present</span><span class="s1"> 
                                </span><span class="s2">if </span><span class="s1">( jQuery._evalUrl ) { 
                                    jQuery._evalUrl( node.src ); 
                                } 
                            } </span><span class="s2">else </span><span class="s1">{ 
                                DOMEval( node.textContent.replace( rcleanScript, </span><span class="s3">&quot;&quot; </span><span class="s1">), doc ); 
                            } 
                        } 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">collection; 
    } 
 
    </span><span class="s2">function </span><span class="s1">remove( elem, selector, keepData ) { 
        </span><span class="s2">var </span><span class="s1">node, 
            nodes = selector ? jQuery.filter( selector, elem ) : elem, 
            i = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s2">for </span><span class="s1">( ; ( node = nodes[ i ] ) != </span><span class="s2">null</span><span class="s1">; i++ ) { 
            </span><span class="s2">if </span><span class="s1">( !keepData &amp;&amp; node.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
                jQuery.cleanData( getAll( node ) ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( node.parentNode ) { 
                </span><span class="s2">if </span><span class="s1">( keepData &amp;&amp; jQuery.contains( node.ownerDocument, node ) ) { 
                    setGlobalEval( getAll( node, </span><span class="s3">&quot;script&quot; </span><span class="s1">) ); 
                } 
                node.parentNode.removeChild( node ); 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">elem; 
    } 
 
    jQuery.extend( { 
        htmlPrefilter: </span><span class="s2">function</span><span class="s1">( html ) { 
            </span><span class="s2">return </span><span class="s1">html.replace( rxhtmlTag, </span><span class="s3">&quot;&lt;$1&gt;&lt;/$2&gt;&quot; </span><span class="s1">); 
        }, 
 
        clone: </span><span class="s2">function</span><span class="s1">( elem, dataAndEvents, deepDataAndEvents ) { 
            </span><span class="s2">var </span><span class="s1">i, l, srcElements, destElements, 
                clone = elem.cloneNode( </span><span class="s2">true </span><span class="s1">), 
                inPage = jQuery.contains( elem.ownerDocument, elem ); 
 
            </span><span class="s0">// Fix IE cloning issues</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !support.noCloneChecked &amp;&amp; ( elem.nodeType === </span><span class="s4">1 </span><span class="s1">|| elem.nodeType === </span><span class="s4">11 </span><span class="s1">) &amp;&amp; 
                !jQuery.isXMLDoc( elem ) ) { 
 
                </span><span class="s0">// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2</span><span class="s1"> 
                destElements = getAll( clone ); 
                srcElements = getAll( elem ); 
 
                </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">, l = srcElements.length; i &lt; l; i++ ) { 
                    fixInput( srcElements[ i ], destElements[ i ] ); 
                } 
            } 
 
            </span><span class="s0">// Copy the events from the original to the clone</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( dataAndEvents ) { 
                </span><span class="s2">if </span><span class="s1">( deepDataAndEvents ) { 
                    srcElements = srcElements || getAll( elem ); 
                    destElements = destElements || getAll( clone ); 
 
                    </span><span class="s2">for </span><span class="s1">( i = </span><span class="s4">0</span><span class="s1">, l = srcElements.length; i &lt; l; i++ ) { 
                        cloneCopyEvent( srcElements[ i ], destElements[ i ] ); 
                    } 
                } </span><span class="s2">else </span><span class="s1">{ 
                    cloneCopyEvent( elem, clone ); 
                } 
            } 
 
            </span><span class="s0">// Preserve script evaluation history</span><span class="s1"> 
            destElements = getAll( clone, </span><span class="s3">&quot;script&quot; </span><span class="s1">); 
            </span><span class="s2">if </span><span class="s1">( destElements.length &gt; </span><span class="s4">0 </span><span class="s1">) { 
                setGlobalEval( destElements, !inPage &amp;&amp; getAll( elem, </span><span class="s3">&quot;script&quot; </span><span class="s1">) ); 
            } 
 
            </span><span class="s0">// Return the cloned set</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">clone; 
        }, 
 
        cleanData: </span><span class="s2">function</span><span class="s1">( elems ) { 
            </span><span class="s2">var </span><span class="s1">data, elem, type, 
                special = jQuery.event.special, 
                i = </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s2">for </span><span class="s1">( ; ( elem = elems[ i ] ) !== undefined; i++ ) { 
                </span><span class="s2">if </span><span class="s1">( acceptData( elem ) ) { 
                    </span><span class="s2">if </span><span class="s1">( ( data = elem[ dataPriv.expando ] ) ) { 
                        </span><span class="s2">if </span><span class="s1">( data.events ) { 
                            </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">data.events ) { 
                                </span><span class="s2">if </span><span class="s1">( special[ type ] ) { 
                                    jQuery.event.remove( elem, type ); 
 
                                    </span><span class="s0">// This is a shortcut to avoid jQuery.event.remove's overhead</span><span class="s1"> 
                                } </span><span class="s2">else </span><span class="s1">{ 
                                    jQuery.removeEvent( elem, type, data.handle ); 
                                } 
                            } 
                        } 
 
                        </span><span class="s0">// Support: Chrome &lt;=35 - 45+</span><span class="s1"> 
                        </span><span class="s0">// Assign undefined instead of using delete, see Data#remove</span><span class="s1"> 
                        elem[ dataPriv.expando ] = undefined; 
                    } 
                    </span><span class="s2">if </span><span class="s1">( elem[ dataUser.expando ] ) { 
 
                        </span><span class="s0">// Support: Chrome &lt;=35 - 45+</span><span class="s1"> 
                        </span><span class="s0">// Assign undefined instead of using delete, see Data#remove</span><span class="s1"> 
                        elem[ dataUser.expando ] = undefined; 
                    } 
                } 
            } 
        } 
    } ); 
 
    jQuery.fn.extend( { 
        detach: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return </span><span class="s1">remove( </span><span class="s2">this</span><span class="s1">, selector, </span><span class="s2">true </span><span class="s1">); 
        }, 
 
        remove: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">return </span><span class="s1">remove( </span><span class="s2">this</span><span class="s1">, selector ); 
        }, 
 
        text: </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( value ) { 
                </span><span class="s2">return </span><span class="s1">value === undefined ? 
                    jQuery.text( </span><span class="s2">this </span><span class="s1">) : 
                    </span><span class="s2">this</span><span class="s1">.empty().each( </span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">11 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">9 </span><span class="s1">) { 
                            </span><span class="s2">this</span><span class="s1">.textContent = value; 
                        } 
                    } ); 
            }, </span><span class="s2">null</span><span class="s1">, value, arguments.length ); 
        }, 
 
        append: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">domManip( </span><span class="s2">this</span><span class="s1">, arguments, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">11 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">9 </span><span class="s1">) { 
                    </span><span class="s2">var </span><span class="s1">target = manipulationTarget( </span><span class="s2">this</span><span class="s1">, elem ); 
                    target.appendChild( elem ); 
                } 
            } ); 
        }, 
 
        prepend: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">domManip( </span><span class="s2">this</span><span class="s1">, arguments, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">1 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">11 </span><span class="s1">|| </span><span class="s2">this</span><span class="s1">.nodeType === </span><span class="s4">9 </span><span class="s1">) { 
                    </span><span class="s2">var </span><span class="s1">target = manipulationTarget( </span><span class="s2">this</span><span class="s1">, elem ); 
                    target.insertBefore( elem, target.firstChild ); 
                } 
            } ); 
        }, 
 
        before: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">domManip( </span><span class="s2">this</span><span class="s1">, arguments, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.parentNode ) { 
                    </span><span class="s2">this</span><span class="s1">.parentNode.insertBefore( elem, </span><span class="s2">this </span><span class="s1">); 
                } 
            } ); 
        }, 
 
        after: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">domManip( </span><span class="s2">this</span><span class="s1">, arguments, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.parentNode ) { 
                    </span><span class="s2">this</span><span class="s1">.parentNode.insertBefore( elem, </span><span class="s2">this</span><span class="s1">.nextSibling ); 
                } 
            } ); 
        }, 
 
        empty: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">elem, 
                i = </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s2">for </span><span class="s1">( ; ( elem = </span><span class="s2">this</span><span class="s1">[ i ] ) != </span><span class="s2">null</span><span class="s1">; i++ ) { 
                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
 
                    </span><span class="s0">// Prevent memory leaks</span><span class="s1"> 
                    jQuery.cleanData( getAll( elem, </span><span class="s2">false </span><span class="s1">) ); 
 
                    </span><span class="s0">// Remove any remaining nodes</span><span class="s1"> 
                    elem.textContent = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                } 
            } 
 
            </span><span class="s2">return this</span><span class="s1">; 
        }, 
 
        clone: </span><span class="s2">function</span><span class="s1">( dataAndEvents, deepDataAndEvents ) { 
            dataAndEvents = dataAndEvents == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">false </span><span class="s1">: dataAndEvents; 
            deepDataAndEvents = deepDataAndEvents == </span><span class="s2">null </span><span class="s1">? dataAndEvents : deepDataAndEvents; 
 
            </span><span class="s2">return this</span><span class="s1">.map( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">return </span><span class="s1">jQuery.clone( </span><span class="s2">this</span><span class="s1">, dataAndEvents, deepDataAndEvents ); 
            } ); 
        }, 
 
        html: </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( value ) { 
                </span><span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] || {}, 
                    i = </span><span class="s4">0</span><span class="s1">, 
                    l = </span><span class="s2">this</span><span class="s1">.length; 
 
                </span><span class="s2">if </span><span class="s1">( value === undefined &amp;&amp; elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">elem.innerHTML; 
                } 
 
                </span><span class="s0">// See if we can take a shortcut and just use innerHTML</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; !rnoInnerhtml.test( value ) &amp;&amp; 
                    !wrapMap[ ( rtagName.exec( value ) || [ </span><span class="s3">&quot;&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot; </span><span class="s1">] )[ </span><span class="s4">1 </span><span class="s1">].toLowerCase() ] ) { 
 
                    value = jQuery.htmlPrefilter( value ); 
 
                    </span><span class="s2">try </span><span class="s1">{ 
                        </span><span class="s2">for </span><span class="s1">( ; i &lt; l; i++ ) { 
                            elem = </span><span class="s2">this</span><span class="s1">[ i ] || {}; 
 
                            </span><span class="s0">// Remove element nodes and prevent memory leaks</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
                                jQuery.cleanData( getAll( elem, </span><span class="s2">false </span><span class="s1">) ); 
                                elem.innerHTML = value; 
                            } 
                        } 
 
                        elem = </span><span class="s4">0</span><span class="s1">; 
 
                        </span><span class="s0">// If using innerHTML throws an exception, use the fallback method</span><span class="s1"> 
                    } </span><span class="s2">catch </span><span class="s1">( e ) {} 
                } 
 
                </span><span class="s2">if </span><span class="s1">( elem ) { 
                    </span><span class="s2">this</span><span class="s1">.empty().append( value ); 
                } 
            }, </span><span class="s2">null</span><span class="s1">, value, arguments.length ); 
        }, 
 
        replaceWith: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">ignored = []; 
 
            </span><span class="s0">// Make the changes, replacing each non-ignored context element with the new content</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">domManip( </span><span class="s2">this</span><span class="s1">, arguments, </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">var </span><span class="s1">parent = </span><span class="s2">this</span><span class="s1">.parentNode; 
 
                </span><span class="s2">if </span><span class="s1">( jQuery.inArray( </span><span class="s2">this</span><span class="s1">, ignored ) &lt; </span><span class="s4">0 </span><span class="s1">) { 
                    jQuery.cleanData( getAll( </span><span class="s2">this </span><span class="s1">) ); 
                    </span><span class="s2">if </span><span class="s1">( parent ) { 
                        parent.replaceChild( elem, </span><span class="s2">this </span><span class="s1">); 
                    } 
                } 
 
                </span><span class="s0">// Force callback invocation</span><span class="s1"> 
            }, ignored ); 
        } 
    } ); 
 
    jQuery.each( { 
        appendTo: </span><span class="s3">&quot;append&quot;</span><span class="s1">, 
        prependTo: </span><span class="s3">&quot;prepend&quot;</span><span class="s1">, 
        insertBefore: </span><span class="s3">&quot;before&quot;</span><span class="s1">, 
        insertAfter: </span><span class="s3">&quot;after&quot;</span><span class="s1">, 
        replaceAll: </span><span class="s3">&quot;replaceWith&quot;</span><span class="s1"> 
    }, </span><span class="s2">function</span><span class="s1">( name, original ) { 
        jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">var </span><span class="s1">elems, 
                ret = [], 
                insert = jQuery( selector ), 
                last = insert.length - </span><span class="s4">1</span><span class="s1">, 
                i = </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s2">for </span><span class="s1">( ; i &lt;= last; i++ ) { 
                elems = i === last ? </span><span class="s2">this </span><span class="s1">: </span><span class="s2">this</span><span class="s1">.clone( </span><span class="s2">true </span><span class="s1">); 
                jQuery( insert[ i ] )[ original ]( elems ); 
 
                </span><span class="s0">// Support: Android &lt;=4.0 only, PhantomJS 1 only</span><span class="s1"> 
                </span><span class="s0">// .get() because push.apply(_, arraylike) throws on ancient WebKit</span><span class="s1"> 
                push.apply( ret, elems.get() ); 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.pushStack( ret ); 
        }; 
    } ); 
    </span><span class="s2">var </span><span class="s1">rmargin = ( </span><span class="s4">/^margin/ </span><span class="s1">); 
 
    </span><span class="s2">var </span><span class="s1">rnumnonpx = </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;^(&quot; </span><span class="s1">+ pnum + </span><span class="s3">&quot;)(?!px)[a-z%]+$&quot;</span><span class="s1">, </span><span class="s3">&quot;i&quot; </span><span class="s1">); 
 
    </span><span class="s2">var </span><span class="s1">getStyles = </span><span class="s2">function</span><span class="s1">( elem ) { 
 
        </span><span class="s0">// Support: IE &lt;=11 only, Firefox &lt;=30 (#15098, #14150)</span><span class="s1"> 
        </span><span class="s0">// IE throws on elements created in popups</span><span class="s1"> 
        </span><span class="s0">// FF meanwhile throws on frame elements through &quot;defaultView.getComputedStyle&quot;</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">view = elem.ownerDocument.defaultView; 
 
        </span><span class="s2">if </span><span class="s1">( !view || !view.opener ) { 
            view = window; 
        } 
 
        </span><span class="s2">return </span><span class="s1">view.getComputedStyle( elem ); 
    }; 
 
 
 
    ( </span><span class="s2">function</span><span class="s1">() { 
 
        </span><span class="s0">// Executing both pixelPosition &amp; boxSizingReliable tests require only one layout</span><span class="s1"> 
        </span><span class="s0">// so they're executed at the same time to save the second computation.</span><span class="s1"> 
        </span><span class="s2">function </span><span class="s1">computeStyleTests() { 
 
            </span><span class="s0">// This is a singleton, we need to execute it only once</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !div ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            div.style.cssText = 
                </span><span class="s3">&quot;box-sizing:border-box;&quot; </span><span class="s1">+ 
                </span><span class="s3">&quot;position:relative;display:block;&quot; </span><span class="s1">+ 
                </span><span class="s3">&quot;margin:auto;border:1px;padding:1px;&quot; </span><span class="s1">+ 
                </span><span class="s3">&quot;top:1%;width:50%&quot;</span><span class="s1">; 
            div.innerHTML = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
            documentElement.appendChild( container ); 
 
            </span><span class="s2">var </span><span class="s1">divStyle = window.getComputedStyle( div ); 
            pixelPositionVal = divStyle.top !== </span><span class="s3">&quot;1%&quot;</span><span class="s1">; 
 
            </span><span class="s0">// Support: Android 4.0 - 4.3 only, Firefox &lt;=3 - 44</span><span class="s1"> 
            reliableMarginLeftVal = divStyle.marginLeft === </span><span class="s3">&quot;2px&quot;</span><span class="s1">; 
            boxSizingReliableVal = divStyle.width === </span><span class="s3">&quot;4px&quot;</span><span class="s1">; 
 
            </span><span class="s0">// Support: Android 4.0 - 4.3 only</span><span class="s1"> 
            </span><span class="s0">// Some styles come back with percentage values, even though they shouldn't</span><span class="s1"> 
            div.style.marginRight = </span><span class="s3">&quot;50%&quot;</span><span class="s1">; 
            pixelMarginRightVal = divStyle.marginRight === </span><span class="s3">&quot;4px&quot;</span><span class="s1">; 
 
            documentElement.removeChild( container ); 
 
            </span><span class="s0">// Nullify the div so it wouldn't be stored in the memory and</span><span class="s1"> 
            </span><span class="s0">// it will also be a sign that checks already performed</span><span class="s1"> 
            div = </span><span class="s2">null</span><span class="s1">; 
        } 
 
        </span><span class="s2">var </span><span class="s1">pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, 
            container = document.createElement( </span><span class="s3">&quot;div&quot; </span><span class="s1">), 
            div = document.createElement( </span><span class="s3">&quot;div&quot; </span><span class="s1">); 
 
        </span><span class="s0">// Finish early in limited (non-browser) environments</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !div.style ) { 
            </span><span class="s2">return</span><span class="s1">; 
        } 
 
        </span><span class="s0">// Support: IE &lt;=9 - 11 only</span><span class="s1"> 
        </span><span class="s0">// Style of cloned element affects source element cloned (#8908)</span><span class="s1"> 
        div.style.backgroundClip = </span><span class="s3">&quot;content-box&quot;</span><span class="s1">; 
        div.cloneNode( </span><span class="s2">true </span><span class="s1">).style.backgroundClip = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
        support.clearCloneStyle = div.style.backgroundClip === </span><span class="s3">&quot;content-box&quot;</span><span class="s1">; 
 
        container.style.cssText = </span><span class="s3">&quot;border:0;width:8px;height:0;top:0;left:-9999px;&quot; </span><span class="s1">+ 
            </span><span class="s3">&quot;padding:0;margin-top:1px;position:absolute&quot;</span><span class="s1">; 
        container.appendChild( div ); 
 
        jQuery.extend( support, { 
            pixelPosition: </span><span class="s2">function</span><span class="s1">() { 
                computeStyleTests(); 
                </span><span class="s2">return </span><span class="s1">pixelPositionVal; 
            }, 
            boxSizingReliable: </span><span class="s2">function</span><span class="s1">() { 
                computeStyleTests(); 
                </span><span class="s2">return </span><span class="s1">boxSizingReliableVal; 
            }, 
            pixelMarginRight: </span><span class="s2">function</span><span class="s1">() { 
                computeStyleTests(); 
                </span><span class="s2">return </span><span class="s1">pixelMarginRightVal; 
            }, 
            reliableMarginLeft: </span><span class="s2">function</span><span class="s1">() { 
                computeStyleTests(); 
                </span><span class="s2">return </span><span class="s1">reliableMarginLeftVal; 
            } 
        } ); 
    } )(); 
 
 
    </span><span class="s2">function </span><span class="s1">curCSS( elem, name, computed ) { 
        </span><span class="s2">var </span><span class="s1">width, minWidth, maxWidth, ret, 
            style = elem.style; 
 
        computed = computed || getStyles( elem ); 
 
        </span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
        </span><span class="s0">// getPropertyValue is only needed for .css('filter') (#12537)</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( computed ) { 
            ret = computed.getPropertyValue( name ) || computed[ name ]; 
 
            </span><span class="s2">if </span><span class="s1">( ret === </span><span class="s3">&quot;&quot; </span><span class="s1">&amp;&amp; !jQuery.contains( elem.ownerDocument, elem ) ) { 
                ret = jQuery.style( elem, name ); 
            } 
 
            </span><span class="s0">// A tribute to the &quot;awesome hack by Dean Edwards&quot;</span><span class="s1"> 
            </span><span class="s0">// Android Browser returns percentage for some values,</span><span class="s1"> 
            </span><span class="s0">// but width seems to be reliably pixels.</span><span class="s1"> 
            </span><span class="s0">// This is against the CSSOM draft spec:</span><span class="s1"> 
            </span><span class="s0">// https://drafts.csswg.org/cssom/#resolved-values</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !support.pixelMarginRight() &amp;&amp; rnumnonpx.test( ret ) &amp;&amp; rmargin.test( name ) ) { 
 
                </span><span class="s0">// Remember the original values</span><span class="s1"> 
                width = style.width; 
                minWidth = style.minWidth; 
                maxWidth = style.maxWidth; 
 
                </span><span class="s0">// Put in the new values to get a computed value out</span><span class="s1"> 
                style.minWidth = style.maxWidth = style.width = ret; 
                ret = computed.width; 
 
                </span><span class="s0">// Revert the changed values</span><span class="s1"> 
                style.width = width; 
                style.minWidth = minWidth; 
                style.maxWidth = maxWidth; 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">ret !== undefined ? 
 
            </span><span class="s0">// Support: IE &lt;=9 - 11 only</span><span class="s1"> 
            </span><span class="s0">// IE returns zIndex value as an integer.</span><span class="s1"> 
        ret + </span><span class="s3">&quot;&quot; </span><span class="s1">: 
            ret; 
    } 
 
 
    </span><span class="s2">function </span><span class="s1">addGetHookIf( conditionFn, hookFn ) { 
 
        </span><span class="s0">// Define the hook, we'll check on the first run if it's really needed.</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">{ 
            </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( conditionFn() ) { 
 
                    </span><span class="s0">// Hook not needed (or it's not possible to use it due</span><span class="s1"> 
                    </span><span class="s0">// to missing dependency), remove it.</span><span class="s1"> 
                    </span><span class="s2">delete this</span><span class="s1">.get; 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
 
                </span><span class="s0">// Hook needed; redefine it so that the support test is not executed again.</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.get = hookFn ).apply( </span><span class="s2">this</span><span class="s1">, arguments ); 
            } 
        }; 
    } 
 
 
    </span><span class="s2">var</span><span class="s1"> 
 
    </span><span class="s0">// Swappable if display is none or starts with table</span><span class="s1"> 
    </span><span class="s0">// except &quot;table&quot;, &quot;table-cell&quot;, or &quot;table-caption&quot;</span><span class="s1"> 
    </span><span class="s0">// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display</span><span class="s1"> 
        rdisplayswap = </span><span class="s4">/^(none|table(?!-c[ea]).+)/</span><span class="s1">, 
        cssShow = { position: </span><span class="s3">&quot;absolute&quot;</span><span class="s1">, visibility: </span><span class="s3">&quot;hidden&quot;</span><span class="s1">, display: </span><span class="s3">&quot;block&quot; </span><span class="s1">}, 
        cssNormalTransform = { 
            letterSpacing: </span><span class="s3">&quot;0&quot;</span><span class="s1">, 
            fontWeight: </span><span class="s3">&quot;400&quot;</span><span class="s1"> 
        }, 
 
        cssPrefixes = [ </span><span class="s3">&quot;Webkit&quot;</span><span class="s1">, </span><span class="s3">&quot;Moz&quot;</span><span class="s1">, </span><span class="s3">&quot;ms&quot; </span><span class="s1">], 
        emptyStyle = document.createElement( </span><span class="s3">&quot;div&quot; </span><span class="s1">).style; 
 
</span><span class="s0">// Return a css property mapped to a potentially vendor prefixed property</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">vendorPropName( name ) { 
 
        </span><span class="s0">// Shortcut for names that are not vendor prefixed</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">emptyStyle ) { 
            </span><span class="s2">return </span><span class="s1">name; 
        } 
 
        </span><span class="s0">// Check for vendor prefixed names</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">capName = name[ </span><span class="s4">0 </span><span class="s1">].toUpperCase() + name.slice( </span><span class="s4">1 </span><span class="s1">), 
            i = cssPrefixes.length; 
 
        </span><span class="s2">while </span><span class="s1">( i-- ) { 
            name = cssPrefixes[ i ] + capName; 
            </span><span class="s2">if </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">emptyStyle ) { 
                </span><span class="s2">return </span><span class="s1">name; 
            } 
        } 
    } 
 
    </span><span class="s2">function </span><span class="s1">setPositiveNumber( elem, value, subtract ) { 
 
        </span><span class="s0">// Any relative (+/-) values have already been</span><span class="s1"> 
        </span><span class="s0">// normalized at this point</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">matches = rcssNum.exec( value ); 
        </span><span class="s2">return </span><span class="s1">matches ? 
 
            </span><span class="s0">// Guard against undefined &quot;subtract&quot;, e.g., when used as in cssHooks</span><span class="s1"> 
        Math.max( </span><span class="s4">0</span><span class="s1">, matches[ </span><span class="s4">2 </span><span class="s1">] - ( subtract || </span><span class="s4">0 </span><span class="s1">) ) + ( matches[ </span><span class="s4">3 </span><span class="s1">] || </span><span class="s3">&quot;px&quot; </span><span class="s1">) : 
            value; 
    } 
 
    </span><span class="s2">function </span><span class="s1">augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) { 
        </span><span class="s2">var </span><span class="s1">i, 
            val = </span><span class="s4">0</span><span class="s1">; 
 
        </span><span class="s0">// If we already have the right measurement, avoid augmentation</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( extra === ( isBorderBox ? </span><span class="s3">&quot;border&quot; </span><span class="s1">: </span><span class="s3">&quot;content&quot; </span><span class="s1">) ) { 
            i = </span><span class="s4">4</span><span class="s1">; 
 
            </span><span class="s0">// Otherwise initialize for horizontal or vertical properties</span><span class="s1"> 
        } </span><span class="s2">else </span><span class="s1">{ 
            i = name === </span><span class="s3">&quot;width&quot; </span><span class="s1">? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">; 
        } 
 
        </span><span class="s2">for </span><span class="s1">( ; i &lt; </span><span class="s4">4</span><span class="s1">; i += </span><span class="s4">2 </span><span class="s1">) { 
 
            </span><span class="s0">// Both box models exclude margin, so add it if we want it</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( extra === </span><span class="s3">&quot;margin&quot; </span><span class="s1">) { 
                val += jQuery.css( elem, extra + cssExpand[ i ], </span><span class="s2">true</span><span class="s1">, styles ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( isBorderBox ) { 
 
                </span><span class="s0">// border-box includes padding, so remove it if we want content</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( extra === </span><span class="s3">&quot;content&quot; </span><span class="s1">) { 
                    val -= jQuery.css( elem, </span><span class="s3">&quot;padding&quot; </span><span class="s1">+ cssExpand[ i ], </span><span class="s2">true</span><span class="s1">, styles ); 
                } 
 
                </span><span class="s0">// At this point, extra isn't border nor margin, so remove border</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( extra !== </span><span class="s3">&quot;margin&quot; </span><span class="s1">) { 
                    val -= jQuery.css( elem, </span><span class="s3">&quot;border&quot; </span><span class="s1">+ cssExpand[ i ] + </span><span class="s3">&quot;Width&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, styles ); 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
 
                </span><span class="s0">// At this point, extra isn't content, so add padding</span><span class="s1"> 
                val += jQuery.css( elem, </span><span class="s3">&quot;padding&quot; </span><span class="s1">+ cssExpand[ i ], </span><span class="s2">true</span><span class="s1">, styles ); 
 
                </span><span class="s0">// At this point, extra isn't content nor padding, so add border</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( extra !== </span><span class="s3">&quot;padding&quot; </span><span class="s1">) { 
                    val += jQuery.css( elem, </span><span class="s3">&quot;border&quot; </span><span class="s1">+ cssExpand[ i ] + </span><span class="s3">&quot;Width&quot;</span><span class="s1">, </span><span class="s2">true</span><span class="s1">, styles ); 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">val; 
    } 
 
    </span><span class="s2">function </span><span class="s1">getWidthOrHeight( elem, name, extra ) { 
 
        </span><span class="s0">// Start with offset property, which is equivalent to the border-box value</span><span class="s1"> 
        </span><span class="s2">var </span><span class="s1">val, 
            valueIsBorderBox = </span><span class="s2">true</span><span class="s1">, 
            styles = getStyles( elem ), 
            isBorderBox = jQuery.css( elem, </span><span class="s3">&quot;boxSizing&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, styles ) === </span><span class="s3">&quot;border-box&quot;</span><span class="s1">; 
 
        </span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
        </span><span class="s0">// Running getBoundingClientRect on a disconnected node</span><span class="s1"> 
        </span><span class="s0">// in IE throws an error.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( elem.getClientRects().length ) { 
            val = elem.getBoundingClientRect()[ name ]; 
        } 
 
        </span><span class="s0">// Some non-html elements return undefined for offsetWidth, so check for null/undefined</span><span class="s1"> 
        </span><span class="s0">// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285</span><span class="s1"> 
        </span><span class="s0">// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( val &lt;= </span><span class="s4">0 </span><span class="s1">|| val == </span><span class="s2">null </span><span class="s1">) { 
 
            </span><span class="s0">// Fall back to computed then uncomputed css if necessary</span><span class="s1"> 
            val = curCSS( elem, name, styles ); 
            </span><span class="s2">if </span><span class="s1">( val &lt; </span><span class="s4">0 </span><span class="s1">|| val == </span><span class="s2">null </span><span class="s1">) { 
                val = elem.style[ name ]; 
            } 
 
            </span><span class="s0">// Computed unit is not pixels. Stop here and return.</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rnumnonpx.test( val ) ) { 
                </span><span class="s2">return </span><span class="s1">val; 
            } 
 
            </span><span class="s0">// Check for style in case a browser which returns unreliable values</span><span class="s1"> 
            </span><span class="s0">// for getComputedStyle silently falls back to the reliable elem.style</span><span class="s1"> 
            valueIsBorderBox = isBorderBox &amp;&amp; 
                ( support.boxSizingReliable() || val === elem.style[ name ] ); 
 
            </span><span class="s0">// Normalize &quot;&quot;, auto, and prepare for extra</span><span class="s1"> 
            val = parseFloat( val ) || </span><span class="s4">0</span><span class="s1">; 
        } 
 
        </span><span class="s0">// Use the active box-sizing model to add/subtract irrelevant styles</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">( val + 
                augmentWidthOrHeight( 
                    elem, 
                    name, 
                    extra || ( isBorderBox ? </span><span class="s3">&quot;border&quot; </span><span class="s1">: </span><span class="s3">&quot;content&quot; </span><span class="s1">), 
                    valueIsBorderBox, 
                    styles 
                ) 
            ) + </span><span class="s3">&quot;px&quot;</span><span class="s1">; 
    } 
 
    jQuery.extend( { 
 
        </span><span class="s0">// Add in style property hooks for overriding the default</span><span class="s1"> 
        </span><span class="s0">// behavior of getting and setting a style property</span><span class="s1"> 
        cssHooks: { 
            opacity: { 
                </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, computed ) { 
                    </span><span class="s2">if </span><span class="s1">( computed ) { 
 
                        </span><span class="s0">// We should always get a number back from opacity</span><span class="s1"> 
                        </span><span class="s2">var </span><span class="s1">ret = curCSS( elem, </span><span class="s3">&quot;opacity&quot; </span><span class="s1">); 
                        </span><span class="s2">return </span><span class="s1">ret === </span><span class="s3">&quot;&quot; </span><span class="s1">? </span><span class="s3">&quot;1&quot; </span><span class="s1">: ret; 
                    } 
                } 
            } 
        }, 
 
        </span><span class="s0">// Don't automatically add &quot;px&quot; to these possibly-unitless properties</span><span class="s1"> 
        cssNumber: { 
            </span><span class="s3">&quot;animationIterationCount&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;columnCount&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;fillOpacity&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;flexGrow&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;flexShrink&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;fontWeight&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;lineHeight&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;opacity&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;order&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;orphans&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;widows&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;zIndex&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
            </span><span class="s3">&quot;zoom&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1"> 
        }, 
 
        </span><span class="s0">// Add in properties whose names you wish to fix before</span><span class="s1"> 
        </span><span class="s0">// setting or getting the value</span><span class="s1"> 
        cssProps: { 
            </span><span class="s3">&quot;float&quot;</span><span class="s1">: </span><span class="s3">&quot;cssFloat&quot;</span><span class="s1"> 
        }, 
 
        </span><span class="s0">// Get and set the style property on a DOM Node</span><span class="s1"> 
        style: </span><span class="s2">function</span><span class="s1">( elem, name, value, extra ) { 
 
            </span><span class="s0">// Don't set styles on text and comment nodes</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !elem || elem.nodeType === </span><span class="s4">3 </span><span class="s1">|| elem.nodeType === </span><span class="s4">8 </span><span class="s1">|| !elem.style ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Make sure that we're working with the right name</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">ret, type, hooks, 
                origName = jQuery.camelCase( name ), 
                style = elem.style; 
 
            name = jQuery.cssProps[ origName ] || 
                ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName ); 
 
            </span><span class="s0">// Gets hook for the prefixed version, then unprefixed version</span><span class="s1"> 
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ]; 
 
            </span><span class="s0">// Check if we're setting a value</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( value !== undefined ) { 
                type = </span><span class="s2">typeof </span><span class="s1">value; 
 
                </span><span class="s0">// Convert &quot;+=&quot; or &quot;-=&quot; to relative numbers (#7345)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; ( ret = rcssNum.exec( value ) ) &amp;&amp; ret[ </span><span class="s4">1 </span><span class="s1">] ) { 
                    value = adjustCSS( elem, name, ret ); 
 
                    </span><span class="s0">// Fixes bug #9237</span><span class="s1"> 
                    type = </span><span class="s3">&quot;number&quot;</span><span class="s1">; 
                } 
 
                </span><span class="s0">// Make sure that null and NaN values aren't set (#7116)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( value == </span><span class="s2">null </span><span class="s1">|| value !== value ) { 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
 
                </span><span class="s0">// If a number was passed in, add the unit (except for certain CSS properties)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;number&quot; </span><span class="s1">) { 
                    value += ret &amp;&amp; ret[ </span><span class="s4">3 </span><span class="s1">] || ( jQuery.cssNumber[ origName ] ? </span><span class="s3">&quot;&quot; </span><span class="s1">: </span><span class="s3">&quot;px&quot; </span><span class="s1">); 
                } 
 
                </span><span class="s0">// background-* props affect original clone's values</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !support.clearCloneStyle &amp;&amp; value === </span><span class="s3">&quot;&quot; </span><span class="s1">&amp;&amp; name.indexOf( </span><span class="s3">&quot;background&quot; </span><span class="s1">) === </span><span class="s4">0 </span><span class="s1">) { 
                    style[ name ] = </span><span class="s3">&quot;inherit&quot;</span><span class="s1">; 
                } 
 
                </span><span class="s0">// If a hook was provided, use that value, otherwise just set the specified value</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !hooks || !( </span><span class="s3">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks ) || 
                    ( value = hooks.set( elem, value, extra ) ) !== undefined ) { 
 
                    style[ name ] = value; 
                } 
 
            } </span><span class="s2">else </span><span class="s1">{ 
 
                </span><span class="s0">// If a hook was provided get the non-computed value from there</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; 
                    ( ret = hooks.get( elem, </span><span class="s2">false</span><span class="s1">, extra ) ) !== undefined ) { 
 
                    </span><span class="s2">return </span><span class="s1">ret; 
                } 
 
                </span><span class="s0">// Otherwise just get the value from the style object</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">style[ name ]; 
            } 
        }, 
 
        css: </span><span class="s2">function</span><span class="s1">( elem, name, extra, styles ) { 
            </span><span class="s2">var </span><span class="s1">val, num, hooks, 
                origName = jQuery.camelCase( name ); 
 
            </span><span class="s0">// Make sure that we're working with the right name</span><span class="s1"> 
            name = jQuery.cssProps[ origName ] || 
                ( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName ); 
 
            </span><span class="s0">// Try prefixed name followed by the unprefixed name</span><span class="s1"> 
            hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ]; 
 
            </span><span class="s0">// If a hook was provided get the computed value from there</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks ) { 
                val = hooks.get( elem, </span><span class="s2">true</span><span class="s1">, extra ); 
            } 
 
            </span><span class="s0">// Otherwise, if a way to get the computed value exists, use that</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( val === undefined ) { 
                val = curCSS( elem, name, styles ); 
            } 
 
            </span><span class="s0">// Convert &quot;normal&quot; to computed value</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( val === </span><span class="s3">&quot;normal&quot; </span><span class="s1">&amp;&amp; name </span><span class="s2">in </span><span class="s1">cssNormalTransform ) { 
                val = cssNormalTransform[ name ]; 
            } 
 
            </span><span class="s0">// Make numeric if forced or a qualifier was provided and val looks numeric</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( extra === </span><span class="s3">&quot;&quot; </span><span class="s1">|| extra ) { 
                num = parseFloat( val ); 
                </span><span class="s2">return </span><span class="s1">extra === </span><span class="s2">true </span><span class="s1">|| isFinite( num ) ? num || </span><span class="s4">0 </span><span class="s1">: val; 
            } 
            </span><span class="s2">return </span><span class="s1">val; 
        } 
    } ); 
 
    jQuery.each( [ </span><span class="s3">&quot;height&quot;</span><span class="s1">, </span><span class="s3">&quot;width&quot; </span><span class="s1">], </span><span class="s2">function</span><span class="s1">( i, name ) { 
        jQuery.cssHooks[ name ] = { 
            </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, computed, extra ) { 
                </span><span class="s2">if </span><span class="s1">( computed ) { 
 
                    </span><span class="s0">// Certain elements can have dimension info if we invisibly show them</span><span class="s1"> 
                    </span><span class="s0">// but it must have a current display style that would benefit</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">rdisplayswap.test( jQuery.css( elem, </span><span class="s3">&quot;display&quot; </span><span class="s1">) ) &amp;&amp; 
 
                        </span><span class="s0">// Support: Safari 8+</span><span class="s1"> 
                        </span><span class="s0">// Table columns in Safari have non-zero offsetWidth &amp; zero</span><span class="s1"> 
                        </span><span class="s0">// getBoundingClientRect().width unless display is changed.</span><span class="s1"> 
                        </span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
                        </span><span class="s0">// Running getBoundingClientRect on a disconnected node</span><span class="s1"> 
                        </span><span class="s0">// in IE throws an error.</span><span class="s1"> 
                    ( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ? 
                        swap( elem, cssShow, </span><span class="s2">function</span><span class="s1">() { 
                            </span><span class="s2">return </span><span class="s1">getWidthOrHeight( elem, name, extra ); 
                        } ) : 
                        getWidthOrHeight( elem, name, extra ); 
                } 
            }, 
 
            </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, value, extra ) { 
                </span><span class="s2">var </span><span class="s1">matches, 
                    styles = extra &amp;&amp; getStyles( elem ), 
                    subtract = extra &amp;&amp; augmentWidthOrHeight( 
                            elem, 
                            name, 
                            extra, 
                            jQuery.css( elem, </span><span class="s3">&quot;boxSizing&quot;</span><span class="s1">, </span><span class="s2">false</span><span class="s1">, styles ) === </span><span class="s3">&quot;border-box&quot;</span><span class="s1">, 
                            styles 
                        ); 
 
                </span><span class="s0">// Convert to pixels if value adjustment is needed</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( subtract &amp;&amp; ( matches = rcssNum.exec( value ) ) &amp;&amp; 
                    ( matches[ </span><span class="s4">3 </span><span class="s1">] || </span><span class="s3">&quot;px&quot; </span><span class="s1">) !== </span><span class="s3">&quot;px&quot; </span><span class="s1">) { 
 
                    elem.style[ name ] = value; 
                    value = jQuery.css( elem, name ); 
                } 
 
                </span><span class="s2">return </span><span class="s1">setPositiveNumber( elem, value, subtract ); 
            } 
        }; 
    } ); 
 
    jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft, 
        </span><span class="s2">function</span><span class="s1">( elem, computed ) { 
            </span><span class="s2">if </span><span class="s1">( computed ) { 
                </span><span class="s2">return </span><span class="s1">( parseFloat( curCSS( elem, </span><span class="s3">&quot;marginLeft&quot; </span><span class="s1">) ) || 
                        elem.getBoundingClientRect().left - 
                        swap( elem, { marginLeft: </span><span class="s4">0 </span><span class="s1">}, </span><span class="s2">function</span><span class="s1">() { 
                            </span><span class="s2">return </span><span class="s1">elem.getBoundingClientRect().left; 
                        } ) 
                    ) + </span><span class="s3">&quot;px&quot;</span><span class="s1">; 
            } 
        } 
    ); 
 
</span><span class="s0">// These hooks are used by animate to expand properties</span><span class="s1"> 
    jQuery.each( { 
        margin: </span><span class="s3">&quot;&quot;</span><span class="s1">, 
        padding: </span><span class="s3">&quot;&quot;</span><span class="s1">, 
        border: </span><span class="s3">&quot;Width&quot;</span><span class="s1"> 
    }, </span><span class="s2">function</span><span class="s1">( prefix, suffix ) { 
        jQuery.cssHooks[ prefix + suffix ] = { 
            expand: </span><span class="s2">function</span><span class="s1">( value ) { 
                </span><span class="s2">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s1">, 
                    expanded = {}, 
 
                </span><span class="s0">// Assumes a single number if not a string</span><span class="s1"> 
                    parts = </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;string&quot; </span><span class="s1">? value.split( </span><span class="s3">&quot; &quot; </span><span class="s1">) : [ value ]; 
 
                </span><span class="s2">for </span><span class="s1">( ; i &lt; </span><span class="s4">4</span><span class="s1">; i++ ) { 
                    expanded[ prefix + cssExpand[ i ] + suffix ] = 
                        parts[ i ] || parts[ i - </span><span class="s4">2 </span><span class="s1">] || parts[ </span><span class="s4">0 </span><span class="s1">]; 
                } 
 
                </span><span class="s2">return </span><span class="s1">expanded; 
            } 
        }; 
 
        </span><span class="s2">if </span><span class="s1">( !rmargin.test( prefix ) ) { 
            jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber; 
        } 
    } ); 
 
    jQuery.fn.extend( { 
        css: </span><span class="s2">function</span><span class="s1">( name, value ) { 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( elem, name, value ) { 
                </span><span class="s2">var </span><span class="s1">styles, len, 
                    map = {}, 
                    i = </span><span class="s4">0</span><span class="s1">; 
 
                </span><span class="s2">if </span><span class="s1">( jQuery.isArray( name ) ) { 
                    styles = getStyles( elem ); 
                    len = name.length; 
 
                    </span><span class="s2">for </span><span class="s1">( ; i &lt; len; i++ ) { 
                        map[ name[ i ] ] = jQuery.css( elem, name[ i ], </span><span class="s2">false</span><span class="s1">, styles ); 
                    } 
 
                    </span><span class="s2">return </span><span class="s1">map; 
                } 
 
                </span><span class="s2">return </span><span class="s1">value !== undefined ? 
                    jQuery.style( elem, name, value ) : 
                    jQuery.css( elem, name ); 
            }, name, value, arguments.length &gt; </span><span class="s4">1 </span><span class="s1">); 
        } 
    } ); 
 
 
    </span><span class="s2">function </span><span class="s1">Tween( elem, options, prop, end, easing ) { 
        </span><span class="s2">return new </span><span class="s1">Tween.prototype.init( elem, options, prop, end, easing ); 
    } 
    jQuery.Tween = Tween; 
 
    Tween.prototype = { 
        constructor: Tween, 
        init: </span><span class="s2">function</span><span class="s1">( elem, options, prop, end, easing, unit ) { 
            </span><span class="s2">this</span><span class="s1">.elem = elem; 
            </span><span class="s2">this</span><span class="s1">.prop = prop; 
            </span><span class="s2">this</span><span class="s1">.easing = easing || jQuery.easing._default; 
            </span><span class="s2">this</span><span class="s1">.options = options; 
            </span><span class="s2">this</span><span class="s1">.start = </span><span class="s2">this</span><span class="s1">.now = </span><span class="s2">this</span><span class="s1">.cur(); 
            </span><span class="s2">this</span><span class="s1">.end = end; 
            </span><span class="s2">this</span><span class="s1">.unit = unit || ( jQuery.cssNumber[ prop ] ? </span><span class="s3">&quot;&quot; </span><span class="s1">: </span><span class="s3">&quot;px&quot; </span><span class="s1">); 
        }, 
        cur: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">hooks = Tween.propHooks[ </span><span class="s2">this</span><span class="s1">.prop ]; 
 
            </span><span class="s2">return </span><span class="s1">hooks &amp;&amp; hooks.get ? 
                hooks.get( </span><span class="s2">this </span><span class="s1">) : 
                Tween.propHooks._default.get( </span><span class="s2">this </span><span class="s1">); 
        }, 
        run: </span><span class="s2">function</span><span class="s1">( percent ) { 
            </span><span class="s2">var </span><span class="s1">eased, 
                hooks = Tween.propHooks[ </span><span class="s2">this</span><span class="s1">.prop ]; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.options.duration ) { 
                </span><span class="s2">this</span><span class="s1">.pos = eased = jQuery.easing[ </span><span class="s2">this</span><span class="s1">.easing ]( 
                    percent, </span><span class="s2">this</span><span class="s1">.options.duration * percent, </span><span class="s4">0</span><span class="s1">, </span><span class="s4">1</span><span class="s1">, </span><span class="s2">this</span><span class="s1">.options.duration 
                ); 
            } </span><span class="s2">else </span><span class="s1">{ 
                </span><span class="s2">this</span><span class="s1">.pos = eased = percent; 
            } 
            </span><span class="s2">this</span><span class="s1">.now = ( </span><span class="s2">this</span><span class="s1">.end - </span><span class="s2">this</span><span class="s1">.start ) * eased + </span><span class="s2">this</span><span class="s1">.start; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.options.step ) { 
                </span><span class="s2">this</span><span class="s1">.options.step.call( </span><span class="s2">this</span><span class="s1">.elem, </span><span class="s2">this</span><span class="s1">.now, </span><span class="s2">this </span><span class="s1">); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; hooks.set ) { 
                hooks.set( </span><span class="s2">this </span><span class="s1">); 
            } </span><span class="s2">else </span><span class="s1">{ 
                Tween.propHooks._default.set( </span><span class="s2">this </span><span class="s1">); 
            } 
            </span><span class="s2">return this</span><span class="s1">; 
        } 
    }; 
 
    Tween.prototype.init.prototype = Tween.prototype; 
 
    Tween.propHooks = { 
        _default: { 
            </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( tween ) { 
                </span><span class="s2">var </span><span class="s1">result; 
 
                </span><span class="s0">// Use a property on the element directly when it is not a DOM element,</span><span class="s1"> 
                </span><span class="s0">// or when there is no matching style property that exists.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( tween.elem.nodeType !== </span><span class="s4">1 </span><span class="s1">|| 
                    tween.elem[ tween.prop ] != </span><span class="s2">null </span><span class="s1">&amp;&amp; tween.elem.style[ tween.prop ] == </span><span class="s2">null </span><span class="s1">) { 
                    </span><span class="s2">return </span><span class="s1">tween.elem[ tween.prop ]; 
                } 
 
                </span><span class="s0">// Passing an empty string as a 3rd parameter to .css will automatically</span><span class="s1"> 
                </span><span class="s0">// attempt a parseFloat and fallback to a string if the parse fails.</span><span class="s1"> 
                </span><span class="s0">// Simple values such as &quot;10px&quot; are parsed to Float;</span><span class="s1"> 
                </span><span class="s0">// complex values such as &quot;rotate(1rad)&quot; are returned as-is.</span><span class="s1"> 
                result = jQuery.css( tween.elem, tween.prop, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
 
                </span><span class="s0">// Empty strings, null, undefined and &quot;auto&quot; are converted to 0.</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">!result || result === </span><span class="s3">&quot;auto&quot; </span><span class="s1">? </span><span class="s4">0 </span><span class="s1">: result; 
            }, 
            </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( tween ) { 
 
                </span><span class="s0">// Use step hook for back compat.</span><span class="s1"> 
                </span><span class="s0">// Use cssHook if its there.</span><span class="s1"> 
                </span><span class="s0">// Use .style if available and use plain properties where available.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( jQuery.fx.step[ tween.prop ] ) { 
                    jQuery.fx.step[ tween.prop ]( tween ); 
                } </span><span class="s2">else if </span><span class="s1">( tween.elem.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; 
                    ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != </span><span class="s2">null </span><span class="s1">|| 
                    jQuery.cssHooks[ tween.prop ] ) ) { 
                    jQuery.style( tween.elem, tween.prop, tween.now + tween.unit ); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    tween.elem[ tween.prop ] = tween.now; 
                } 
            } 
        } 
    }; 
 
</span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
</span><span class="s0">// Panic based approach to setting things on disconnected nodes</span><span class="s1"> 
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = { 
        </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( tween ) { 
            </span><span class="s2">if </span><span class="s1">( tween.elem.nodeType &amp;&amp; tween.elem.parentNode ) { 
                tween.elem[ tween.prop ] = tween.now; 
            } 
        } 
    }; 
 
    jQuery.easing = { 
        linear: </span><span class="s2">function</span><span class="s1">( p ) { 
            </span><span class="s2">return </span><span class="s1">p; 
        }, 
        swing: </span><span class="s2">function</span><span class="s1">( p ) { 
            </span><span class="s2">return </span><span class="s4">0.5 </span><span class="s1">- Math.cos( p * Math.PI ) / </span><span class="s4">2</span><span class="s1">; 
        }, 
        _default: </span><span class="s3">&quot;swing&quot;</span><span class="s1"> 
    }; 
 
    jQuery.fx = Tween.prototype.init; 
 
</span><span class="s0">// Back compat &lt;1.8 extension point</span><span class="s1"> 
    jQuery.fx.step = {}; 
 
 
 
 
    </span><span class="s2">var</span><span class="s1"> 
        fxNow, timerId, 
        rfxtypes = </span><span class="s4">/^(?:toggle|show|hide)$/</span><span class="s1">, 
        rrun = </span><span class="s4">/queueHooks$/</span><span class="s1">; 
 
    </span><span class="s2">function </span><span class="s1">raf() { 
        </span><span class="s2">if </span><span class="s1">( timerId ) { 
            window.requestAnimationFrame( raf ); 
            jQuery.fx.tick(); 
        } 
    } 
 
</span><span class="s0">// Animations created synchronously will run synchronously</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">createFxNow() { 
        window.setTimeout( </span><span class="s2">function</span><span class="s1">() { 
            fxNow = undefined; 
        } ); 
        </span><span class="s2">return </span><span class="s1">( fxNow = jQuery.now() ); 
    } 
 
</span><span class="s0">// Generate parameters to create a standard animation</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">genFx( type, includeWidth ) { 
        </span><span class="s2">var </span><span class="s1">which, 
            i = </span><span class="s4">0</span><span class="s1">, 
            attrs = { height: type }; 
 
        </span><span class="s0">// If we include width, step value is 1 to do all cssExpand values,</span><span class="s1"> 
        </span><span class="s0">// otherwise step value is 2 to skip over Left and Right</span><span class="s1"> 
        includeWidth = includeWidth ? </span><span class="s4">1 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">; 
        </span><span class="s2">for </span><span class="s1">( ; i &lt; </span><span class="s4">4</span><span class="s1">; i += </span><span class="s4">2 </span><span class="s1">- includeWidth ) { 
            which = cssExpand[ i ]; 
            attrs[ </span><span class="s3">&quot;margin&quot; </span><span class="s1">+ which ] = attrs[ </span><span class="s3">&quot;padding&quot; </span><span class="s1">+ which ] = type; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( includeWidth ) { 
            attrs.opacity = attrs.width = type; 
        } 
 
        </span><span class="s2">return </span><span class="s1">attrs; 
    } 
 
    </span><span class="s2">function </span><span class="s1">createTween( value, prop, animation ) { 
        </span><span class="s2">var </span><span class="s1">tween, 
            collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ </span><span class="s3">&quot;*&quot; </span><span class="s1">] ), 
            index = </span><span class="s4">0</span><span class="s1">, 
            length = collection.length; 
        </span><span class="s2">for </span><span class="s1">( ; index &lt; length; index++ ) { 
            </span><span class="s2">if </span><span class="s1">( ( tween = collection[ index ].call( animation, prop, value ) ) ) { 
 
                </span><span class="s0">// We're done with this property</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">tween; 
            } 
        } 
    } 
 
    </span><span class="s2">function </span><span class="s1">defaultPrefilter( elem, props, opts ) { 
        </span><span class="s2">var </span><span class="s1">prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, 
            isBox = </span><span class="s3">&quot;width&quot; </span><span class="s2">in </span><span class="s1">props || </span><span class="s3">&quot;height&quot; </span><span class="s2">in </span><span class="s1">props, 
            anim = </span><span class="s2">this</span><span class="s1">, 
            orig = {}, 
            style = elem.style, 
            hidden = elem.nodeType &amp;&amp; isHiddenWithinTree( elem ), 
            dataShow = dataPriv.get( elem, </span><span class="s3">&quot;fxshow&quot; </span><span class="s1">); 
 
        </span><span class="s0">// Queue-skipping animations hijack the fx hooks</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( !opts.queue ) { 
            hooks = jQuery._queueHooks( elem, </span><span class="s3">&quot;fx&quot; </span><span class="s1">); 
            </span><span class="s2">if </span><span class="s1">( hooks.unqueued == </span><span class="s2">null </span><span class="s1">) { 
                hooks.unqueued = </span><span class="s4">0</span><span class="s1">; 
                oldfire = hooks.empty.fire; 
                hooks.empty.fire = </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( !hooks.unqueued ) { 
                        oldfire(); 
                    } 
                }; 
            } 
            hooks.unqueued++; 
 
            anim.always( </span><span class="s2">function</span><span class="s1">() { 
 
                </span><span class="s0">// Ensure the complete handler is called before this completes</span><span class="s1"> 
                anim.always( </span><span class="s2">function</span><span class="s1">() { 
                    hooks.unqueued--; 
                    </span><span class="s2">if </span><span class="s1">( !jQuery.queue( elem, </span><span class="s3">&quot;fx&quot; </span><span class="s1">).length ) { 
                        hooks.empty.fire(); 
                    } 
                } ); 
            } ); 
        } 
 
        </span><span class="s0">// Detect show/hide animations</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">props ) { 
            value = props[ prop ]; 
            </span><span class="s2">if </span><span class="s1">( rfxtypes.test( value ) ) { 
                </span><span class="s2">delete </span><span class="s1">props[ prop ]; 
                toggle = toggle || value === </span><span class="s3">&quot;toggle&quot;</span><span class="s1">; 
                </span><span class="s2">if </span><span class="s1">( value === ( hidden ? </span><span class="s3">&quot;hide&quot; </span><span class="s1">: </span><span class="s3">&quot;show&quot; </span><span class="s1">) ) { 
 
                    </span><span class="s0">// Pretend to be hidden if this is a &quot;show&quot; and</span><span class="s1"> 
                    </span><span class="s0">// there is still data from a stopped show/hide</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( value === </span><span class="s3">&quot;show&quot; </span><span class="s1">&amp;&amp; dataShow &amp;&amp; dataShow[ prop ] !== undefined ) { 
                        hidden = </span><span class="s2">true</span><span class="s1">; 
 
                        </span><span class="s0">// Ignore all other no-op show/hide data</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        </span><span class="s2">continue</span><span class="s1">; 
                    } 
                } 
                orig[ prop ] = dataShow &amp;&amp; dataShow[ prop ] || jQuery.style( elem, prop ); 
            } 
        } 
 
        </span><span class="s0">// Bail out if this is a no-op like .hide().hide()</span><span class="s1"> 
        propTween = !jQuery.isEmptyObject( props ); 
        </span><span class="s2">if </span><span class="s1">( !propTween &amp;&amp; jQuery.isEmptyObject( orig ) ) { 
            </span><span class="s2">return</span><span class="s1">; 
        } 
 
        </span><span class="s0">// Restrict &quot;overflow&quot; and &quot;display&quot; styles during box animations</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( isBox &amp;&amp; elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
 
            </span><span class="s0">// Support: IE &lt;=9 - 11, Edge 12 - 13</span><span class="s1"> 
            </span><span class="s0">// Record all 3 overflow attributes because IE does not infer the shorthand</span><span class="s1"> 
            </span><span class="s0">// from identically-valued overflowX and overflowY</span><span class="s1"> 
            opts.overflow = [ style.overflow, style.overflowX, style.overflowY ]; 
 
            </span><span class="s0">// Identify a display type, preferring old show/hide data over the CSS cascade</span><span class="s1"> 
            restoreDisplay = dataShow &amp;&amp; dataShow.display; 
            </span><span class="s2">if </span><span class="s1">( restoreDisplay == </span><span class="s2">null </span><span class="s1">) { 
                restoreDisplay = dataPriv.get( elem, </span><span class="s3">&quot;display&quot; </span><span class="s1">); 
            } 
            display = jQuery.css( elem, </span><span class="s3">&quot;display&quot; </span><span class="s1">); 
            </span><span class="s2">if </span><span class="s1">( display === </span><span class="s3">&quot;none&quot; </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( restoreDisplay ) { 
                    display = restoreDisplay; 
                } </span><span class="s2">else </span><span class="s1">{ 
 
                    </span><span class="s0">// Get nonempty value(s) by temporarily forcing visibility</span><span class="s1"> 
                    showHide( [ elem ], </span><span class="s2">true </span><span class="s1">); 
                    restoreDisplay = elem.style.display || restoreDisplay; 
                    display = jQuery.css( elem, </span><span class="s3">&quot;display&quot; </span><span class="s1">); 
                    showHide( [ elem ] ); 
                } 
            } 
 
            </span><span class="s0">// Animate inline elements as inline-block</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( display === </span><span class="s3">&quot;inline&quot; </span><span class="s1">|| display === </span><span class="s3">&quot;inline-block&quot; </span><span class="s1">&amp;&amp; restoreDisplay != </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( jQuery.css( elem, </span><span class="s3">&quot;float&quot; </span><span class="s1">) === </span><span class="s3">&quot;none&quot; </span><span class="s1">) { 
 
                    </span><span class="s0">// Restore the original display value at the end of pure show/hide animations</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !propTween ) { 
                        anim.done( </span><span class="s2">function</span><span class="s1">() { 
                            style.display = restoreDisplay; 
                        } ); 
                        </span><span class="s2">if </span><span class="s1">( restoreDisplay == </span><span class="s2">null </span><span class="s1">) { 
                            display = style.display; 
                            restoreDisplay = display === </span><span class="s3">&quot;none&quot; </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: display; 
                        } 
                    } 
                    style.display = </span><span class="s3">&quot;inline-block&quot;</span><span class="s1">; 
                } 
            } 
        } 
 
        </span><span class="s2">if </span><span class="s1">( opts.overflow ) { 
            style.overflow = </span><span class="s3">&quot;hidden&quot;</span><span class="s1">; 
            anim.always( </span><span class="s2">function</span><span class="s1">() { 
                style.overflow = opts.overflow[ </span><span class="s4">0 </span><span class="s1">]; 
                style.overflowX = opts.overflow[ </span><span class="s4">1 </span><span class="s1">]; 
                style.overflowY = opts.overflow[ </span><span class="s4">2 </span><span class="s1">]; 
            } ); 
        } 
 
        </span><span class="s0">// Implement show/hide animations</span><span class="s1"> 
        propTween = </span><span class="s2">false</span><span class="s1">; 
        </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">orig ) { 
 
            </span><span class="s0">// General show/hide setup for this element animation</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !propTween ) { 
                </span><span class="s2">if </span><span class="s1">( dataShow ) { 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s3">&quot;hidden&quot; </span><span class="s2">in </span><span class="s1">dataShow ) { 
                        hidden = dataShow.hidden; 
                    } 
                } </span><span class="s2">else </span><span class="s1">{ 
                    dataShow = dataPriv.access( elem, </span><span class="s3">&quot;fxshow&quot;</span><span class="s1">, { display: restoreDisplay } ); 
                } 
 
                </span><span class="s0">// Store hidden/visible for toggle so `.stop().toggle()` &quot;reverses&quot;</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( toggle ) { 
                    dataShow.hidden = !hidden; 
                } 
 
                </span><span class="s0">// Show elements before animating them</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( hidden ) { 
                    showHide( [ elem ], </span><span class="s2">true </span><span class="s1">); 
                } 
 
                </span><span class="s0">/* eslint-disable no-loop-func */</span><span class="s1"> 
 
                anim.done( </span><span class="s2">function</span><span class="s1">() { 
 
                    </span><span class="s0">/* eslint-enable no-loop-func */</span><span class="s1"> 
 
                    </span><span class="s0">// The final step of a &quot;hide&quot; animation is actually hiding the element</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !hidden ) { 
                        showHide( [ elem ] ); 
                    } 
                    dataPriv.remove( elem, </span><span class="s3">&quot;fxshow&quot; </span><span class="s1">); 
                    </span><span class="s2">for </span><span class="s1">( prop </span><span class="s2">in </span><span class="s1">orig ) { 
                        jQuery.style( elem, prop, orig[ prop ] ); 
                    } 
                } ); 
            } 
 
            </span><span class="s0">// Per-property setup</span><span class="s1"> 
            propTween = createTween( hidden ? dataShow[ prop ] : </span><span class="s4">0</span><span class="s1">, prop, anim ); 
            </span><span class="s2">if </span><span class="s1">( !( prop </span><span class="s2">in </span><span class="s1">dataShow ) ) { 
                dataShow[ prop ] = propTween.start; 
                </span><span class="s2">if </span><span class="s1">( hidden ) { 
                    propTween.end = propTween.start; 
                    propTween.start = </span><span class="s4">0</span><span class="s1">; 
                } 
            } 
        } 
    } 
 
    </span><span class="s2">function </span><span class="s1">propFilter( props, specialEasing ) { 
        </span><span class="s2">var </span><span class="s1">index, name, easing, value, hooks; 
 
        </span><span class="s0">// camelCase, specialEasing and expand cssHook pass</span><span class="s1"> 
        </span><span class="s2">for </span><span class="s1">( index </span><span class="s2">in </span><span class="s1">props ) { 
            name = jQuery.camelCase( index ); 
            easing = specialEasing[ name ]; 
            value = props[ index ]; 
            </span><span class="s2">if </span><span class="s1">( jQuery.isArray( value ) ) { 
                easing = value[ </span><span class="s4">1 </span><span class="s1">]; 
                value = props[ index ] = value[ </span><span class="s4">0 </span><span class="s1">]; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( index !== name ) { 
                props[ name ] = value; 
                </span><span class="s2">delete </span><span class="s1">props[ index ]; 
            } 
 
            hooks = jQuery.cssHooks[ name ]; 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;expand&quot; </span><span class="s2">in </span><span class="s1">hooks ) { 
                value = hooks.expand( value ); 
                </span><span class="s2">delete </span><span class="s1">props[ name ]; 
 
                </span><span class="s0">// Not quite $.extend, this won't overwrite existing keys.</span><span class="s1"> 
                </span><span class="s0">// Reusing 'index' because we have the correct &quot;name&quot;</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( index </span><span class="s2">in </span><span class="s1">value ) { 
                    </span><span class="s2">if </span><span class="s1">( !( index </span><span class="s2">in </span><span class="s1">props ) ) { 
                        props[ index ] = value[ index ]; 
                        specialEasing[ index ] = easing; 
                    } 
                } 
            } </span><span class="s2">else </span><span class="s1">{ 
                specialEasing[ name ] = easing; 
            } 
        } 
    } 
 
    </span><span class="s2">function </span><span class="s1">Animation( elem, properties, options ) { 
        </span><span class="s2">var </span><span class="s1">result, 
            stopped, 
            index = </span><span class="s4">0</span><span class="s1">, 
            length = Animation.prefilters.length, 
            deferred = jQuery.Deferred().always( </span><span class="s2">function</span><span class="s1">() { 
 
                </span><span class="s0">// Don't match elem in the :animated selector</span><span class="s1"> 
                </span><span class="s2">delete </span><span class="s1">tick.elem; 
            } ), 
            tick = </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( stopped ) { 
                    </span><span class="s2">return false</span><span class="s1">; 
                } 
                </span><span class="s2">var </span><span class="s1">currentTime = fxNow || createFxNow(), 
                    remaining = Math.max( </span><span class="s4">0</span><span class="s1">, animation.startTime + animation.duration - currentTime ), 
 
                </span><span class="s0">// Support: Android 2.3 only</span><span class="s1"> 
                </span><span class="s0">// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)</span><span class="s1"> 
                    temp = remaining / animation.duration || </span><span class="s4">0</span><span class="s1">, 
                    percent = </span><span class="s4">1 </span><span class="s1">- temp, 
                    index = </span><span class="s4">0</span><span class="s1">, 
                    length = animation.tweens.length; 
 
                </span><span class="s2">for </span><span class="s1">( ; index &lt; length; index++ ) { 
                    animation.tweens[ index ].run( percent ); 
                } 
 
                deferred.notifyWith( elem, [ animation, percent, remaining ] ); 
 
                </span><span class="s2">if </span><span class="s1">( percent &lt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; length ) { 
                    </span><span class="s2">return </span><span class="s1">remaining; 
                } </span><span class="s2">else </span><span class="s1">{ 
                    deferred.resolveWith( elem, [ animation ] ); 
                    </span><span class="s2">return false</span><span class="s1">; 
                } 
            }, 
            animation = deferred.promise( { 
                elem: elem, 
                props: jQuery.extend( {}, properties ), 
                opts: jQuery.extend( </span><span class="s2">true</span><span class="s1">, { 
                    specialEasing: {}, 
                    easing: jQuery.easing._default 
                }, options ), 
                originalProperties: properties, 
                originalOptions: options, 
                startTime: fxNow || createFxNow(), 
                duration: options.duration, 
                tweens: [], 
                createTween: </span><span class="s2">function</span><span class="s1">( prop, end ) { 
                    </span><span class="s2">var </span><span class="s1">tween = jQuery.Tween( elem, animation.opts, prop, end, 
                        animation.opts.specialEasing[ prop ] || animation.opts.easing ); 
                    animation.tweens.push( tween ); 
                    </span><span class="s2">return </span><span class="s1">tween; 
                }, 
                stop: </span><span class="s2">function</span><span class="s1">( gotoEnd ) { 
                    </span><span class="s2">var </span><span class="s1">index = </span><span class="s4">0</span><span class="s1">, 
 
                    </span><span class="s0">// If we are going to the end, we want to run all the tweens</span><span class="s1"> 
                    </span><span class="s0">// otherwise we skip this part</span><span class="s1"> 
                        length = gotoEnd ? animation.tweens.length : </span><span class="s4">0</span><span class="s1">; 
                    </span><span class="s2">if </span><span class="s1">( stopped ) { 
                        </span><span class="s2">return this</span><span class="s1">; 
                    } 
                    stopped = </span><span class="s2">true</span><span class="s1">; 
                    </span><span class="s2">for </span><span class="s1">( ; index &lt; length; index++ ) { 
                        animation.tweens[ index ].run( </span><span class="s4">1 </span><span class="s1">); 
                    } 
 
                    </span><span class="s0">// Resolve when we played the last frame; otherwise, reject</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( gotoEnd ) { 
                        deferred.notifyWith( elem, [ animation, </span><span class="s4">1</span><span class="s1">, </span><span class="s4">0 </span><span class="s1">] ); 
                        deferred.resolveWith( elem, [ animation, gotoEnd ] ); 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        deferred.rejectWith( elem, [ animation, gotoEnd ] ); 
                    } 
                    </span><span class="s2">return this</span><span class="s1">; 
                } 
            } ), 
            props = animation.props; 
 
        propFilter( props, animation.opts.specialEasing ); 
 
        </span><span class="s2">for </span><span class="s1">( ; index &lt; length; index++ ) { 
            result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts ); 
            </span><span class="s2">if </span><span class="s1">( result ) { 
                </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( result.stop ) ) { 
                    jQuery._queueHooks( animation.elem, animation.opts.queue ).stop = 
                        jQuery.proxy( result.stop, result ); 
                } 
                </span><span class="s2">return </span><span class="s1">result; 
            } 
        } 
 
        jQuery.map( props, createTween, animation ); 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( animation.opts.start ) ) { 
            animation.opts.start.call( elem, animation ); 
        } 
 
        jQuery.fx.timer( 
            jQuery.extend( tick, { 
                elem: elem, 
                anim: animation, 
                queue: animation.opts.queue 
            } ) 
        ); 
 
        </span><span class="s0">// attach callbacks from options</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">animation.progress( animation.opts.progress ) 
            .done( animation.opts.done, animation.opts.complete ) 
            .fail( animation.opts.fail ) 
            .always( animation.opts.always ); 
    } 
 
    jQuery.Animation = jQuery.extend( Animation, { 
 
        tweeners: { 
            </span><span class="s3">&quot;*&quot;</span><span class="s1">: [ </span><span class="s2">function</span><span class="s1">( prop, value ) { 
                </span><span class="s2">var </span><span class="s1">tween = </span><span class="s2">this</span><span class="s1">.createTween( prop, value ); 
                adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween ); 
                </span><span class="s2">return </span><span class="s1">tween; 
            } ] 
        }, 
 
        tweener: </span><span class="s2">function</span><span class="s1">( props, callback ) { 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( props ) ) { 
                callback = props; 
                props = [ </span><span class="s3">&quot;*&quot; </span><span class="s1">]; 
            } </span><span class="s2">else </span><span class="s1">{ 
                props = props.match( rnothtmlwhite ); 
            } 
 
            </span><span class="s2">var </span><span class="s1">prop, 
                index = </span><span class="s4">0</span><span class="s1">, 
                length = props.length; 
 
            </span><span class="s2">for </span><span class="s1">( ; index &lt; length; index++ ) { 
                prop = props[ index ]; 
                Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || []; 
                Animation.tweeners[ prop ].unshift( callback ); 
            } 
        }, 
 
        prefilters: [ defaultPrefilter ], 
 
        prefilter: </span><span class="s2">function</span><span class="s1">( callback, prepend ) { 
            </span><span class="s2">if </span><span class="s1">( prepend ) { 
                Animation.prefilters.unshift( callback ); 
            } </span><span class="s2">else </span><span class="s1">{ 
                Animation.prefilters.push( callback ); 
            } 
        } 
    } ); 
 
    jQuery.speed = </span><span class="s2">function</span><span class="s1">( speed, easing, fn ) { 
        </span><span class="s2">var </span><span class="s1">opt = speed &amp;&amp; </span><span class="s2">typeof </span><span class="s1">speed === </span><span class="s3">&quot;object&quot; </span><span class="s1">? jQuery.extend( {}, speed ) : { 
            complete: fn || !fn &amp;&amp; easing || 
            jQuery.isFunction( speed ) &amp;&amp; speed, 
            duration: speed, 
            easing: fn &amp;&amp; easing || easing &amp;&amp; !jQuery.isFunction( easing ) &amp;&amp; easing 
        }; 
 
        </span><span class="s0">// Go to the end state if fx are off or if document is hidden</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.fx.off || document.hidden ) { 
            opt.duration = </span><span class="s4">0</span><span class="s1">; 
 
        } </span><span class="s2">else </span><span class="s1">{ 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">opt.duration !== </span><span class="s3">&quot;number&quot; </span><span class="s1">) { 
                </span><span class="s2">if </span><span class="s1">( opt.duration </span><span class="s2">in </span><span class="s1">jQuery.fx.speeds ) { 
                    opt.duration = jQuery.fx.speeds[ opt.duration ]; 
 
                } </span><span class="s2">else </span><span class="s1">{ 
                    opt.duration = jQuery.fx.speeds._default; 
                } 
            } 
        } 
 
        </span><span class="s0">// Normalize opt.queue - true/undefined/null -&gt; &quot;fx&quot;</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( opt.queue == </span><span class="s2">null </span><span class="s1">|| opt.queue === </span><span class="s2">true </span><span class="s1">) { 
            opt.queue = </span><span class="s3">&quot;fx&quot;</span><span class="s1">; 
        } 
 
        </span><span class="s0">// Queueing</span><span class="s1"> 
        opt.old = opt.complete; 
 
        opt.complete = </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( opt.old ) ) { 
                opt.old.call( </span><span class="s2">this </span><span class="s1">); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( opt.queue ) { 
                jQuery.dequeue( </span><span class="s2">this</span><span class="s1">, opt.queue ); 
            } 
        }; 
 
        </span><span class="s2">return </span><span class="s1">opt; 
    }; 
 
    jQuery.fn.extend( { 
        fadeTo: </span><span class="s2">function</span><span class="s1">( speed, to, easing, callback ) { 
 
            </span><span class="s0">// Show any hidden elements after setting opacity to 0</span><span class="s1"> 
            </span><span class="s2">return this</span><span class="s1">.filter( isHiddenWithinTree ).css( </span><span class="s3">&quot;opacity&quot;</span><span class="s1">, </span><span class="s4">0 </span><span class="s1">).show() 
 
                </span><span class="s0">// Animate to the value specified</span><span class="s1"> 
                .end().animate( { opacity: to }, speed, easing, callback ); 
        }, 
        animate: </span><span class="s2">function</span><span class="s1">( prop, speed, easing, callback ) { 
            </span><span class="s2">var </span><span class="s1">empty = jQuery.isEmptyObject( prop ), 
                optall = jQuery.speed( speed, easing, callback ), 
                doAnimation = </span><span class="s2">function</span><span class="s1">() { 
 
                    </span><span class="s0">// Operate on a copy of prop so per-property easing won't be lost</span><span class="s1"> 
                    </span><span class="s2">var </span><span class="s1">anim = Animation( </span><span class="s2">this</span><span class="s1">, jQuery.extend( {}, prop ), optall ); 
 
                    </span><span class="s0">// Empty animations, or finishing resolves immediately</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( empty || dataPriv.get( </span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;finish&quot; </span><span class="s1">) ) { 
                        anim.stop( </span><span class="s2">true </span><span class="s1">); 
                    } 
                }; 
            doAnimation.finish = doAnimation; 
 
            </span><span class="s2">return </span><span class="s1">empty || optall.queue === </span><span class="s2">false </span><span class="s1">? 
                </span><span class="s2">this</span><span class="s1">.each( doAnimation ) : 
                </span><span class="s2">this</span><span class="s1">.queue( optall.queue, doAnimation ); 
        }, 
        stop: </span><span class="s2">function</span><span class="s1">( type, clearQueue, gotoEnd ) { 
            </span><span class="s2">var </span><span class="s1">stopQueue = </span><span class="s2">function</span><span class="s1">( hooks ) { 
                </span><span class="s2">var </span><span class="s1">stop = hooks.stop; 
                </span><span class="s2">delete </span><span class="s1">hooks.stop; 
                stop( gotoEnd ); 
            }; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">type !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                gotoEnd = clearQueue; 
                clearQueue = type; 
                type = undefined; 
            } 
            </span><span class="s2">if </span><span class="s1">( clearQueue &amp;&amp; type !== </span><span class="s2">false </span><span class="s1">) { 
                </span><span class="s2">this</span><span class="s1">.queue( type || </span><span class="s3">&quot;fx&quot;</span><span class="s1">, [] ); 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">dequeue = </span><span class="s2">true</span><span class="s1">, 
                    index = type != </span><span class="s2">null </span><span class="s1">&amp;&amp; type + </span><span class="s3">&quot;queueHooks&quot;</span><span class="s1">, 
                    timers = jQuery.timers, 
                    data = dataPriv.get( </span><span class="s2">this </span><span class="s1">); 
 
                </span><span class="s2">if </span><span class="s1">( index ) { 
                    </span><span class="s2">if </span><span class="s1">( data[ index ] &amp;&amp; data[ index ].stop ) { 
                        stopQueue( data[ index ] ); 
                    } 
                } </span><span class="s2">else </span><span class="s1">{ 
                    </span><span class="s2">for </span><span class="s1">( index </span><span class="s2">in </span><span class="s1">data ) { 
                        </span><span class="s2">if </span><span class="s1">( data[ index ] &amp;&amp; data[ index ].stop &amp;&amp; rrun.test( index ) ) { 
                            stopQueue( data[ index ] ); 
                        } 
                    } 
                } 
 
                </span><span class="s2">for </span><span class="s1">( index = timers.length; index--; ) { 
                    </span><span class="s2">if </span><span class="s1">( timers[ index ].elem === </span><span class="s2">this </span><span class="s1">&amp;&amp; 
                        ( type == </span><span class="s2">null </span><span class="s1">|| timers[ index ].queue === type ) ) { 
 
                        timers[ index ].anim.stop( gotoEnd ); 
                        dequeue = </span><span class="s2">false</span><span class="s1">; 
                        timers.splice( index, </span><span class="s4">1 </span><span class="s1">); 
                    } 
                } 
 
                </span><span class="s0">// Start the next in the queue if the last step wasn't forced.</span><span class="s1"> 
                </span><span class="s0">// Timers currently will call their complete callbacks, which</span><span class="s1"> 
                </span><span class="s0">// will dequeue but only if they were gotoEnd.</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( dequeue || !gotoEnd ) { 
                    jQuery.dequeue( </span><span class="s2">this</span><span class="s1">, type ); 
                } 
            } ); 
        }, 
        finish: </span><span class="s2">function</span><span class="s1">( type ) { 
            </span><span class="s2">if </span><span class="s1">( type !== </span><span class="s2">false </span><span class="s1">) { 
                type = type || </span><span class="s3">&quot;fx&quot;</span><span class="s1">; 
            } 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">index, 
                    data = dataPriv.get( </span><span class="s2">this </span><span class="s1">), 
                    queue = data[ type + </span><span class="s3">&quot;queue&quot; </span><span class="s1">], 
                    hooks = data[ type + </span><span class="s3">&quot;queueHooks&quot; </span><span class="s1">], 
                    timers = jQuery.timers, 
                    length = queue ? queue.length : </span><span class="s4">0</span><span class="s1">; 
 
                </span><span class="s0">// Enable finishing flag on private data</span><span class="s1"> 
                data.finish = </span><span class="s2">true</span><span class="s1">; 
 
                </span><span class="s0">// Empty the queue first</span><span class="s1"> 
                jQuery.queue( </span><span class="s2">this</span><span class="s1">, type, [] ); 
 
                </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; hooks.stop ) { 
                    hooks.stop.call( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">true </span><span class="s1">); 
                } 
 
                </span><span class="s0">// Look for any active animations, and finish them</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( index = timers.length; index--; ) { 
                    </span><span class="s2">if </span><span class="s1">( timers[ index ].elem === </span><span class="s2">this </span><span class="s1">&amp;&amp; timers[ index ].queue === type ) { 
                        timers[ index ].anim.stop( </span><span class="s2">true </span><span class="s1">); 
                        timers.splice( index, </span><span class="s4">1 </span><span class="s1">); 
                    } 
                } 
 
                </span><span class="s0">// Look for any animations in the old queue and finish them</span><span class="s1"> 
                </span><span class="s2">for </span><span class="s1">( index = </span><span class="s4">0</span><span class="s1">; index &lt; length; index++ ) { 
                    </span><span class="s2">if </span><span class="s1">( queue[ index ] &amp;&amp; queue[ index ].finish ) { 
                        queue[ index ].finish.call( </span><span class="s2">this </span><span class="s1">); 
                    } 
                } 
 
                </span><span class="s0">// Turn off finishing flag</span><span class="s1"> 
                </span><span class="s2">delete </span><span class="s1">data.finish; 
            } ); 
        } 
    } ); 
 
    jQuery.each( [ </span><span class="s3">&quot;toggle&quot;</span><span class="s1">, </span><span class="s3">&quot;show&quot;</span><span class="s1">, </span><span class="s3">&quot;hide&quot; </span><span class="s1">], </span><span class="s2">function</span><span class="s1">( i, name ) { 
        </span><span class="s2">var </span><span class="s1">cssFn = jQuery.fn[ name ]; 
        jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( speed, easing, callback ) { 
            </span><span class="s2">return </span><span class="s1">speed == </span><span class="s2">null </span><span class="s1">|| </span><span class="s2">typeof </span><span class="s1">speed === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">? 
                cssFn.apply( </span><span class="s2">this</span><span class="s1">, arguments ) : 
                </span><span class="s2">this</span><span class="s1">.animate( genFx( name, </span><span class="s2">true </span><span class="s1">), speed, easing, callback ); 
        }; 
    } ); 
 
</span><span class="s0">// Generate shortcuts for custom animations</span><span class="s1"> 
    jQuery.each( { 
        slideDown: genFx( </span><span class="s3">&quot;show&quot; </span><span class="s1">), 
        slideUp: genFx( </span><span class="s3">&quot;hide&quot; </span><span class="s1">), 
        slideToggle: genFx( </span><span class="s3">&quot;toggle&quot; </span><span class="s1">), 
        fadeIn: { opacity: </span><span class="s3">&quot;show&quot; </span><span class="s1">}, 
        fadeOut: { opacity: </span><span class="s3">&quot;hide&quot; </span><span class="s1">}, 
        fadeToggle: { opacity: </span><span class="s3">&quot;toggle&quot; </span><span class="s1">} 
    }, </span><span class="s2">function</span><span class="s1">( name, props ) { 
        jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( speed, easing, callback ) { 
            </span><span class="s2">return this</span><span class="s1">.animate( props, speed, easing, callback ); 
        }; 
    } ); 
 
    jQuery.timers = []; 
    jQuery.fx.tick = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">timer, 
            i = </span><span class="s4">0</span><span class="s1">, 
            timers = jQuery.timers; 
 
        fxNow = jQuery.now(); 
 
        </span><span class="s2">for </span><span class="s1">( ; i &lt; timers.length; i++ ) { 
            timer = timers[ i ]; 
 
            </span><span class="s0">// Checks the timer has not already been removed</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !timer() &amp;&amp; timers[ i ] === timer ) { 
                timers.splice( i--, </span><span class="s4">1 </span><span class="s1">); 
            } 
        } 
 
        </span><span class="s2">if </span><span class="s1">( !timers.length ) { 
            jQuery.fx.stop(); 
        } 
        fxNow = undefined; 
    }; 
 
    jQuery.fx.timer = </span><span class="s2">function</span><span class="s1">( timer ) { 
        jQuery.timers.push( timer ); 
        </span><span class="s2">if </span><span class="s1">( timer() ) { 
            jQuery.fx.start(); 
        } </span><span class="s2">else </span><span class="s1">{ 
            jQuery.timers.pop(); 
        } 
    }; 
 
    jQuery.fx.interval = </span><span class="s4">13</span><span class="s1">; 
    jQuery.fx.start = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">if </span><span class="s1">( !timerId ) { 
            timerId = window.requestAnimationFrame ? 
                window.requestAnimationFrame( raf ) : 
                window.setInterval( jQuery.fx.tick, jQuery.fx.interval ); 
        } 
    }; 
 
    jQuery.fx.stop = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">if </span><span class="s1">( window.cancelAnimationFrame ) { 
            window.cancelAnimationFrame( timerId ); 
        } </span><span class="s2">else </span><span class="s1">{ 
            window.clearInterval( timerId ); 
        } 
 
        timerId = </span><span class="s2">null</span><span class="s1">; 
    }; 
 
    jQuery.fx.speeds = { 
        slow: </span><span class="s4">600</span><span class="s1">, 
        fast: </span><span class="s4">200</span><span class="s1">, 
 
        </span><span class="s0">// Default speed</span><span class="s1"> 
        _default: </span><span class="s4">400</span><span class="s1"> 
    }; 
 
 
</span><span class="s0">// Based off of the plugin by Clint Helfers, with permission.</span><span class="s1"> 
</span><span class="s0">// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/</span><span class="s1"> 
    jQuery.fn.delay = </span><span class="s2">function</span><span class="s1">( time, type ) { 
        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time; 
        type = type || </span><span class="s3">&quot;fx&quot;</span><span class="s1">; 
 
        </span><span class="s2">return this</span><span class="s1">.queue( type, </span><span class="s2">function</span><span class="s1">( next, hooks ) { 
            </span><span class="s2">var </span><span class="s1">timeout = window.setTimeout( next, time ); 
            hooks.stop = </span><span class="s2">function</span><span class="s1">() { 
                window.clearTimeout( timeout ); 
            }; 
        } ); 
    }; 
 
 
    ( </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">input = document.createElement( </span><span class="s3">&quot;input&quot; </span><span class="s1">), 
            select = document.createElement( </span><span class="s3">&quot;select&quot; </span><span class="s1">), 
            opt = select.appendChild( document.createElement( </span><span class="s3">&quot;option&quot; </span><span class="s1">) ); 
 
        input.type = </span><span class="s3">&quot;checkbox&quot;</span><span class="s1">; 
 
        </span><span class="s0">// Support: Android &lt;=4.3 only</span><span class="s1"> 
        </span><span class="s0">// Default value for a checkbox should be &quot;on&quot;</span><span class="s1"> 
        support.checkOn = input.value !== </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
        </span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
        </span><span class="s0">// Must access selectedIndex to make default options select</span><span class="s1"> 
        support.optSelected = opt.selected; 
 
        </span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
        </span><span class="s0">// An input loses its value after becoming a radio</span><span class="s1"> 
        input = document.createElement( </span><span class="s3">&quot;input&quot; </span><span class="s1">); 
        input.value = </span><span class="s3">&quot;t&quot;</span><span class="s1">; 
        input.type = </span><span class="s3">&quot;radio&quot;</span><span class="s1">; 
        support.radioValue = input.value === </span><span class="s3">&quot;t&quot;</span><span class="s1">; 
    } )(); 
 
 
    </span><span class="s2">var </span><span class="s1">boolHook, 
        attrHandle = jQuery.expr.attrHandle; 
 
    jQuery.fn.extend( { 
        attr: </span><span class="s2">function</span><span class="s1">( name, value ) { 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, jQuery.attr, name, value, arguments.length &gt; </span><span class="s4">1 </span><span class="s1">); 
        }, 
 
        removeAttr: </span><span class="s2">function</span><span class="s1">( name ) { 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                jQuery.removeAttr( </span><span class="s2">this</span><span class="s1">, name ); 
            } ); 
        } 
    } ); 
 
    jQuery.extend( { 
        attr: </span><span class="s2">function</span><span class="s1">( elem, name, value ) { 
            </span><span class="s2">var </span><span class="s1">ret, hooks, 
                nType = elem.nodeType; 
 
            </span><span class="s0">// Don't get/set attributes on text, comment and attribute nodes</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( nType === </span><span class="s4">3 </span><span class="s1">|| nType === </span><span class="s4">8 </span><span class="s1">|| nType === </span><span class="s4">2 </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Fallback to prop when attributes are not supported</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">elem.getAttribute === </span><span class="s3">&quot;undefined&quot; </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">jQuery.prop( elem, name, value ); 
            } 
 
            </span><span class="s0">// Attribute hooks are determined by the lowercase version</span><span class="s1"> 
            </span><span class="s0">// Grab necessary hook if one is defined</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( nType !== </span><span class="s4">1 </span><span class="s1">|| !jQuery.isXMLDoc( elem ) ) { 
                hooks = jQuery.attrHooks[ name.toLowerCase() ] || 
                    ( jQuery.expr.match.bool.test( name ) ? boolHook : undefined ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( value !== undefined ) { 
                </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">null </span><span class="s1">) { 
                    jQuery.removeAttr( elem, name ); 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
 
                </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; 
                    ( ret = hooks.set( elem, value, name ) ) !== undefined ) { 
                    </span><span class="s2">return </span><span class="s1">ret; 
                } 
 
                elem.setAttribute( name, value + </span><span class="s3">&quot;&quot; </span><span class="s1">); 
                </span><span class="s2">return </span><span class="s1">value; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">ret; 
            } 
 
            ret = jQuery.find.attr( elem, name ); 
 
            </span><span class="s0">// Non-existent attributes return null, we normalize to undefined</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">ret == </span><span class="s2">null </span><span class="s1">? undefined : ret; 
        }, 
 
        attrHooks: { 
            type: { 
                </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, value ) { 
                    </span><span class="s2">if </span><span class="s1">( !support.radioValue &amp;&amp; value === </span><span class="s3">&quot;radio&quot; </span><span class="s1">&amp;&amp; 
                        jQuery.nodeName( elem, </span><span class="s3">&quot;input&quot; </span><span class="s1">) ) { 
                        </span><span class="s2">var </span><span class="s1">val = elem.value; 
                        elem.setAttribute( </span><span class="s3">&quot;type&quot;</span><span class="s1">, value ); 
                        </span><span class="s2">if </span><span class="s1">( val ) { 
                            elem.value = val; 
                        } 
                        </span><span class="s2">return </span><span class="s1">value; 
                    } 
                } 
            } 
        }, 
 
        removeAttr: </span><span class="s2">function</span><span class="s1">( elem, value ) { 
            </span><span class="s2">var </span><span class="s1">name, 
                i = </span><span class="s4">0</span><span class="s1">, 
 
            </span><span class="s0">// Attribute names can contain non-HTML whitespace characters</span><span class="s1"> 
            </span><span class="s0">// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2</span><span class="s1"> 
                attrNames = value &amp;&amp; value.match( rnothtmlwhite ); 
 
            </span><span class="s2">if </span><span class="s1">( attrNames &amp;&amp; elem.nodeType === </span><span class="s4">1 </span><span class="s1">) { 
                </span><span class="s2">while </span><span class="s1">( ( name = attrNames[ i++ ] ) ) { 
                    elem.removeAttribute( name ); 
                } 
            } 
        } 
    } ); 
 
</span><span class="s0">// Hooks for boolean attributes</span><span class="s1"> 
    boolHook = { 
        </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, value, name ) { 
            </span><span class="s2">if </span><span class="s1">( value === </span><span class="s2">false </span><span class="s1">) { 
 
                </span><span class="s0">// Remove boolean attributes when set to false</span><span class="s1"> 
                jQuery.removeAttr( elem, name ); 
            } </span><span class="s2">else </span><span class="s1">{ 
                elem.setAttribute( name, name ); 
            } 
            </span><span class="s2">return </span><span class="s1">name; 
        } 
    }; 
 
    jQuery.each( jQuery.expr.match.bool.source.match( </span><span class="s4">/\w+/g </span><span class="s1">), </span><span class="s2">function</span><span class="s1">( i, name ) { 
        </span><span class="s2">var </span><span class="s1">getter = attrHandle[ name ] || jQuery.find.attr; 
 
        attrHandle[ name ] = </span><span class="s2">function</span><span class="s1">( elem, name, isXML ) { 
            </span><span class="s2">var </span><span class="s1">ret, handle, 
                lowercaseName = name.toLowerCase(); 
 
            </span><span class="s2">if </span><span class="s1">( !isXML ) { 
 
                </span><span class="s0">// Avoid an infinite loop by temporarily removing this function from the getter</span><span class="s1"> 
                handle = attrHandle[ lowercaseName ]; 
                attrHandle[ lowercaseName ] = ret; 
                ret = getter( elem, name, isXML ) != </span><span class="s2">null </span><span class="s1">? 
                    lowercaseName : 
                    </span><span class="s2">null</span><span class="s1">; 
                attrHandle[ lowercaseName ] = handle; 
            } 
            </span><span class="s2">return </span><span class="s1">ret; 
        }; 
    } ); 
 
 
 
 
    </span><span class="s2">var </span><span class="s1">rfocusable = </span><span class="s4">/^(?:input|select|textarea|button)$/i</span><span class="s1">, 
        rclickable = </span><span class="s4">/^(?:a|area)$/i</span><span class="s1">; 
 
    jQuery.fn.extend( { 
        prop: </span><span class="s2">function</span><span class="s1">( name, value ) { 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, jQuery.prop, name, value, arguments.length &gt; </span><span class="s4">1 </span><span class="s1">); 
        }, 
 
        removeProp: </span><span class="s2">function</span><span class="s1">( name ) { 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">delete this</span><span class="s1">[ jQuery.propFix[ name ] || name ]; 
            } ); 
        } 
    } ); 
 
    jQuery.extend( { 
        prop: </span><span class="s2">function</span><span class="s1">( elem, name, value ) { 
            </span><span class="s2">var </span><span class="s1">ret, hooks, 
                nType = elem.nodeType; 
 
            </span><span class="s0">// Don't get/set properties on text, comment and attribute nodes</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( nType === </span><span class="s4">3 </span><span class="s1">|| nType === </span><span class="s4">8 </span><span class="s1">|| nType === </span><span class="s4">2 </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( nType !== </span><span class="s4">1 </span><span class="s1">|| !jQuery.isXMLDoc( elem ) ) { 
 
                </span><span class="s0">// Fix name and attach hooks</span><span class="s1"> 
                name = jQuery.propFix[ name ] || name; 
                hooks = jQuery.propHooks[ name ]; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( value !== undefined ) { 
                </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; 
                    ( ret = hooks.set( elem, value, name ) ) !== undefined ) { 
                    </span><span class="s2">return </span><span class="s1">ret; 
                } 
 
                </span><span class="s2">return </span><span class="s1">( elem[ name ] = value ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; </span><span class="s3">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; ( ret = hooks.get( elem, name ) ) !== </span><span class="s2">null </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">ret; 
            } 
 
            </span><span class="s2">return </span><span class="s1">elem[ name ]; 
        }, 
 
        propHooks: { 
            tabIndex: { 
                </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
 
                    </span><span class="s0">// Support: IE &lt;=9 - 11 only</span><span class="s1"> 
                    </span><span class="s0">// elem.tabIndex doesn't always return the</span><span class="s1"> 
                    </span><span class="s0">// correct value when it hasn't been explicitly set</span><span class="s1"> 
                    </span><span class="s0">// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/</span><span class="s1"> 
                    </span><span class="s0">// Use proper attribute retrieval(#12072)</span><span class="s1"> 
                    </span><span class="s2">var </span><span class="s1">tabindex = jQuery.find.attr( elem, </span><span class="s3">&quot;tabindex&quot; </span><span class="s1">); 
 
                    </span><span class="s2">if </span><span class="s1">( tabindex ) { 
                        </span><span class="s2">return </span><span class="s1">parseInt( tabindex, </span><span class="s4">10 </span><span class="s1">); 
                    } 
 
                    </span><span class="s2">if </span><span class="s1">( 
                        rfocusable.test( elem.nodeName ) || 
                        rclickable.test( elem.nodeName ) &amp;&amp; 
                        elem.href 
                    ) { 
                        </span><span class="s2">return </span><span class="s4">0</span><span class="s1">; 
                    } 
 
                    </span><span class="s2">return </span><span class="s1">-</span><span class="s4">1</span><span class="s1">; 
                } 
            } 
        }, 
 
        propFix: { 
            </span><span class="s3">&quot;for&quot;</span><span class="s1">: </span><span class="s3">&quot;htmlFor&quot;</span><span class="s1">, 
            </span><span class="s3">&quot;class&quot;</span><span class="s1">: </span><span class="s3">&quot;className&quot;</span><span class="s1"> 
        } 
    } ); 
 
</span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
</span><span class="s0">// Accessing the selectedIndex property</span><span class="s1"> 
</span><span class="s0">// forces the browser to respect setting selected</span><span class="s1"> 
</span><span class="s0">// on the option</span><span class="s1"> 
</span><span class="s0">// The getter ensures a default option is selected</span><span class="s1"> 
</span><span class="s0">// when in an optgroup</span><span class="s1"> 
</span><span class="s0">// eslint rule &quot;no-unused-expressions&quot; is disabled for this code</span><span class="s1"> 
</span><span class="s0">// since it considers such accessions noop</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !support.optSelected ) { 
        jQuery.propHooks.selected = { 
            </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
 
                </span><span class="s0">/* eslint no-unused-expressions: &quot;off&quot; */</span><span class="s1"> 
 
                </span><span class="s2">var </span><span class="s1">parent = elem.parentNode; 
                </span><span class="s2">if </span><span class="s1">( parent &amp;&amp; parent.parentNode ) { 
                    parent.parentNode.selectedIndex; 
                } 
                </span><span class="s2">return null</span><span class="s1">; 
            }, 
            </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
 
                </span><span class="s0">/* eslint no-unused-expressions: &quot;off&quot; */</span><span class="s1"> 
 
                </span><span class="s2">var </span><span class="s1">parent = elem.parentNode; 
                </span><span class="s2">if </span><span class="s1">( parent ) { 
                    parent.selectedIndex; 
 
                    </span><span class="s2">if </span><span class="s1">( parent.parentNode ) { 
                        parent.parentNode.selectedIndex; 
                    } 
                } 
            } 
        }; 
    } 
 
    jQuery.each( [ 
        </span><span class="s3">&quot;tabIndex&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;readOnly&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;maxLength&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;cellSpacing&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;cellPadding&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;rowSpan&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;colSpan&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;useMap&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;frameBorder&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;contentEditable&quot;</span><span class="s1"> 
    ], </span><span class="s2">function</span><span class="s1">() { 
        jQuery.propFix[ </span><span class="s2">this</span><span class="s1">.toLowerCase() ] = </span><span class="s2">this</span><span class="s1">; 
    } ); 
 
 
 
 
    </span><span class="s0">// Strip and collapse whitespace according to HTML spec</span><span class="s1"> 
    </span><span class="s0">// https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">stripAndCollapse( value ) { 
        </span><span class="s2">var </span><span class="s1">tokens = value.match( rnothtmlwhite ) || []; 
        </span><span class="s2">return </span><span class="s1">tokens.join( </span><span class="s3">&quot; &quot; </span><span class="s1">); 
    } 
 
 
    </span><span class="s2">function </span><span class="s1">getClass( elem ) { 
        </span><span class="s2">return </span><span class="s1">elem.getAttribute &amp;&amp; elem.getAttribute( </span><span class="s3">&quot;class&quot; </span><span class="s1">) || </span><span class="s3">&quot;&quot;</span><span class="s1">; 
    } 
 
    jQuery.fn.extend( { 
        addClass: </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">var </span><span class="s1">classes, elem, cur, curValue, clazz, j, finalValue, 
                i = </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( value ) ) { 
                </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( j ) { 
                    jQuery( </span><span class="s2">this </span><span class="s1">).addClass( value.call( </span><span class="s2">this</span><span class="s1">, j, getClass( </span><span class="s2">this </span><span class="s1">) ) ); 
                } ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; value ) { 
                classes = value.match( rnothtmlwhite ) || []; 
 
                </span><span class="s2">while </span><span class="s1">( ( elem = </span><span class="s2">this</span><span class="s1">[ i++ ] ) ) { 
                    curValue = getClass( elem ); 
                    cur = elem.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; ( </span><span class="s3">&quot; &quot; </span><span class="s1">+ stripAndCollapse( curValue ) + </span><span class="s3">&quot; &quot; </span><span class="s1">); 
 
                    </span><span class="s2">if </span><span class="s1">( cur ) { 
                        j = </span><span class="s4">0</span><span class="s1">; 
                        </span><span class="s2">while </span><span class="s1">( ( clazz = classes[ j++ ] ) ) { 
                            </span><span class="s2">if </span><span class="s1">( cur.indexOf( </span><span class="s3">&quot; &quot; </span><span class="s1">+ clazz + </span><span class="s3">&quot; &quot; </span><span class="s1">) &lt; </span><span class="s4">0 </span><span class="s1">) { 
                                cur += clazz + </span><span class="s3">&quot; &quot;</span><span class="s1">; 
                            } 
                        } 
 
                        </span><span class="s0">// Only assign if different to avoid unneeded rendering.</span><span class="s1"> 
                        finalValue = stripAndCollapse( cur ); 
                        </span><span class="s2">if </span><span class="s1">( curValue !== finalValue ) { 
                            elem.setAttribute( </span><span class="s3">&quot;class&quot;</span><span class="s1">, finalValue ); 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s2">return this</span><span class="s1">; 
        }, 
 
        removeClass: </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">var </span><span class="s1">classes, elem, cur, curValue, clazz, j, finalValue, 
                i = </span><span class="s4">0</span><span class="s1">; 
 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( value ) ) { 
                </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( j ) { 
                    jQuery( </span><span class="s2">this </span><span class="s1">).removeClass( value.call( </span><span class="s2">this</span><span class="s1">, j, getClass( </span><span class="s2">this </span><span class="s1">) ) ); 
                } ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( !arguments.length ) { 
                </span><span class="s2">return this</span><span class="s1">.attr( </span><span class="s3">&quot;class&quot;</span><span class="s1">, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">value === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; value ) { 
                classes = value.match( rnothtmlwhite ) || []; 
 
                </span><span class="s2">while </span><span class="s1">( ( elem = </span><span class="s2">this</span><span class="s1">[ i++ ] ) ) { 
                    curValue = getClass( elem ); 
 
                    </span><span class="s0">// This expression is here for better compressibility (see addClass)</span><span class="s1"> 
                    cur = elem.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; ( </span><span class="s3">&quot; &quot; </span><span class="s1">+ stripAndCollapse( curValue ) + </span><span class="s3">&quot; &quot; </span><span class="s1">); 
 
                    </span><span class="s2">if </span><span class="s1">( cur ) { 
                        j = </span><span class="s4">0</span><span class="s1">; 
                        </span><span class="s2">while </span><span class="s1">( ( clazz = classes[ j++ ] ) ) { 
 
                            </span><span class="s0">// Remove *all* instances</span><span class="s1"> 
                            </span><span class="s2">while </span><span class="s1">( cur.indexOf( </span><span class="s3">&quot; &quot; </span><span class="s1">+ clazz + </span><span class="s3">&quot; &quot; </span><span class="s1">) &gt; -</span><span class="s4">1 </span><span class="s1">) { 
                                cur = cur.replace( </span><span class="s3">&quot; &quot; </span><span class="s1">+ clazz + </span><span class="s3">&quot; &quot;</span><span class="s1">, </span><span class="s3">&quot; &quot; </span><span class="s1">); 
                            } 
                        } 
 
                        </span><span class="s0">// Only assign if different to avoid unneeded rendering.</span><span class="s1"> 
                        finalValue = stripAndCollapse( cur ); 
                        </span><span class="s2">if </span><span class="s1">( curValue !== finalValue ) { 
                            elem.setAttribute( </span><span class="s3">&quot;class&quot;</span><span class="s1">, finalValue ); 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s2">return this</span><span class="s1">; 
        }, 
 
        toggleClass: </span><span class="s2">function</span><span class="s1">( value, stateVal ) { 
            </span><span class="s2">var </span><span class="s1">type = </span><span class="s2">typeof </span><span class="s1">value; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">stateVal === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">&amp;&amp; type === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                </span><span class="s2">return </span><span class="s1">stateVal ? </span><span class="s2">this</span><span class="s1">.addClass( value ) : </span><span class="s2">this</span><span class="s1">.removeClass( value ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( value ) ) { 
                </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( i ) { 
                    jQuery( </span><span class="s2">this </span><span class="s1">).toggleClass( 
                        value.call( </span><span class="s2">this</span><span class="s1">, i, getClass( </span><span class="s2">this </span><span class="s1">), stateVal ), 
                        stateVal 
                    ); 
                } ); 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">className, i, self, classNames; 
 
                </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
 
                    </span><span class="s0">// Toggle individual class names</span><span class="s1"> 
                    i = </span><span class="s4">0</span><span class="s1">; 
                    self = jQuery( </span><span class="s2">this </span><span class="s1">); 
                    classNames = value.match( rnothtmlwhite ) || []; 
 
                    </span><span class="s2">while </span><span class="s1">( ( className = classNames[ i++ ] ) ) { 
 
                        </span><span class="s0">// Check each className given, space separated list</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( self.hasClass( className ) ) { 
                            self.removeClass( className ); 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            self.addClass( className ); 
                        } 
                    } 
 
                    </span><span class="s0">// Toggle whole class name</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( value === undefined || type === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">) { 
                    className = getClass( </span><span class="s2">this </span><span class="s1">); 
                    </span><span class="s2">if </span><span class="s1">( className ) { 
 
                        </span><span class="s0">// Store className if set</span><span class="s1"> 
                        dataPriv.set( </span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;__className__&quot;</span><span class="s1">, className ); 
                    } 
 
                    </span><span class="s0">// If the element has a class name or if we're passed `false`,</span><span class="s1"> 
                    </span><span class="s0">// then remove the whole classname (if there was one, the above saved it).</span><span class="s1"> 
                    </span><span class="s0">// Otherwise bring back whatever was previously saved (if anything),</span><span class="s1"> 
                    </span><span class="s0">// falling back to the empty string if nothing was stored.</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.setAttribute ) { 
                        </span><span class="s2">this</span><span class="s1">.setAttribute( </span><span class="s3">&quot;class&quot;</span><span class="s1">, 
                            className || value === </span><span class="s2">false </span><span class="s1">? 
                                </span><span class="s3">&quot;&quot; </span><span class="s1">: 
                            dataPriv.get( </span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;__className__&quot; </span><span class="s1">) || </span><span class="s3">&quot;&quot;</span><span class="s1"> 
                        ); 
                    } 
                } 
            } ); 
        }, 
 
        hasClass: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">var </span><span class="s1">className, elem, 
                i = </span><span class="s4">0</span><span class="s1">; 
 
            className = </span><span class="s3">&quot; &quot; </span><span class="s1">+ selector + </span><span class="s3">&quot; &quot;</span><span class="s1">; 
            </span><span class="s2">while </span><span class="s1">( ( elem = </span><span class="s2">this</span><span class="s1">[ i++ ] ) ) { 
                </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">1 </span><span class="s1">&amp;&amp; 
                    ( </span><span class="s3">&quot; &quot; </span><span class="s1">+ stripAndCollapse( getClass( elem ) ) + </span><span class="s3">&quot; &quot; </span><span class="s1">).indexOf( className ) &gt; -</span><span class="s4">1 </span><span class="s1">) { 
                    </span><span class="s2">return true</span><span class="s1">; 
                } 
            } 
 
            </span><span class="s2">return false</span><span class="s1">; 
        } 
    } ); 
 
 
 
 
    </span><span class="s2">var </span><span class="s1">rreturn = </span><span class="s4">/\r/g</span><span class="s1">; 
 
    jQuery.fn.extend( { 
        val: </span><span class="s2">function</span><span class="s1">( value ) { 
            </span><span class="s2">var </span><span class="s1">hooks, ret, isFunction, 
                elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">]; 
 
            </span><span class="s2">if </span><span class="s1">( !arguments.length ) { 
                </span><span class="s2">if </span><span class="s1">( elem ) { 
                    hooks = jQuery.valHooks[ elem.type ] || 
                        jQuery.valHooks[ elem.nodeName.toLowerCase() ]; 
 
                    </span><span class="s2">if </span><span class="s1">( hooks &amp;&amp; 
                        </span><span class="s3">&quot;get&quot; </span><span class="s2">in </span><span class="s1">hooks &amp;&amp; 
                        ( ret = hooks.get( elem, </span><span class="s3">&quot;value&quot; </span><span class="s1">) ) !== undefined 
                    ) { 
                        </span><span class="s2">return </span><span class="s1">ret; 
                    } 
 
                    ret = elem.value; 
 
                    </span><span class="s0">// Handle most common string cases</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">ret === </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                        </span><span class="s2">return </span><span class="s1">ret.replace( rreturn, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
                    } 
 
                    </span><span class="s0">// Handle cases where value is null/undef or number</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">ret == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: ret; 
                } 
 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            isFunction = jQuery.isFunction( value ); 
 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( i ) { 
                </span><span class="s2">var </span><span class="s1">val; 
 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">.nodeType !== </span><span class="s4">1 </span><span class="s1">) { 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
 
                </span><span class="s2">if </span><span class="s1">( isFunction ) { 
                    val = value.call( </span><span class="s2">this</span><span class="s1">, i, jQuery( </span><span class="s2">this </span><span class="s1">).val() ); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    val = value; 
                } 
 
                </span><span class="s0">// Treat null/undefined as &quot;&quot;; convert numbers to string</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( val == </span><span class="s2">null </span><span class="s1">) { 
                    val = </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
                } </span><span class="s2">else if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">val === </span><span class="s3">&quot;number&quot; </span><span class="s1">) { 
                    val += </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
                } </span><span class="s2">else if </span><span class="s1">( jQuery.isArray( val ) ) { 
                    val = jQuery.map( val, </span><span class="s2">function</span><span class="s1">( value ) { 
                        </span><span class="s2">return </span><span class="s1">value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: value + </span><span class="s3">&quot;&quot;</span><span class="s1">; 
                    } ); 
                } 
 
                hooks = jQuery.valHooks[ </span><span class="s2">this</span><span class="s1">.type ] || jQuery.valHooks[ </span><span class="s2">this</span><span class="s1">.nodeName.toLowerCase() ]; 
 
                </span><span class="s0">// If set returns undefined, fall back to normal setting</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( !hooks || !( </span><span class="s3">&quot;set&quot; </span><span class="s2">in </span><span class="s1">hooks ) || hooks.set( </span><span class="s2">this</span><span class="s1">, val, </span><span class="s3">&quot;value&quot; </span><span class="s1">) === undefined ) { 
                    </span><span class="s2">this</span><span class="s1">.value = val; 
                } 
            } ); 
        } 
    } ); 
 
    jQuery.extend( { 
        valHooks: { 
            option: { 
                </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
 
                    </span><span class="s2">var </span><span class="s1">val = jQuery.find.attr( elem, </span><span class="s3">&quot;value&quot; </span><span class="s1">); 
                    </span><span class="s2">return </span><span class="s1">val != </span><span class="s2">null </span><span class="s1">? 
                        val : 
 
                        </span><span class="s0">// Support: IE &lt;=10 - 11 only</span><span class="s1"> 
                        </span><span class="s0">// option.text throws exceptions (#14686, #14858)</span><span class="s1"> 
                        </span><span class="s0">// Strip and collapse whitespace</span><span class="s1"> 
                        </span><span class="s0">// https://html.spec.whatwg.org/#strip-and-collapse-whitespace</span><span class="s1"> 
                        stripAndCollapse( jQuery.text( elem ) ); 
                } 
            }, 
            select: { 
                </span><span class="s2">get</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem ) { 
                    </span><span class="s2">var </span><span class="s1">value, option, i, 
                        options = elem.options, 
                        index = elem.selectedIndex, 
                        one = elem.type === </span><span class="s3">&quot;select-one&quot;</span><span class="s1">, 
                        values = one ? </span><span class="s2">null </span><span class="s1">: [], 
                        max = one ? index + </span><span class="s4">1 </span><span class="s1">: options.length; 
 
                    </span><span class="s2">if </span><span class="s1">( index &lt; </span><span class="s4">0 </span><span class="s1">) { 
                        i = max; 
 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        i = one ? index : </span><span class="s4">0</span><span class="s1">; 
                    } 
 
                    </span><span class="s0">// Loop through all the selected options</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( ; i &lt; max; i++ ) { 
                        option = options[ i ]; 
 
                        </span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
                        </span><span class="s0">// IE8-9 doesn't update selected after form reset (#2551)</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( ( option.selected || i === index ) &amp;&amp; 
 
                                </span><span class="s0">// Don't return options that are disabled or in a disabled optgroup</span><span class="s1"> 
                            !option.disabled &amp;&amp; 
                            ( !option.parentNode.disabled || 
                            !jQuery.nodeName( option.parentNode, </span><span class="s3">&quot;optgroup&quot; </span><span class="s1">) ) ) { 
 
                            </span><span class="s0">// Get the specific value for the option</span><span class="s1"> 
                            value = jQuery( option ).val(); 
 
                            </span><span class="s0">// We don't need an array for one selects</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( one ) { 
                                </span><span class="s2">return </span><span class="s1">value; 
                            } 
 
                            </span><span class="s0">// Multi-Selects return an array</span><span class="s1"> 
                            values.push( value ); 
                        } 
                    } 
 
                    </span><span class="s2">return </span><span class="s1">values; 
                }, 
 
                </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, value ) { 
                    </span><span class="s2">var </span><span class="s1">optionSet, option, 
                        options = elem.options, 
                        values = jQuery.makeArray( value ), 
                        i = options.length; 
 
                    </span><span class="s2">while </span><span class="s1">( i-- ) { 
                        option = options[ i ]; 
 
                        </span><span class="s0">/* eslint-disable no-cond-assign */</span><span class="s1"> 
 
                        </span><span class="s2">if </span><span class="s1">( option.selected = 
                                jQuery.inArray( jQuery.valHooks.option.get( option ), values ) &gt; -</span><span class="s4">1</span><span class="s1"> 
                        ) { 
                            optionSet = </span><span class="s2">true</span><span class="s1">; 
                        } 
 
                        </span><span class="s0">/* eslint-enable no-cond-assign */</span><span class="s1"> 
                    } 
 
                    </span><span class="s0">// Force browsers to behave consistently when non-matching value is set</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !optionSet ) { 
                        elem.selectedIndex = -</span><span class="s4">1</span><span class="s1">; 
                    } 
                    </span><span class="s2">return </span><span class="s1">values; 
                } 
            } 
        } 
    } ); 
 
</span><span class="s0">// Radios and checkboxes getter/setter</span><span class="s1"> 
    jQuery.each( [ </span><span class="s3">&quot;radio&quot;</span><span class="s1">, </span><span class="s3">&quot;checkbox&quot; </span><span class="s1">], </span><span class="s2">function</span><span class="s1">() { 
        jQuery.valHooks[ </span><span class="s2">this </span><span class="s1">] = { 
            </span><span class="s2">set</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( elem, value ) { 
                </span><span class="s2">if </span><span class="s1">( jQuery.isArray( value ) ) { 
                    </span><span class="s2">return </span><span class="s1">( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) &gt; -</span><span class="s4">1 </span><span class="s1">); 
                } 
            } 
        }; 
        </span><span class="s2">if </span><span class="s1">( !support.checkOn ) { 
            jQuery.valHooks[ </span><span class="s2">this </span><span class="s1">].get = </span><span class="s2">function</span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">elem.getAttribute( </span><span class="s3">&quot;value&quot; </span><span class="s1">) === </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;on&quot; </span><span class="s1">: elem.value; 
            }; 
        } 
    } ); 
 
 
 
 
</span><span class="s0">// Return jQuery for attributes-only inclusion</span><span class="s1"> 
 
 
    </span><span class="s2">var </span><span class="s1">rfocusMorph = </span><span class="s4">/^(?:focusinfocus|focusoutblur)$/</span><span class="s1">; 
 
    jQuery.extend( jQuery.event, { 
 
        trigger: </span><span class="s2">function</span><span class="s1">( event, data, elem, onlyHandlers ) { 
 
            </span><span class="s2">var </span><span class="s1">i, cur, tmp, bubbleType, ontype, handle, special, 
                eventPath = [ elem || document ], 
                type = hasOwn.call( event, </span><span class="s3">&quot;type&quot; </span><span class="s1">) ? event.type : event, 
                namespaces = hasOwn.call( event, </span><span class="s3">&quot;namespace&quot; </span><span class="s1">) ? event.namespace.split( </span><span class="s3">&quot;.&quot; </span><span class="s1">) : []; 
 
            cur = tmp = elem = elem || document; 
 
            </span><span class="s0">// Don't do events on text and comment nodes</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">3 </span><span class="s1">|| elem.nodeType === </span><span class="s4">8 </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// focus/blur morphs to focusin/out; ensure we're not firing them right now</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rfocusMorph.test( type + jQuery.event.triggered ) ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( type.indexOf( </span><span class="s3">&quot;.&quot; </span><span class="s1">) &gt; -</span><span class="s4">1 </span><span class="s1">) { 
 
                </span><span class="s0">// Namespaced trigger; create a regexp to match event type in handle()</span><span class="s1"> 
                namespaces = type.split( </span><span class="s3">&quot;.&quot; </span><span class="s1">); 
                type = namespaces.shift(); 
                namespaces.sort(); 
            } 
            ontype = type.indexOf( </span><span class="s3">&quot;:&quot; </span><span class="s1">) &lt; </span><span class="s4">0 </span><span class="s1">&amp;&amp; </span><span class="s3">&quot;on&quot; </span><span class="s1">+ type; 
 
            </span><span class="s0">// Caller can pass in a jQuery.Event object, Object, or just an event type string</span><span class="s1"> 
            event = event[ jQuery.expando ] ? 
                event : 
                </span><span class="s2">new </span><span class="s1">jQuery.Event( type, </span><span class="s2">typeof </span><span class="s1">event === </span><span class="s3">&quot;object&quot; </span><span class="s1">&amp;&amp; event ); 
 
            </span><span class="s0">// Trigger bitmask: &amp; 1 for native handlers; &amp; 2 for jQuery (always true)</span><span class="s1"> 
            event.isTrigger = onlyHandlers ? </span><span class="s4">2 </span><span class="s1">: </span><span class="s4">3</span><span class="s1">; 
            event.namespace = namespaces.join( </span><span class="s3">&quot;.&quot; </span><span class="s1">); 
            event.rnamespace = event.namespace ? 
                </span><span class="s2">new </span><span class="s1">RegExp( </span><span class="s3">&quot;(^|</span><span class="s2">\\</span><span class="s3">.)&quot; </span><span class="s1">+ namespaces.join( </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">.(?:.*</span><span class="s2">\\</span><span class="s3">.|)&quot; </span><span class="s1">) + </span><span class="s3">&quot;(</span><span class="s2">\\</span><span class="s3">.|$)&quot; </span><span class="s1">) : 
                </span><span class="s2">null</span><span class="s1">; 
 
            </span><span class="s0">// Clean up the event in case it is being reused</span><span class="s1"> 
            event.result = undefined; 
            </span><span class="s2">if </span><span class="s1">( !event.target ) { 
                event.target = elem; 
            } 
 
            </span><span class="s0">// Clone any incoming data and prepend the event, creating the handler arg list</span><span class="s1"> 
            data = data == </span><span class="s2">null </span><span class="s1">? 
                [ event ] : 
                jQuery.makeArray( data, [ event ] ); 
 
            </span><span class="s0">// Allow special events to draw outside the lines</span><span class="s1"> 
            special = jQuery.event.special[ type ] || {}; 
            </span><span class="s2">if </span><span class="s1">( !onlyHandlers &amp;&amp; special.trigger &amp;&amp; special.trigger.apply( elem, data ) === </span><span class="s2">false </span><span class="s1">) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Determine event propagation path in advance, per W3C events spec (#9951)</span><span class="s1"> 
            </span><span class="s0">// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !onlyHandlers &amp;&amp; !special.noBubble &amp;&amp; !jQuery.isWindow( elem ) ) { 
 
                bubbleType = special.delegateType || type; 
                </span><span class="s2">if </span><span class="s1">( !rfocusMorph.test( bubbleType + type ) ) { 
                    cur = cur.parentNode; 
                } 
                </span><span class="s2">for </span><span class="s1">( ; cur; cur = cur.parentNode ) { 
                    eventPath.push( cur ); 
                    tmp = cur; 
                } 
 
                </span><span class="s0">// Only add window if we got to document (e.g., not plain obj or detached DOM)</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( tmp === ( elem.ownerDocument || document ) ) { 
                    eventPath.push( tmp.defaultView || tmp.parentWindow || window ); 
                } 
            } 
 
            </span><span class="s0">// Fire handlers on the event path</span><span class="s1"> 
            i = </span><span class="s4">0</span><span class="s1">; 
            </span><span class="s2">while </span><span class="s1">( ( cur = eventPath[ i++ ] ) &amp;&amp; !event.isPropagationStopped() ) { 
 
                event.type = i &gt; </span><span class="s4">1 </span><span class="s1">? 
                    bubbleType : 
                special.bindType || type; 
 
                </span><span class="s0">// jQuery handler</span><span class="s1"> 
                handle = ( dataPriv.get( cur, </span><span class="s3">&quot;events&quot; </span><span class="s1">) || {} )[ event.type ] &amp;&amp; 
                    dataPriv.get( cur, </span><span class="s3">&quot;handle&quot; </span><span class="s1">); 
                </span><span class="s2">if </span><span class="s1">( handle ) { 
                    handle.apply( cur, data ); 
                } 
 
                </span><span class="s0">// Native handler</span><span class="s1"> 
                handle = ontype &amp;&amp; cur[ ontype ]; 
                </span><span class="s2">if </span><span class="s1">( handle &amp;&amp; handle.apply &amp;&amp; acceptData( cur ) ) { 
                    event.result = handle.apply( cur, data ); 
                    </span><span class="s2">if </span><span class="s1">( event.result === </span><span class="s2">false </span><span class="s1">) { 
                        event.preventDefault(); 
                    } 
                } 
            } 
            event.type = type; 
 
            </span><span class="s0">// If nobody prevented the default action, do it now</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !onlyHandlers &amp;&amp; !event.isDefaultPrevented() ) { 
 
                </span><span class="s2">if </span><span class="s1">( ( !special._default || 
                    special._default.apply( eventPath.pop(), data ) === </span><span class="s2">false </span><span class="s1">) &amp;&amp; 
                    acceptData( elem ) ) { 
 
                    </span><span class="s0">// Call a native DOM method on the target with the same name as the event.</span><span class="s1"> 
                    </span><span class="s0">// Don't do default actions on window, that's where global variables be (#6170)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( ontype &amp;&amp; jQuery.isFunction( elem[ type ] ) &amp;&amp; !jQuery.isWindow( elem ) ) { 
 
                        </span><span class="s0">// Don't re-trigger an onFOO event when we call its FOO() method</span><span class="s1"> 
                        tmp = elem[ ontype ]; 
 
                        </span><span class="s2">if </span><span class="s1">( tmp ) { 
                            elem[ ontype ] = </span><span class="s2">null</span><span class="s1">; 
                        } 
 
                        </span><span class="s0">// Prevent re-triggering of the same event, since we already bubbled it above</span><span class="s1"> 
                        jQuery.event.triggered = type; 
                        elem[ type ](); 
                        jQuery.event.triggered = undefined; 
 
                        </span><span class="s2">if </span><span class="s1">( tmp ) { 
                            elem[ ontype ] = tmp; 
                        } 
                    } 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">event.result; 
        }, 
 
        </span><span class="s0">// Piggyback on a donor event to simulate a different one</span><span class="s1"> 
        </span><span class="s0">// Used only for `focus(in | out)` events</span><span class="s1"> 
        simulate: </span><span class="s2">function</span><span class="s1">( type, elem, event ) { 
            </span><span class="s2">var </span><span class="s1">e = jQuery.extend( 
                </span><span class="s2">new </span><span class="s1">jQuery.Event(), 
                event, 
                { 
                    type: type, 
                    isSimulated: </span><span class="s2">true</span><span class="s1"> 
                } 
            ); 
 
            jQuery.event.trigger( e, </span><span class="s2">null</span><span class="s1">, elem ); 
        } 
 
    } ); 
 
    jQuery.fn.extend( { 
 
        trigger: </span><span class="s2">function</span><span class="s1">( type, data ) { 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                jQuery.event.trigger( type, data, </span><span class="s2">this </span><span class="s1">); 
            } ); 
        }, 
        triggerHandler: </span><span class="s2">function</span><span class="s1">( type, data ) { 
            </span><span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">]; 
            </span><span class="s2">if </span><span class="s1">( elem ) { 
                </span><span class="s2">return </span><span class="s1">jQuery.event.trigger( type, data, elem, </span><span class="s2">true </span><span class="s1">); 
            } 
        } 
    } ); 
 
 
    jQuery.each( ( </span><span class="s3">&quot;blur focus focusin focusout resize scroll click dblclick &quot; </span><span class="s1">+ 
        </span><span class="s3">&quot;mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave &quot; </span><span class="s1">+ 
        </span><span class="s3">&quot;change select submit keydown keypress keyup contextmenu&quot; </span><span class="s1">).split( </span><span class="s3">&quot; &quot; </span><span class="s1">), 
        </span><span class="s2">function</span><span class="s1">( i, name ) { 
 
            </span><span class="s0">// Handle event binding</span><span class="s1"> 
            jQuery.fn[ name ] = </span><span class="s2">function</span><span class="s1">( data, fn ) { 
                </span><span class="s2">return </span><span class="s1">arguments.length &gt; </span><span class="s4">0 </span><span class="s1">? 
                    </span><span class="s2">this</span><span class="s1">.on( name, </span><span class="s2">null</span><span class="s1">, data, fn ) : 
                    </span><span class="s2">this</span><span class="s1">.trigger( name ); 
            }; 
        } ); 
 
    jQuery.fn.extend( { 
        hover: </span><span class="s2">function</span><span class="s1">( fnOver, fnOut ) { 
            </span><span class="s2">return this</span><span class="s1">.mouseenter( fnOver ).mouseleave( fnOut || fnOver ); 
        } 
    } ); 
 
 
 
 
    support.focusin = </span><span class="s3">&quot;onfocusin&quot; </span><span class="s2">in </span><span class="s1">window; 
 
 
</span><span class="s0">// Support: Firefox &lt;=44</span><span class="s1"> 
</span><span class="s0">// Firefox doesn't have focus(in | out) events</span><span class="s1"> 
</span><span class="s0">// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787</span><span class="s1"> 
</span><span class="s0">//</span><span class="s1"> 
</span><span class="s0">// Support: Chrome &lt;=48 - 49, Safari &lt;=9.0 - 9.1</span><span class="s1"> 
</span><span class="s0">// focus(in | out) events fire after focus &amp; blur events,</span><span class="s1"> 
</span><span class="s0">// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order</span><span class="s1"> 
</span><span class="s0">// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !support.focusin ) { 
        jQuery.each( { focus: </span><span class="s3">&quot;focusin&quot;</span><span class="s1">, blur: </span><span class="s3">&quot;focusout&quot; </span><span class="s1">}, </span><span class="s2">function</span><span class="s1">( orig, fix ) { 
 
            </span><span class="s0">// Attach a single capturing handler on the document while someone wants focusin/focusout</span><span class="s1"> 
            </span><span class="s2">var </span><span class="s1">handler = </span><span class="s2">function</span><span class="s1">( event ) { 
                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) ); 
            }; 
 
            jQuery.event.special[ fix ] = { 
                setup: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">var </span><span class="s1">doc = </span><span class="s2">this</span><span class="s1">.ownerDocument || </span><span class="s2">this</span><span class="s1">, 
                        attaches = dataPriv.access( doc, fix ); 
 
                    </span><span class="s2">if </span><span class="s1">( !attaches ) { 
                        doc.addEventListener( orig, handler, </span><span class="s2">true </span><span class="s1">); 
                    } 
                    dataPriv.access( doc, fix, ( attaches || </span><span class="s4">0 </span><span class="s1">) + </span><span class="s4">1 </span><span class="s1">); 
                }, 
                teardown: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">var </span><span class="s1">doc = </span><span class="s2">this</span><span class="s1">.ownerDocument || </span><span class="s2">this</span><span class="s1">, 
                        attaches = dataPriv.access( doc, fix ) - </span><span class="s4">1</span><span class="s1">; 
 
                    </span><span class="s2">if </span><span class="s1">( !attaches ) { 
                        doc.removeEventListener( orig, handler, </span><span class="s2">true </span><span class="s1">); 
                        dataPriv.remove( doc, fix ); 
 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        dataPriv.access( doc, fix, attaches ); 
                    } 
                } 
            }; 
        } ); 
    } 
    </span><span class="s2">var </span><span class="s1">location = window.location; 
 
    </span><span class="s2">var </span><span class="s1">nonce = jQuery.now(); 
 
    </span><span class="s2">var </span><span class="s1">rquery = ( </span><span class="s4">/\?/ </span><span class="s1">); 
 
 
 
</span><span class="s0">// Cross-browser xml parsing</span><span class="s1"> 
    jQuery.parseXML = </span><span class="s2">function</span><span class="s1">( data ) { 
        </span><span class="s2">var </span><span class="s1">xml; 
        </span><span class="s2">if </span><span class="s1">( !data || </span><span class="s2">typeof </span><span class="s1">data !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return null</span><span class="s1">; 
        } 
 
        </span><span class="s0">// Support: IE 9 - 11 only</span><span class="s1"> 
        </span><span class="s0">// IE throws on parseFromString with invalid input.</span><span class="s1"> 
        </span><span class="s2">try </span><span class="s1">{ 
            xml = ( </span><span class="s2">new </span><span class="s1">window.DOMParser() ).parseFromString( data, </span><span class="s3">&quot;text/xml&quot; </span><span class="s1">); 
        } </span><span class="s2">catch </span><span class="s1">( e ) { 
            xml = undefined; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( !xml || xml.getElementsByTagName( </span><span class="s3">&quot;parsererror&quot; </span><span class="s1">).length ) { 
            jQuery.error( </span><span class="s3">&quot;Invalid XML: &quot; </span><span class="s1">+ data ); 
        } 
        </span><span class="s2">return </span><span class="s1">xml; 
    }; 
 
 
    </span><span class="s2">var</span><span class="s1"> 
        rbracket = </span><span class="s4">/\[\]$/</span><span class="s1">, 
        rCRLF = </span><span class="s4">/\r?\n/g</span><span class="s1">, 
        rsubmitterTypes = </span><span class="s4">/^(?:submit|button|image|reset|file)$/i</span><span class="s1">, 
        rsubmittable = </span><span class="s4">/^(?:input|select|textarea|keygen)/i</span><span class="s1">; 
 
    </span><span class="s2">function </span><span class="s1">buildParams( prefix, obj, traditional, add ) { 
        </span><span class="s2">var </span><span class="s1">name; 
 
        </span><span class="s2">if </span><span class="s1">( jQuery.isArray( obj ) ) { 
 
            </span><span class="s0">// Serialize array item.</span><span class="s1"> 
            jQuery.each( obj, </span><span class="s2">function</span><span class="s1">( i, v ) { 
                </span><span class="s2">if </span><span class="s1">( traditional || rbracket.test( prefix ) ) { 
 
                    </span><span class="s0">// Treat each array item as a scalar.</span><span class="s1"> 
                    add( prefix, v ); 
 
                } </span><span class="s2">else </span><span class="s1">{ 
 
                    </span><span class="s0">// Item is non-scalar (array or object), encode its numeric index.</span><span class="s1"> 
                    buildParams( 
                        prefix + </span><span class="s3">&quot;[&quot; </span><span class="s1">+ ( </span><span class="s2">typeof </span><span class="s1">v === </span><span class="s3">&quot;object&quot; </span><span class="s1">&amp;&amp; v != </span><span class="s2">null </span><span class="s1">? i : </span><span class="s3">&quot;&quot; </span><span class="s1">) + </span><span class="s3">&quot;]&quot;</span><span class="s1">, 
                        v, 
                        traditional, 
                        add 
                    ); 
                } 
            } ); 
 
        } </span><span class="s2">else if </span><span class="s1">( !traditional &amp;&amp; jQuery.type( obj ) === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
 
            </span><span class="s0">// Serialize object item.</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( name </span><span class="s2">in </span><span class="s1">obj ) { 
                buildParams( prefix + </span><span class="s3">&quot;[&quot; </span><span class="s1">+ name + </span><span class="s3">&quot;]&quot;</span><span class="s1">, obj[ name ], traditional, add ); 
            } 
 
        } </span><span class="s2">else </span><span class="s1">{ 
 
            </span><span class="s0">// Serialize scalar item.</span><span class="s1"> 
            add( prefix, obj ); 
        } 
    } 
 
</span><span class="s0">// Serialize an array of form elements or a set of</span><span class="s1"> 
</span><span class="s0">// key/values into a query string</span><span class="s1"> 
    jQuery.param = </span><span class="s2">function</span><span class="s1">( a, traditional ) { 
        </span><span class="s2">var </span><span class="s1">prefix, 
            s = [], 
            add = </span><span class="s2">function</span><span class="s1">( key, valueOrFunction ) { 
 
                </span><span class="s0">// If value is a function, invoke it and use its return value</span><span class="s1"> 
                </span><span class="s2">var </span><span class="s1">value = jQuery.isFunction( valueOrFunction ) ? 
                    valueOrFunction() : 
                    valueOrFunction; 
 
                s[ s.length ] = encodeURIComponent( key ) + </span><span class="s3">&quot;=&quot; </span><span class="s1">+ 
                    encodeURIComponent( value == </span><span class="s2">null </span><span class="s1">? </span><span class="s3">&quot;&quot; </span><span class="s1">: value ); 
            }; 
 
        </span><span class="s0">// If an array was passed in, assume that it is an array of form elements.</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.isArray( a ) || ( a.jquery &amp;&amp; !jQuery.isPlainObject( a ) ) ) { 
 
            </span><span class="s0">// Serialize the form elements</span><span class="s1"> 
            jQuery.each( a, </span><span class="s2">function</span><span class="s1">() { 
                add( </span><span class="s2">this</span><span class="s1">.name, </span><span class="s2">this</span><span class="s1">.value ); 
            } ); 
 
        } </span><span class="s2">else </span><span class="s1">{ 
 
            </span><span class="s0">// If traditional, encode the &quot;old&quot; way (the way 1.3.2 or older</span><span class="s1"> 
            </span><span class="s0">// did it), otherwise encode params recursively.</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( prefix </span><span class="s2">in </span><span class="s1">a ) { 
                buildParams( prefix, a[ prefix ], traditional, add ); 
            } 
        } 
 
        </span><span class="s0">// Return the resulting serialization</span><span class="s1"> 
        </span><span class="s2">return </span><span class="s1">s.join( </span><span class="s3">&quot;&amp;&quot; </span><span class="s1">); 
    }; 
 
    jQuery.fn.extend( { 
        serialize: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">jQuery.param( </span><span class="s2">this</span><span class="s1">.serializeArray() ); 
        }, 
        serializeArray: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return this</span><span class="s1">.map( </span><span class="s2">function</span><span class="s1">() { 
 
                    </span><span class="s0">// Can add propHook for &quot;elements&quot; to filter or add form elements</span><span class="s1"> 
                    </span><span class="s2">var </span><span class="s1">elements = jQuery.prop( </span><span class="s2">this</span><span class="s1">, </span><span class="s3">&quot;elements&quot; </span><span class="s1">); 
                    </span><span class="s2">return </span><span class="s1">elements ? jQuery.makeArray( elements ) : </span><span class="s2">this</span><span class="s1">; 
                } ) 
                .filter( </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">var </span><span class="s1">type = </span><span class="s2">this</span><span class="s1">.type; 
 
                    </span><span class="s0">// Use .is( &quot;:disabled&quot; ) so that fieldset[disabled] works</span><span class="s1"> 
                    </span><span class="s2">return this</span><span class="s1">.name &amp;&amp; !jQuery( </span><span class="s2">this </span><span class="s1">).is( </span><span class="s3">&quot;:disabled&quot; </span><span class="s1">) &amp;&amp; 
                        rsubmittable.test( </span><span class="s2">this</span><span class="s1">.nodeName ) &amp;&amp; !rsubmitterTypes.test( type ) &amp;&amp; 
                        ( </span><span class="s2">this</span><span class="s1">.checked || !rcheckableType.test( type ) ); 
                } ) 
                .map( </span><span class="s2">function</span><span class="s1">( i, elem ) { 
                    </span><span class="s2">var </span><span class="s1">val = jQuery( </span><span class="s2">this </span><span class="s1">).val(); 
 
                    </span><span class="s2">if </span><span class="s1">( val == </span><span class="s2">null </span><span class="s1">) { 
                        </span><span class="s2">return null</span><span class="s1">; 
                    } 
 
                    </span><span class="s2">if </span><span class="s1">( jQuery.isArray( val ) ) { 
                        </span><span class="s2">return </span><span class="s1">jQuery.map( val, </span><span class="s2">function</span><span class="s1">( val ) { 
                            </span><span class="s2">return </span><span class="s1">{ name: elem.name, value: val.replace( rCRLF, </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot; </span><span class="s1">) }; 
                        } ); 
                    } 
 
                    </span><span class="s2">return </span><span class="s1">{ name: elem.name, value: val.replace( rCRLF, </span><span class="s3">&quot;</span><span class="s2">\r\n</span><span class="s3">&quot; </span><span class="s1">) }; 
                } ).get(); 
        } 
    } ); 
 
 
    </span><span class="s2">var</span><span class="s1"> 
        r20 = </span><span class="s4">/%20/g</span><span class="s1">, 
        rhash = </span><span class="s4">/#.*$/</span><span class="s1">, 
        rantiCache = </span><span class="s4">/([?&amp;])_=[^&amp;]*/</span><span class="s1">, 
        rheaders = </span><span class="s4">/^(.*?):[ \t]*([^\r\n]*)$/mg</span><span class="s1">, 
 
    </span><span class="s0">// #7653, #8125, #8152: local protocol detection</span><span class="s1"> 
        rlocalProtocol = </span><span class="s4">/^(?:about|app|app-storage|.+-extension|file|res|widget):$/</span><span class="s1">, 
        rnoContent = </span><span class="s4">/^(?:GET|HEAD)$/</span><span class="s1">, 
        rprotocol = </span><span class="s4">/^\/\//</span><span class="s1">, 
 
    </span><span class="s0">/* Prefilters 
     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example) 
     * 2) These are called: 
     *    - BEFORE asking for a transport 
     *    - AFTER param serialization (s.data is a string if s.processData is true) 
     * 3) key is the dataType 
     * 4) the catchall symbol &quot;*&quot; can be used 
     * 5) execution will start with transport dataType and THEN continue down to &quot;*&quot; if needed 
     */</span><span class="s1"> 
        prefilters = {}, 
 
    </span><span class="s0">/* Transports bindings 
     * 1) key is the dataType 
     * 2) the catchall symbol &quot;*&quot; can be used 
     * 3) selection will start with transport dataType and THEN go to &quot;*&quot; if needed 
     */</span><span class="s1"> 
        transports = {}, 
 
    </span><span class="s0">// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression</span><span class="s1"> 
        allTypes = </span><span class="s3">&quot;*/&quot;</span><span class="s1">.concat( </span><span class="s3">&quot;*&quot; </span><span class="s1">), 
 
    </span><span class="s0">// Anchor tag for parsing the document origin</span><span class="s1"> 
        originAnchor = document.createElement( </span><span class="s3">&quot;a&quot; </span><span class="s1">); 
    originAnchor.href = location.href; 
 
</span><span class="s0">// Base &quot;constructor&quot; for jQuery.ajaxPrefilter and jQuery.ajaxTransport</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">addToPrefiltersOrTransports( structure ) { 
 
        </span><span class="s0">// dataTypeExpression is optional and defaults to &quot;*&quot;</span><span class="s1"> 
        </span><span class="s2">return function</span><span class="s1">( dataTypeExpression, func ) { 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">dataTypeExpression !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                func = dataTypeExpression; 
                dataTypeExpression = </span><span class="s3">&quot;*&quot;</span><span class="s1">; 
            } 
 
            </span><span class="s2">var </span><span class="s1">dataType, 
                i = </span><span class="s4">0</span><span class="s1">, 
                dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || []; 
 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( func ) ) { 
 
                </span><span class="s0">// For each dataType in the dataTypeExpression</span><span class="s1"> 
                </span><span class="s2">while </span><span class="s1">( ( dataType = dataTypes[ i++ ] ) ) { 
 
                    </span><span class="s0">// Prepend if requested</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( dataType[ </span><span class="s4">0 </span><span class="s1">] === </span><span class="s3">&quot;+&quot; </span><span class="s1">) { 
                        dataType = dataType.slice( </span><span class="s4">1 </span><span class="s1">) || </span><span class="s3">&quot;*&quot;</span><span class="s1">; 
                        ( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func ); 
 
                        </span><span class="s0">// Otherwise append</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        ( structure[ dataType ] = structure[ dataType ] || [] ).push( func ); 
                    } 
                } 
            } 
        }; 
    } 
 
</span><span class="s0">// Base inspection function for prefilters and transports</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) { 
 
        </span><span class="s2">var </span><span class="s1">inspected = {}, 
            seekingTransport = ( structure === transports ); 
 
        </span><span class="s2">function </span><span class="s1">inspect( dataType ) { 
            </span><span class="s2">var </span><span class="s1">selected; 
            inspected[ dataType ] = </span><span class="s2">true</span><span class="s1">; 
            jQuery.each( structure[ dataType ] || [], </span><span class="s2">function</span><span class="s1">( _, prefilterOrFactory ) { 
                </span><span class="s2">var </span><span class="s1">dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR ); 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">dataTypeOrTransport === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; 
                    !seekingTransport &amp;&amp; !inspected[ dataTypeOrTransport ] ) { 
 
                    options.dataTypes.unshift( dataTypeOrTransport ); 
                    inspect( dataTypeOrTransport ); 
                    </span><span class="s2">return false</span><span class="s1">; 
                } </span><span class="s2">else if </span><span class="s1">( seekingTransport ) { 
                    </span><span class="s2">return </span><span class="s1">!( selected = dataTypeOrTransport ); 
                } 
            } ); 
            </span><span class="s2">return </span><span class="s1">selected; 
        } 
 
        </span><span class="s2">return </span><span class="s1">inspect( options.dataTypes[ </span><span class="s4">0 </span><span class="s1">] ) || !inspected[ </span><span class="s3">&quot;*&quot; </span><span class="s1">] &amp;&amp; inspect( </span><span class="s3">&quot;*&quot; </span><span class="s1">); 
    } 
 
</span><span class="s0">// A special extend for ajax options</span><span class="s1"> 
</span><span class="s0">// that takes &quot;flat&quot; options (not to be deep extended)</span><span class="s1"> 
</span><span class="s0">// Fixes #9887</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">ajaxExtend( target, src ) { 
        </span><span class="s2">var </span><span class="s1">key, deep, 
            flatOptions = jQuery.ajaxSettings.flatOptions || {}; 
 
        </span><span class="s2">for </span><span class="s1">( key </span><span class="s2">in </span><span class="s1">src ) { 
            </span><span class="s2">if </span><span class="s1">( src[ key ] !== undefined ) { 
                ( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ]; 
            } 
        } 
        </span><span class="s2">if </span><span class="s1">( deep ) { 
            jQuery.extend( </span><span class="s2">true</span><span class="s1">, target, deep ); 
        } 
 
        </span><span class="s2">return </span><span class="s1">target; 
    } 
 
    </span><span class="s0">/* Handles responses to an ajax request: 
     * - finds the right dataType (mediates between content-type and expected dataType) 
     * - returns the corresponding response 
     */</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">ajaxHandleResponses( s, jqXHR, responses ) { 
 
        </span><span class="s2">var </span><span class="s1">ct, type, finalDataType, firstDataType, 
            contents = s.contents, 
            dataTypes = s.dataTypes; 
 
        </span><span class="s0">// Remove auto dataType and get content-type in the process</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( dataTypes[ </span><span class="s4">0 </span><span class="s1">] === </span><span class="s3">&quot;*&quot; </span><span class="s1">) { 
            dataTypes.shift(); 
            </span><span class="s2">if </span><span class="s1">( ct === undefined ) { 
                ct = s.mimeType || jqXHR.getResponseHeader( </span><span class="s3">&quot;Content-Type&quot; </span><span class="s1">); 
            } 
        } 
 
        </span><span class="s0">// Check if we're dealing with a known content-type</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( ct ) { 
            </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">contents ) { 
                </span><span class="s2">if </span><span class="s1">( contents[ type ] &amp;&amp; contents[ type ].test( ct ) ) { 
                    dataTypes.unshift( type ); 
                    </span><span class="s2">break</span><span class="s1">; 
                } 
            } 
        } 
 
        </span><span class="s0">// Check to see if we have a response for the expected dataType</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( dataTypes[ </span><span class="s4">0 </span><span class="s1">] </span><span class="s2">in </span><span class="s1">responses ) { 
            finalDataType = dataTypes[ </span><span class="s4">0 </span><span class="s1">]; 
        } </span><span class="s2">else </span><span class="s1">{ 
 
            </span><span class="s0">// Try convertible dataTypes</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( type </span><span class="s2">in </span><span class="s1">responses ) { 
                </span><span class="s2">if </span><span class="s1">( !dataTypes[ </span><span class="s4">0 </span><span class="s1">] || s.converters[ type + </span><span class="s3">&quot; &quot; </span><span class="s1">+ dataTypes[ </span><span class="s4">0 </span><span class="s1">] ] ) { 
                    finalDataType = type; 
                    </span><span class="s2">break</span><span class="s1">; 
                } 
                </span><span class="s2">if </span><span class="s1">( !firstDataType ) { 
                    firstDataType = type; 
                } 
            } 
 
            </span><span class="s0">// Or just use first one</span><span class="s1"> 
            finalDataType = finalDataType || firstDataType; 
        } 
 
        </span><span class="s0">// If we found a dataType</span><span class="s1"> 
        </span><span class="s0">// We add the dataType to the list if needed</span><span class="s1"> 
        </span><span class="s0">// and return the corresponding response</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( finalDataType ) { 
            </span><span class="s2">if </span><span class="s1">( finalDataType !== dataTypes[ </span><span class="s4">0 </span><span class="s1">] ) { 
                dataTypes.unshift( finalDataType ); 
            } 
            </span><span class="s2">return </span><span class="s1">responses[ finalDataType ]; 
        } 
    } 
 
    </span><span class="s0">/* Chain conversions given the request and the original response 
     * Also sets the responseXXX fields on the jqXHR instance 
     */</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">ajaxConvert( s, response, jqXHR, isSuccess ) { 
        </span><span class="s2">var </span><span class="s1">conv2, current, conv, tmp, prev, 
            converters = {}, 
 
        </span><span class="s0">// Work with a copy of dataTypes in case we need to modify it for conversion</span><span class="s1"> 
            dataTypes = s.dataTypes.slice(); 
 
        </span><span class="s0">// Create converters map with lowercased keys</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( dataTypes[ </span><span class="s4">1 </span><span class="s1">] ) { 
            </span><span class="s2">for </span><span class="s1">( conv </span><span class="s2">in </span><span class="s1">s.converters ) { 
                converters[ conv.toLowerCase() ] = s.converters[ conv ]; 
            } 
        } 
 
        current = dataTypes.shift(); 
 
        </span><span class="s0">// Convert to each sequential dataType</span><span class="s1"> 
        </span><span class="s2">while </span><span class="s1">( current ) { 
 
            </span><span class="s2">if </span><span class="s1">( s.responseFields[ current ] ) { 
                jqXHR[ s.responseFields[ current ] ] = response; 
            } 
 
            </span><span class="s0">// Apply the dataFilter if provided</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !prev &amp;&amp; isSuccess &amp;&amp; s.dataFilter ) { 
                response = s.dataFilter( response, s.dataType ); 
            } 
 
            prev = current; 
            current = dataTypes.shift(); 
 
            </span><span class="s2">if </span><span class="s1">( current ) { 
 
                </span><span class="s0">// There's only work to do if current dataType is non-auto</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( current === </span><span class="s3">&quot;*&quot; </span><span class="s1">) { 
 
                    current = prev; 
 
                    </span><span class="s0">// Convert response if prev dataType is non-auto and differs from current</span><span class="s1"> 
                } </span><span class="s2">else if </span><span class="s1">( prev !== </span><span class="s3">&quot;*&quot; </span><span class="s1">&amp;&amp; prev !== current ) { 
 
                    </span><span class="s0">// Seek a direct converter</span><span class="s1"> 
                    conv = converters[ prev + </span><span class="s3">&quot; &quot; </span><span class="s1">+ current ] || converters[ </span><span class="s3">&quot;* &quot; </span><span class="s1">+ current ]; 
 
                    </span><span class="s0">// If none found, seek a pair</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !conv ) { 
                        </span><span class="s2">for </span><span class="s1">( conv2 </span><span class="s2">in </span><span class="s1">converters ) { 
 
                            </span><span class="s0">// If conv2 outputs current</span><span class="s1"> 
                            tmp = conv2.split( </span><span class="s3">&quot; &quot; </span><span class="s1">); 
                            </span><span class="s2">if </span><span class="s1">( tmp[ </span><span class="s4">1 </span><span class="s1">] === current ) { 
 
                                </span><span class="s0">// If prev can be converted to accepted input</span><span class="s1"> 
                                conv = converters[ prev + </span><span class="s3">&quot; &quot; </span><span class="s1">+ tmp[ </span><span class="s4">0 </span><span class="s1">] ] || 
                                    converters[ </span><span class="s3">&quot;* &quot; </span><span class="s1">+ tmp[ </span><span class="s4">0 </span><span class="s1">] ]; 
                                </span><span class="s2">if </span><span class="s1">( conv ) { 
 
                                    </span><span class="s0">// Condense equivalence converters</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( conv === </span><span class="s2">true </span><span class="s1">) { 
                                        conv = converters[ conv2 ]; 
 
                                        </span><span class="s0">// Otherwise, insert the intermediate dataType</span><span class="s1"> 
                                    } </span><span class="s2">else if </span><span class="s1">( converters[ conv2 ] !== </span><span class="s2">true </span><span class="s1">) { 
                                        current = tmp[ </span><span class="s4">0 </span><span class="s1">]; 
                                        dataTypes.unshift( tmp[ </span><span class="s4">1 </span><span class="s1">] ); 
                                    } 
                                    </span><span class="s2">break</span><span class="s1">; 
                                } 
                            } 
                        } 
                    } 
 
                    </span><span class="s0">// Apply converter (if not an equivalence)</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( conv !== </span><span class="s2">true </span><span class="s1">) { 
 
                        </span><span class="s0">// Unless errors are allowed to bubble, catch and return them</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( conv &amp;&amp; s.throws ) { 
                            response = conv( response ); 
                        } </span><span class="s2">else </span><span class="s1">{ 
                            </span><span class="s2">try </span><span class="s1">{ 
                                response = conv( response ); 
                            } </span><span class="s2">catch </span><span class="s1">( e ) { 
                                </span><span class="s2">return </span><span class="s1">{ 
                                    state: </span><span class="s3">&quot;parsererror&quot;</span><span class="s1">, 
                                    error: conv ? e : </span><span class="s3">&quot;No conversion from &quot; </span><span class="s1">+ prev + </span><span class="s3">&quot; to &quot; </span><span class="s1">+ current 
                                }; 
                            } 
                        } 
                    } 
                } 
            } 
        } 
 
        </span><span class="s2">return </span><span class="s1">{ state: </span><span class="s3">&quot;success&quot;</span><span class="s1">, data: response }; 
    } 
 
    jQuery.extend( { 
 
        </span><span class="s0">// Counter for holding the number of active queries</span><span class="s1"> 
        active: </span><span class="s4">0</span><span class="s1">, 
 
        </span><span class="s0">// Last-Modified header cache for next request</span><span class="s1"> 
        lastModified: {}, 
        etag: {}, 
 
        ajaxSettings: { 
            url: location.href, 
            type: </span><span class="s3">&quot;GET&quot;</span><span class="s1">, 
            isLocal: rlocalProtocol.test( location.protocol ), 
            global: </span><span class="s2">true</span><span class="s1">, 
            processData: </span><span class="s2">true</span><span class="s1">, 
            async: </span><span class="s2">true</span><span class="s1">, 
            contentType: </span><span class="s3">&quot;application/x-www-form-urlencoded; charset=UTF-8&quot;</span><span class="s1">, 
 
            </span><span class="s0">/* 
             timeout: 0, 
             data: null, 
             dataType: null, 
             username: null, 
             password: null, 
             cache: null, 
             throws: false, 
             traditional: false, 
             headers: {}, 
             */</span><span class="s1"> 
 
            accepts: { 
                </span><span class="s3">&quot;*&quot;</span><span class="s1">: allTypes, 
                text: </span><span class="s3">&quot;text/plain&quot;</span><span class="s1">, 
                html: </span><span class="s3">&quot;text/html&quot;</span><span class="s1">, 
                xml: </span><span class="s3">&quot;application/xml, text/xml&quot;</span><span class="s1">, 
                json: </span><span class="s3">&quot;application/json, text/javascript&quot;</span><span class="s1"> 
            }, 
 
            contents: { 
                xml: </span><span class="s4">/\bxml\b/</span><span class="s1">, 
                html: </span><span class="s4">/\bhtml/</span><span class="s1">, 
                json: </span><span class="s4">/\bjson\b/</span><span class="s1"> 
            }, 
 
            responseFields: { 
                xml: </span><span class="s3">&quot;responseXML&quot;</span><span class="s1">, 
                text: </span><span class="s3">&quot;responseText&quot;</span><span class="s1">, 
                json: </span><span class="s3">&quot;responseJSON&quot;</span><span class="s1"> 
            }, 
 
            </span><span class="s0">// Data converters</span><span class="s1"> 
            </span><span class="s0">// Keys separate source (or catchall &quot;*&quot;) and destination types with a single space</span><span class="s1"> 
            converters: { 
 
                </span><span class="s0">// Convert anything to text</span><span class="s1"> 
                </span><span class="s3">&quot;* text&quot;</span><span class="s1">: String, 
 
                </span><span class="s0">// Text to html (true = no transformation)</span><span class="s1"> 
                </span><span class="s3">&quot;text html&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1">, 
 
                </span><span class="s0">// Evaluate text as a json expression</span><span class="s1"> 
                </span><span class="s3">&quot;text json&quot;</span><span class="s1">: JSON.parse, 
 
                </span><span class="s0">// Parse text as xml</span><span class="s1"> 
                </span><span class="s3">&quot;text xml&quot;</span><span class="s1">: jQuery.parseXML 
            }, 
 
            </span><span class="s0">// For options that shouldn't be deep extended:</span><span class="s1"> 
            </span><span class="s0">// you can add your own custom options here if</span><span class="s1"> 
            </span><span class="s0">// and when you create one that shouldn't be</span><span class="s1"> 
            </span><span class="s0">// deep extended (see ajaxExtend)</span><span class="s1"> 
            flatOptions: { 
                url: </span><span class="s2">true</span><span class="s1">, 
                context: </span><span class="s2">true</span><span class="s1"> 
            } 
        }, 
 
        </span><span class="s0">// Creates a full fledged settings object into target</span><span class="s1"> 
        </span><span class="s0">// with both ajaxSettings and settings fields.</span><span class="s1"> 
        </span><span class="s0">// If target is omitted, writes into ajaxSettings.</span><span class="s1"> 
        ajaxSetup: </span><span class="s2">function</span><span class="s1">( target, settings ) { 
            </span><span class="s2">return </span><span class="s1">settings ? 
 
                </span><span class="s0">// Building a settings object</span><span class="s1"> 
                ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) : 
 
                </span><span class="s0">// Extending ajaxSettings</span><span class="s1"> 
                ajaxExtend( jQuery.ajaxSettings, target ); 
        }, 
 
        ajaxPrefilter: addToPrefiltersOrTransports( prefilters ), 
        ajaxTransport: addToPrefiltersOrTransports( transports ), 
 
        </span><span class="s0">// Main method</span><span class="s1"> 
        ajax: </span><span class="s2">function</span><span class="s1">( url, options ) { 
 
            </span><span class="s0">// If url is an object, simulate pre-1.5 signature</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">url === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
                options = url; 
                url = undefined; 
            } 
 
            </span><span class="s0">// Force options to be an object</span><span class="s1"> 
            options = options || {}; 
 
            </span><span class="s2">var </span><span class="s1">transport, 
 
            </span><span class="s0">// URL without anti-cache param</span><span class="s1"> 
                cacheURL, 
 
            </span><span class="s0">// Response headers</span><span class="s1"> 
                responseHeadersString, 
                responseHeaders, 
 
            </span><span class="s0">// timeout handle</span><span class="s1"> 
                timeoutTimer, 
 
            </span><span class="s0">// Url cleanup var</span><span class="s1"> 
                urlAnchor, 
 
            </span><span class="s0">// Request state (becomes false upon send and true upon completion)</span><span class="s1"> 
                completed, 
 
            </span><span class="s0">// To know if global events are to be dispatched</span><span class="s1"> 
                fireGlobals, 
 
            </span><span class="s0">// Loop variable</span><span class="s1"> 
                i, 
 
            </span><span class="s0">// uncached part of the url</span><span class="s1"> 
                uncached, 
 
            </span><span class="s0">// Create the final options object</span><span class="s1"> 
                s = jQuery.ajaxSetup( {}, options ), 
 
            </span><span class="s0">// Callbacks context</span><span class="s1"> 
                callbackContext = s.context || s, 
 
            </span><span class="s0">// Context for global events is callbackContext if it is a DOM node or jQuery collection</span><span class="s1"> 
                globalEventContext = s.context &amp;&amp; 
                ( callbackContext.nodeType || callbackContext.jquery ) ? 
                    jQuery( callbackContext ) : 
                    jQuery.event, 
 
            </span><span class="s0">// Deferreds</span><span class="s1"> 
                deferred = jQuery.Deferred(), 
                completeDeferred = jQuery.Callbacks( </span><span class="s3">&quot;once memory&quot; </span><span class="s1">), 
 
            </span><span class="s0">// Status-dependent callbacks</span><span class="s1"> 
                statusCode = s.statusCode || {}, 
 
            </span><span class="s0">// Headers (they are sent all at once)</span><span class="s1"> 
                requestHeaders = {}, 
                requestHeadersNames = {}, 
 
            </span><span class="s0">// Default abort message</span><span class="s1"> 
                strAbort = </span><span class="s3">&quot;canceled&quot;</span><span class="s1">, 
 
            </span><span class="s0">// Fake xhr</span><span class="s1"> 
                jqXHR = { 
                    readyState: </span><span class="s4">0</span><span class="s1">, 
 
                    </span><span class="s0">// Builds headers hashtable if needed</span><span class="s1"> 
                    getResponseHeader: </span><span class="s2">function</span><span class="s1">( key ) { 
                        </span><span class="s2">var </span><span class="s1">match; 
                        </span><span class="s2">if </span><span class="s1">( completed ) { 
                            </span><span class="s2">if </span><span class="s1">( !responseHeaders ) { 
                                responseHeaders = {}; 
                                </span><span class="s2">while </span><span class="s1">( ( match = rheaders.exec( responseHeadersString ) ) ) { 
                                    responseHeaders[ match[ </span><span class="s4">1 </span><span class="s1">].toLowerCase() ] = match[ </span><span class="s4">2 </span><span class="s1">]; 
                                } 
                            } 
                            match = responseHeaders[ key.toLowerCase() ]; 
                        } 
                        </span><span class="s2">return </span><span class="s1">match == </span><span class="s2">null </span><span class="s1">? </span><span class="s2">null </span><span class="s1">: match; 
                    }, 
 
                    </span><span class="s0">// Raw string</span><span class="s1"> 
                    getAllResponseHeaders: </span><span class="s2">function</span><span class="s1">() { 
                        </span><span class="s2">return </span><span class="s1">completed ? responseHeadersString : </span><span class="s2">null</span><span class="s1">; 
                    }, 
 
                    </span><span class="s0">// Caches the header</span><span class="s1"> 
                    setRequestHeader: </span><span class="s2">function</span><span class="s1">( name, value ) { 
                        </span><span class="s2">if </span><span class="s1">( completed == </span><span class="s2">null </span><span class="s1">) { 
                            name = requestHeadersNames[ name.toLowerCase() ] = 
                                requestHeadersNames[ name.toLowerCase() ] || name; 
                            requestHeaders[ name ] = value; 
                        } 
                        </span><span class="s2">return this</span><span class="s1">; 
                    }, 
 
                    </span><span class="s0">// Overrides response content-type header</span><span class="s1"> 
                    overrideMimeType: </span><span class="s2">function</span><span class="s1">( type ) { 
                        </span><span class="s2">if </span><span class="s1">( completed == </span><span class="s2">null </span><span class="s1">) { 
                            s.mimeType = type; 
                        } 
                        </span><span class="s2">return this</span><span class="s1">; 
                    }, 
 
                    </span><span class="s0">// Status-dependent callbacks</span><span class="s1"> 
                    statusCode: </span><span class="s2">function</span><span class="s1">( map ) { 
                        </span><span class="s2">var </span><span class="s1">code; 
                        </span><span class="s2">if </span><span class="s1">( map ) { 
                            </span><span class="s2">if </span><span class="s1">( completed ) { 
 
                                </span><span class="s0">// Execute the appropriate callbacks</span><span class="s1"> 
                                jqXHR.always( map[ jqXHR.status ] ); 
                            } </span><span class="s2">else </span><span class="s1">{ 
 
                                </span><span class="s0">// Lazy-add the new callbacks in a way that preserves old ones</span><span class="s1"> 
                                </span><span class="s2">for </span><span class="s1">( code </span><span class="s2">in </span><span class="s1">map ) { 
                                    statusCode[ code ] = [ statusCode[ code ], map[ code ] ]; 
                                } 
                            } 
                        } 
                        </span><span class="s2">return this</span><span class="s1">; 
                    }, 
 
                    </span><span class="s0">// Cancel the request</span><span class="s1"> 
                    abort: </span><span class="s2">function</span><span class="s1">( statusText ) { 
                        </span><span class="s2">var </span><span class="s1">finalText = statusText || strAbort; 
                        </span><span class="s2">if </span><span class="s1">( transport ) { 
                            transport.abort( finalText ); 
                        } 
                        done( </span><span class="s4">0</span><span class="s1">, finalText ); 
                        </span><span class="s2">return this</span><span class="s1">; 
                    } 
                }; 
 
            </span><span class="s0">// Attach deferreds</span><span class="s1"> 
            deferred.promise( jqXHR ); 
 
            </span><span class="s0">// Add protocol if not provided (prefilters might expect it)</span><span class="s1"> 
            </span><span class="s0">// Handle falsy url in the settings object (#10093: consistency with old signature)</span><span class="s1"> 
            </span><span class="s0">// We also use the url parameter if available</span><span class="s1"> 
            s.url = ( ( url || s.url || location.href ) + </span><span class="s3">&quot;&quot; </span><span class="s1">) 
                .replace( rprotocol, location.protocol + </span><span class="s3">&quot;//&quot; </span><span class="s1">); 
 
            </span><span class="s0">// Alias method option to type as per ticket #12004</span><span class="s1"> 
            s.type = options.method || options.type || s.method || s.type; 
 
            </span><span class="s0">// Extract dataTypes list</span><span class="s1"> 
            s.dataTypes = ( s.dataType || </span><span class="s3">&quot;*&quot; </span><span class="s1">).toLowerCase().match( rnothtmlwhite ) || [ </span><span class="s3">&quot;&quot; </span><span class="s1">]; 
 
            </span><span class="s0">// A cross-domain request is in order when the origin doesn't match the current origin.</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.crossDomain == </span><span class="s2">null </span><span class="s1">) { 
                urlAnchor = document.createElement( </span><span class="s3">&quot;a&quot; </span><span class="s1">); 
 
                </span><span class="s0">// Support: IE &lt;=8 - 11, Edge 12 - 13</span><span class="s1"> 
                </span><span class="s0">// IE throws exception on accessing the href property if url is malformed,</span><span class="s1"> 
                </span><span class="s0">// e.g. http://example.com:80x/</span><span class="s1"> 
                </span><span class="s2">try </span><span class="s1">{ 
                    urlAnchor.href = s.url; 
 
                    </span><span class="s0">// Support: IE &lt;=8 - 11 only</span><span class="s1"> 
                    </span><span class="s0">// Anchor's host property isn't correctly set when s.url is relative</span><span class="s1"> 
                    urlAnchor.href = urlAnchor.href; 
                    s.crossDomain = originAnchor.protocol + </span><span class="s3">&quot;//&quot; </span><span class="s1">+ originAnchor.host !== 
                        urlAnchor.protocol + </span><span class="s3">&quot;//&quot; </span><span class="s1">+ urlAnchor.host; 
                } </span><span class="s2">catch </span><span class="s1">( e ) { 
 
                    </span><span class="s0">// If there is an error parsing the URL, assume it is crossDomain,</span><span class="s1"> 
                    </span><span class="s0">// it can be rejected by the transport if it is invalid</span><span class="s1"> 
                    s.crossDomain = </span><span class="s2">true</span><span class="s1">; 
                } 
            } 
 
            </span><span class="s0">// Convert data if not already a string</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.data &amp;&amp; s.processData &amp;&amp; </span><span class="s2">typeof </span><span class="s1">s.data !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
                s.data = jQuery.param( s.data, s.traditional ); 
            } 
 
            </span><span class="s0">// Apply prefilters</span><span class="s1"> 
            inspectPrefiltersOrTransports( prefilters, s, options, jqXHR ); 
 
            </span><span class="s0">// If request was aborted inside a prefilter, stop there</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( completed ) { 
                </span><span class="s2">return </span><span class="s1">jqXHR; 
            } 
 
            </span><span class="s0">// We can fire global events as of now if asked to</span><span class="s1"> 
            </span><span class="s0">// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)</span><span class="s1"> 
            fireGlobals = jQuery.event &amp;&amp; s.global; 
 
            </span><span class="s0">// Watch for a new set of requests</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( fireGlobals &amp;&amp; jQuery.active++ === </span><span class="s4">0 </span><span class="s1">) { 
                jQuery.event.trigger( </span><span class="s3">&quot;ajaxStart&quot; </span><span class="s1">); 
            } 
 
            </span><span class="s0">// Uppercase the type</span><span class="s1"> 
            s.type = s.type.toUpperCase(); 
 
            </span><span class="s0">// Determine if request has content</span><span class="s1"> 
            s.hasContent = !rnoContent.test( s.type ); 
 
            </span><span class="s0">// Save the URL in case we're toying with the If-Modified-Since</span><span class="s1"> 
            </span><span class="s0">// and/or If-None-Match header later on</span><span class="s1"> 
            </span><span class="s0">// Remove hash to simplify url manipulation</span><span class="s1"> 
            cacheURL = s.url.replace( rhash, </span><span class="s3">&quot;&quot; </span><span class="s1">); 
 
            </span><span class="s0">// More options handling for requests with no content</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !s.hasContent ) { 
 
                </span><span class="s0">// Remember the hash so we can put it back</span><span class="s1"> 
                uncached = s.url.slice( cacheURL.length ); 
 
                </span><span class="s0">// If data is available, append data to url</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( s.data ) { 
                    cacheURL += ( rquery.test( cacheURL ) ? </span><span class="s3">&quot;&amp;&quot; </span><span class="s1">: </span><span class="s3">&quot;?&quot; </span><span class="s1">) + s.data; 
 
                    </span><span class="s0">// #9682: remove data so that it's not used in an eventual retry</span><span class="s1"> 
                    </span><span class="s2">delete </span><span class="s1">s.data; 
                } 
 
                </span><span class="s0">// Add or update anti-cache param if needed</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( s.cache === </span><span class="s2">false </span><span class="s1">) { 
                    cacheURL = cacheURL.replace( rantiCache, </span><span class="s3">&quot;$1&quot; </span><span class="s1">); 
                    uncached = ( rquery.test( cacheURL ) ? </span><span class="s3">&quot;&amp;&quot; </span><span class="s1">: </span><span class="s3">&quot;?&quot; </span><span class="s1">) + </span><span class="s3">&quot;_=&quot; </span><span class="s1">+ ( nonce++ ) + uncached; 
                } 
 
                </span><span class="s0">// Put hash and anti-cache on the URL that will be requested (gh-1732)</span><span class="s1"> 
                s.url = cacheURL + uncached; 
 
                </span><span class="s0">// Change '%20' to '+' if this is encoded form body content (gh-2658)</span><span class="s1"> 
            } </span><span class="s2">else if </span><span class="s1">( s.data &amp;&amp; s.processData &amp;&amp; 
                ( s.contentType || </span><span class="s3">&quot;&quot; </span><span class="s1">).indexOf( </span><span class="s3">&quot;application/x-www-form-urlencoded&quot; </span><span class="s1">) === </span><span class="s4">0 </span><span class="s1">) { 
                s.data = s.data.replace( r20, </span><span class="s3">&quot;+&quot; </span><span class="s1">); 
            } 
 
            </span><span class="s0">// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.ifModified ) { 
                </span><span class="s2">if </span><span class="s1">( jQuery.lastModified[ cacheURL ] ) { 
                    jqXHR.setRequestHeader( </span><span class="s3">&quot;If-Modified-Since&quot;</span><span class="s1">, jQuery.lastModified[ cacheURL ] ); 
                } 
                </span><span class="s2">if </span><span class="s1">( jQuery.etag[ cacheURL ] ) { 
                    jqXHR.setRequestHeader( </span><span class="s3">&quot;If-None-Match&quot;</span><span class="s1">, jQuery.etag[ cacheURL ] ); 
                } 
            } 
 
            </span><span class="s0">// Set the correct header, if data is being sent</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.data &amp;&amp; s.hasContent &amp;&amp; s.contentType !== </span><span class="s2">false </span><span class="s1">|| options.contentType ) { 
                jqXHR.setRequestHeader( </span><span class="s3">&quot;Content-Type&quot;</span><span class="s1">, s.contentType ); 
            } 
 
            </span><span class="s0">// Set the Accepts header for the server, depending on the dataType</span><span class="s1"> 
            jqXHR.setRequestHeader( 
                </span><span class="s3">&quot;Accept&quot;</span><span class="s1">, 
                s.dataTypes[ </span><span class="s4">0 </span><span class="s1">] &amp;&amp; s.accepts[ s.dataTypes[ </span><span class="s4">0 </span><span class="s1">] ] ? 
                s.accepts[ s.dataTypes[ </span><span class="s4">0 </span><span class="s1">] ] + 
                ( s.dataTypes[ </span><span class="s4">0 </span><span class="s1">] !== </span><span class="s3">&quot;*&quot; </span><span class="s1">? </span><span class="s3">&quot;, &quot; </span><span class="s1">+ allTypes + </span><span class="s3">&quot;; q=0.01&quot; </span><span class="s1">: </span><span class="s3">&quot;&quot; </span><span class="s1">) : 
                    s.accepts[ </span><span class="s3">&quot;*&quot; </span><span class="s1">] 
            ); 
 
            </span><span class="s0">// Check for headers option</span><span class="s1"> 
            </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">s.headers ) { 
                jqXHR.setRequestHeader( i, s.headers[ i ] ); 
            } 
 
            </span><span class="s0">// Allow custom headers/mimetypes and early abort</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( s.beforeSend &amp;&amp; 
                ( s.beforeSend.call( callbackContext, jqXHR, s ) === </span><span class="s2">false </span><span class="s1">|| completed ) ) { 
 
                </span><span class="s0">// Abort if not done already and return</span><span class="s1"> 
                </span><span class="s2">return </span><span class="s1">jqXHR.abort(); 
            } 
 
            </span><span class="s0">// Aborting is no longer a cancellation</span><span class="s1"> 
            strAbort = </span><span class="s3">&quot;abort&quot;</span><span class="s1">; 
 
            </span><span class="s0">// Install callbacks on deferreds</span><span class="s1"> 
            completeDeferred.add( s.complete ); 
            jqXHR.done( s.success ); 
            jqXHR.fail( s.error ); 
 
            </span><span class="s0">// Get transport</span><span class="s1"> 
            transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR ); 
 
            </span><span class="s0">// If no transport, we auto-abort</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !transport ) { 
                done( -</span><span class="s4">1</span><span class="s1">, </span><span class="s3">&quot;No Transport&quot; </span><span class="s1">); 
            } </span><span class="s2">else </span><span class="s1">{ 
                jqXHR.readyState = </span><span class="s4">1</span><span class="s1">; 
 
                </span><span class="s0">// Send global event</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( fireGlobals ) { 
                    globalEventContext.trigger( </span><span class="s3">&quot;ajaxSend&quot;</span><span class="s1">, [ jqXHR, s ] ); 
                } 
 
                </span><span class="s0">// If request was aborted inside ajaxSend, stop there</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( completed ) { 
                    </span><span class="s2">return </span><span class="s1">jqXHR; 
                } 
 
                </span><span class="s0">// Timeout</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( s.async &amp;&amp; s.timeout &gt; </span><span class="s4">0 </span><span class="s1">) { 
                    timeoutTimer = window.setTimeout( </span><span class="s2">function</span><span class="s1">() { 
                        jqXHR.abort( </span><span class="s3">&quot;timeout&quot; </span><span class="s1">); 
                    }, s.timeout ); 
                } 
 
                </span><span class="s2">try </span><span class="s1">{ 
                    completed = </span><span class="s2">false</span><span class="s1">; 
                    transport.send( requestHeaders, done ); 
                } </span><span class="s2">catch </span><span class="s1">( e ) { 
 
                    </span><span class="s0">// Rethrow post-completion exceptions</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( completed ) { 
                        </span><span class="s2">throw </span><span class="s1">e; 
                    } 
 
                    </span><span class="s0">// Propagate others as results</span><span class="s1"> 
                    done( -</span><span class="s4">1</span><span class="s1">, e ); 
                } 
            } 
 
            </span><span class="s0">// Callback for when everything is done</span><span class="s1"> 
            </span><span class="s2">function </span><span class="s1">done( status, nativeStatusText, responses, headers ) { 
                </span><span class="s2">var </span><span class="s1">isSuccess, success, error, response, modified, 
                    statusText = nativeStatusText; 
 
                </span><span class="s0">// Ignore repeat invocations</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( completed ) { 
                    </span><span class="s2">return</span><span class="s1">; 
                } 
 
                completed = </span><span class="s2">true</span><span class="s1">; 
 
                </span><span class="s0">// Clear timeout if it exists</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( timeoutTimer ) { 
                    window.clearTimeout( timeoutTimer ); 
                } 
 
                </span><span class="s0">// Dereference transport for early garbage collection</span><span class="s1"> 
                </span><span class="s0">// (no matter how long the jqXHR object will be used)</span><span class="s1"> 
                transport = undefined; 
 
                </span><span class="s0">// Cache response headers</span><span class="s1"> 
                responseHeadersString = headers || </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
                </span><span class="s0">// Set readyState</span><span class="s1"> 
                jqXHR.readyState = status &gt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">4 </span><span class="s1">: </span><span class="s4">0</span><span class="s1">; 
 
                </span><span class="s0">// Determine if successful</span><span class="s1"> 
                isSuccess = status &gt;= </span><span class="s4">200 </span><span class="s1">&amp;&amp; status &lt; </span><span class="s4">300 </span><span class="s1">|| status === </span><span class="s4">304</span><span class="s1">; 
 
                </span><span class="s0">// Get response data</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( responses ) { 
                    response = ajaxHandleResponses( s, jqXHR, responses ); 
                } 
 
                </span><span class="s0">// Convert no matter what (that way responseXXX fields are always set)</span><span class="s1"> 
                response = ajaxConvert( s, response, jqXHR, isSuccess ); 
 
                </span><span class="s0">// If successful, handle type chaining</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( isSuccess ) { 
 
                    </span><span class="s0">// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( s.ifModified ) { 
                        modified = jqXHR.getResponseHeader( </span><span class="s3">&quot;Last-Modified&quot; </span><span class="s1">); 
                        </span><span class="s2">if </span><span class="s1">( modified ) { 
                            jQuery.lastModified[ cacheURL ] = modified; 
                        } 
                        modified = jqXHR.getResponseHeader( </span><span class="s3">&quot;etag&quot; </span><span class="s1">); 
                        </span><span class="s2">if </span><span class="s1">( modified ) { 
                            jQuery.etag[ cacheURL ] = modified; 
                        } 
                    } 
 
                    </span><span class="s0">// if no content</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( status === </span><span class="s4">204 </span><span class="s1">|| s.type === </span><span class="s3">&quot;HEAD&quot; </span><span class="s1">) { 
                        statusText = </span><span class="s3">&quot;nocontent&quot;</span><span class="s1">; 
 
                        </span><span class="s0">// if not modified</span><span class="s1"> 
                    } </span><span class="s2">else if </span><span class="s1">( status === </span><span class="s4">304 </span><span class="s1">) { 
                        statusText = </span><span class="s3">&quot;notmodified&quot;</span><span class="s1">; 
 
                        </span><span class="s0">// If we have data, let's convert it</span><span class="s1"> 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        statusText = response.state; 
                        success = response.data; 
                        error = response.error; 
                        isSuccess = !error; 
                    } 
                } </span><span class="s2">else </span><span class="s1">{ 
 
                    </span><span class="s0">// Extract error from statusText and normalize for non-aborts</span><span class="s1"> 
                    error = statusText; 
                    </span><span class="s2">if </span><span class="s1">( status || !statusText ) { 
                        statusText = </span><span class="s3">&quot;error&quot;</span><span class="s1">; 
                        </span><span class="s2">if </span><span class="s1">( status &lt; </span><span class="s4">0 </span><span class="s1">) { 
                            status = </span><span class="s4">0</span><span class="s1">; 
                        } 
                    } 
                } 
 
                </span><span class="s0">// Set data for the fake xhr object</span><span class="s1"> 
                jqXHR.status = status; 
                jqXHR.statusText = ( nativeStatusText || statusText ) + </span><span class="s3">&quot;&quot;</span><span class="s1">; 
 
                </span><span class="s0">// Success/Error</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( isSuccess ) { 
                    deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] ); 
                } </span><span class="s2">else </span><span class="s1">{ 
                    deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] ); 
                } 
 
                </span><span class="s0">// Status-dependent callbacks</span><span class="s1"> 
                jqXHR.statusCode( statusCode ); 
                statusCode = undefined; 
 
                </span><span class="s2">if </span><span class="s1">( fireGlobals ) { 
                    globalEventContext.trigger( isSuccess ? </span><span class="s3">&quot;ajaxSuccess&quot; </span><span class="s1">: </span><span class="s3">&quot;ajaxError&quot;</span><span class="s1">, 
                        [ jqXHR, s, isSuccess ? success : error ] ); 
                } 
 
                </span><span class="s0">// Complete</span><span class="s1"> 
                completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] ); 
 
                </span><span class="s2">if </span><span class="s1">( fireGlobals ) { 
                    globalEventContext.trigger( </span><span class="s3">&quot;ajaxComplete&quot;</span><span class="s1">, [ jqXHR, s ] ); 
 
                    </span><span class="s0">// Handle the global AJAX counter</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !( --jQuery.active ) ) { 
                        jQuery.event.trigger( </span><span class="s3">&quot;ajaxStop&quot; </span><span class="s1">); 
                    } 
                } 
            } 
 
            </span><span class="s2">return </span><span class="s1">jqXHR; 
        }, 
 
        getJSON: </span><span class="s2">function</span><span class="s1">( url, data, callback ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.get( url, data, callback, </span><span class="s3">&quot;json&quot; </span><span class="s1">); 
        }, 
 
        getScript: </span><span class="s2">function</span><span class="s1">( url, callback ) { 
            </span><span class="s2">return </span><span class="s1">jQuery.get( url, undefined, callback, </span><span class="s3">&quot;script&quot; </span><span class="s1">); 
        } 
    } ); 
 
    jQuery.each( [ </span><span class="s3">&quot;get&quot;</span><span class="s1">, </span><span class="s3">&quot;post&quot; </span><span class="s1">], </span><span class="s2">function</span><span class="s1">( i, method ) { 
        jQuery[ method ] = </span><span class="s2">function</span><span class="s1">( url, data, callback, type ) { 
 
            </span><span class="s0">// Shift arguments if data argument was omitted</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( data ) ) { 
                type = type || callback; 
                callback = data; 
                data = undefined; 
            } 
 
            </span><span class="s0">// The url can be an options object (which then must have .url)</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">jQuery.ajax( jQuery.extend( { 
                url: url, 
                type: method, 
                dataType: type, 
                data: data, 
                success: callback 
            }, jQuery.isPlainObject( url ) &amp;&amp; url ) ); 
        }; 
    } ); 
 
 
    jQuery._evalUrl = </span><span class="s2">function</span><span class="s1">( url ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.ajax( { 
            url: url, 
 
            </span><span class="s0">// Make this explicit, since user can override this through ajaxSetup (#11264)</span><span class="s1"> 
            type: </span><span class="s3">&quot;GET&quot;</span><span class="s1">, 
            dataType: </span><span class="s3">&quot;script&quot;</span><span class="s1">, 
            cache: </span><span class="s2">true</span><span class="s1">, 
            async: </span><span class="s2">false</span><span class="s1">, 
            global: </span><span class="s2">false</span><span class="s1">, 
            </span><span class="s3">&quot;throws&quot;</span><span class="s1">: </span><span class="s2">true</span><span class="s1"> 
        } ); 
    }; 
 
 
    jQuery.fn.extend( { 
        wrapAll: </span><span class="s2">function</span><span class="s1">( html ) { 
            </span><span class="s2">var </span><span class="s1">wrap; 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] ) { 
                </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( html ) ) { 
                    html = html.call( </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] ); 
                } 
 
                </span><span class="s0">// The elements to wrap the target around</span><span class="s1"> 
                wrap = jQuery( html, </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">].ownerDocument ).eq( </span><span class="s4">0 </span><span class="s1">).clone( </span><span class="s2">true </span><span class="s1">); 
 
                </span><span class="s2">if </span><span class="s1">( </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">].parentNode ) { 
                    wrap.insertBefore( </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] ); 
                } 
 
                wrap.map( </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">var </span><span class="s1">elem = </span><span class="s2">this</span><span class="s1">; 
 
                    </span><span class="s2">while </span><span class="s1">( elem.firstElementChild ) { 
                        elem = elem.firstElementChild; 
                    } 
 
                    </span><span class="s2">return </span><span class="s1">elem; 
                } ).append( </span><span class="s2">this </span><span class="s1">); 
            } 
 
            </span><span class="s2">return this</span><span class="s1">; 
        }, 
 
        wrapInner: </span><span class="s2">function</span><span class="s1">( html ) { 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( html ) ) { 
                </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( i ) { 
                    jQuery( </span><span class="s2">this </span><span class="s1">).wrapInner( html.call( </span><span class="s2">this</span><span class="s1">, i ) ); 
                } ); 
            } 
 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">self = jQuery( </span><span class="s2">this </span><span class="s1">), 
                    contents = self.contents(); 
 
                </span><span class="s2">if </span><span class="s1">( contents.length ) { 
                    contents.wrapAll( html ); 
 
                } </span><span class="s2">else </span><span class="s1">{ 
                    self.append( html ); 
                } 
            } ); 
        }, 
 
        wrap: </span><span class="s2">function</span><span class="s1">( html ) { 
            </span><span class="s2">var </span><span class="s1">isFunction = jQuery.isFunction( html ); 
 
            </span><span class="s2">return this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( i ) { 
                jQuery( </span><span class="s2">this </span><span class="s1">).wrapAll( isFunction ? html.call( </span><span class="s2">this</span><span class="s1">, i ) : html ); 
            } ); 
        }, 
 
        unwrap: </span><span class="s2">function</span><span class="s1">( selector ) { 
            </span><span class="s2">this</span><span class="s1">.parent( selector ).not( </span><span class="s3">&quot;body&quot; </span><span class="s1">).each( </span><span class="s2">function</span><span class="s1">() { 
                jQuery( </span><span class="s2">this </span><span class="s1">).replaceWith( </span><span class="s2">this</span><span class="s1">.childNodes ); 
            } ); 
            </span><span class="s2">return this</span><span class="s1">; 
        } 
    } ); 
 
 
    jQuery.expr.pseudos.hidden = </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">!jQuery.expr.pseudos.visible( elem ); 
    }; 
    jQuery.expr.pseudos.visible = </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">!!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length ); 
    }; 
 
 
 
 
    jQuery.ajaxSettings.xhr = </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">try </span><span class="s1">{ 
            </span><span class="s2">return new </span><span class="s1">window.XMLHttpRequest(); 
        } </span><span class="s2">catch </span><span class="s1">( e ) {} 
    }; 
 
    </span><span class="s2">var </span><span class="s1">xhrSuccessStatus = { 
 
            </span><span class="s0">// File protocol always yields status code 0, assume 200</span><span class="s1"> 
            </span><span class="s4">0</span><span class="s1">: </span><span class="s4">200</span><span class="s1">, 
 
            </span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
            </span><span class="s0">// #1450: sometimes IE returns 1223 when it should be 204</span><span class="s1"> 
            </span><span class="s4">1223</span><span class="s1">: </span><span class="s4">204</span><span class="s1"> 
        }, 
        xhrSupported = jQuery.ajaxSettings.xhr(); 
 
    support.cors = !!xhrSupported &amp;&amp; ( </span><span class="s3">&quot;withCredentials&quot; </span><span class="s2">in </span><span class="s1">xhrSupported ); 
    support.ajax = xhrSupported = !!xhrSupported; 
 
    jQuery.ajaxTransport( </span><span class="s2">function</span><span class="s1">( options ) { 
        </span><span class="s2">var </span><span class="s1">callback, errorCallback; 
 
        </span><span class="s0">// Cross domain only allowed if supported through XMLHttpRequest</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( support.cors || xhrSupported &amp;&amp; !options.crossDomain ) { 
            </span><span class="s2">return </span><span class="s1">{ 
                send: </span><span class="s2">function</span><span class="s1">( headers, complete ) { 
                    </span><span class="s2">var </span><span class="s1">i, 
                        xhr = options.xhr(); 
 
                    xhr.open( 
                        options.type, 
                        options.url, 
                        options.async, 
                        options.username, 
                        options.password 
                    ); 
 
                    </span><span class="s0">// Apply custom fields if provided</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( options.xhrFields ) { 
                        </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">options.xhrFields ) { 
                            xhr[ i ] = options.xhrFields[ i ]; 
                        } 
                    } 
 
                    </span><span class="s0">// Override mime type if needed</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( options.mimeType &amp;&amp; xhr.overrideMimeType ) { 
                        xhr.overrideMimeType( options.mimeType ); 
                    } 
 
                    </span><span class="s0">// X-Requested-With header</span><span class="s1"> 
                    </span><span class="s0">// For cross-domain requests, seeing as conditions for a preflight are</span><span class="s1"> 
                    </span><span class="s0">// akin to a jigsaw puzzle, we simply never set it to be sure.</span><span class="s1"> 
                    </span><span class="s0">// (it can always be set on a per-request basis or even using ajaxSetup)</span><span class="s1"> 
                    </span><span class="s0">// For same-domain requests, won't change header if already provided.</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( !options.crossDomain &amp;&amp; !headers[ </span><span class="s3">&quot;X-Requested-With&quot; </span><span class="s1">] ) { 
                        headers[ </span><span class="s3">&quot;X-Requested-With&quot; </span><span class="s1">] = </span><span class="s3">&quot;XMLHttpRequest&quot;</span><span class="s1">; 
                    } 
 
                    </span><span class="s0">// Set headers</span><span class="s1"> 
                    </span><span class="s2">for </span><span class="s1">( i </span><span class="s2">in </span><span class="s1">headers ) { 
                        xhr.setRequestHeader( i, headers[ i ] ); 
                    } 
 
                    </span><span class="s0">// Callback</span><span class="s1"> 
                    callback = </span><span class="s2">function</span><span class="s1">( type ) { 
                        </span><span class="s2">return function</span><span class="s1">() { 
                            </span><span class="s2">if </span><span class="s1">( callback ) { 
                                callback = errorCallback = xhr.onload = 
                                    xhr.onerror = xhr.onabort = xhr.onreadystatechange = </span><span class="s2">null</span><span class="s1">; 
 
                                </span><span class="s2">if </span><span class="s1">( type === </span><span class="s3">&quot;abort&quot; </span><span class="s1">) { 
                                    xhr.abort(); 
                                } </span><span class="s2">else if </span><span class="s1">( type === </span><span class="s3">&quot;error&quot; </span><span class="s1">) { 
 
                                    </span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
                                    </span><span class="s0">// On a manual native abort, IE9 throws</span><span class="s1"> 
                                    </span><span class="s0">// errors on any property access that is not readyState</span><span class="s1"> 
                                    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">xhr.status !== </span><span class="s3">&quot;number&quot; </span><span class="s1">) { 
                                        complete( </span><span class="s4">0</span><span class="s1">, </span><span class="s3">&quot;error&quot; </span><span class="s1">); 
                                    } </span><span class="s2">else </span><span class="s1">{ 
                                        complete( 
 
                                            </span><span class="s0">// File: protocol always yields status 0; see #8605, #14207</span><span class="s1"> 
                                            xhr.status, 
                                            xhr.statusText 
                                        ); 
                                    } 
                                } </span><span class="s2">else </span><span class="s1">{ 
                                    complete( 
                                        xhrSuccessStatus[ xhr.status ] || xhr.status, 
                                        xhr.statusText, 
 
                                        </span><span class="s0">// Support: IE &lt;=9 only</span><span class="s1"> 
                                        </span><span class="s0">// IE9 has no XHR2 but throws on binary (trac-11426)</span><span class="s1"> 
                                        </span><span class="s0">// For XHR2 non-text, let the caller handle it (gh-2498)</span><span class="s1"> 
                                        ( xhr.responseType || </span><span class="s3">&quot;text&quot; </span><span class="s1">) !== </span><span class="s3">&quot;text&quot;  </span><span class="s1">|| 
                                        </span><span class="s2">typeof </span><span class="s1">xhr.responseText !== </span><span class="s3">&quot;string&quot; </span><span class="s1">? 
                                        { binary: xhr.response } : 
                                        { text: xhr.responseText }, 
                                        xhr.getAllResponseHeaders() 
                                    ); 
                                } 
                            } 
                        }; 
                    }; 
 
                    </span><span class="s0">// Listen to events</span><span class="s1"> 
                    xhr.onload = callback(); 
                    errorCallback = xhr.onerror = callback( </span><span class="s3">&quot;error&quot; </span><span class="s1">); 
 
                    </span><span class="s0">// Support: IE 9 only</span><span class="s1"> 
                    </span><span class="s0">// Use onreadystatechange to replace onabort</span><span class="s1"> 
                    </span><span class="s0">// to handle uncaught aborts</span><span class="s1"> 
                    </span><span class="s2">if </span><span class="s1">( xhr.onabort !== undefined ) { 
                        xhr.onabort = errorCallback; 
                    } </span><span class="s2">else </span><span class="s1">{ 
                        xhr.onreadystatechange = </span><span class="s2">function</span><span class="s1">() { 
 
                            </span><span class="s0">// Check readyState before timeout as it changes</span><span class="s1"> 
                            </span><span class="s2">if </span><span class="s1">( xhr.readyState === </span><span class="s4">4 </span><span class="s1">) { 
 
                                </span><span class="s0">// Allow onerror to be called first,</span><span class="s1"> 
                                </span><span class="s0">// but that will not handle a native abort</span><span class="s1"> 
                                </span><span class="s0">// Also, save errorCallback to a variable</span><span class="s1"> 
                                </span><span class="s0">// as xhr.onerror cannot be accessed</span><span class="s1"> 
                                window.setTimeout( </span><span class="s2">function</span><span class="s1">() { 
                                    </span><span class="s2">if </span><span class="s1">( callback ) { 
                                        errorCallback(); 
                                    } 
                                } ); 
                            } 
                        }; 
                    } 
 
                    </span><span class="s0">// Create the abort callback</span><span class="s1"> 
                    callback = callback( </span><span class="s3">&quot;abort&quot; </span><span class="s1">); 
 
                    </span><span class="s2">try </span><span class="s1">{ 
 
                        </span><span class="s0">// Do send the request (this may raise an exception)</span><span class="s1"> 
                        xhr.send( options.hasContent &amp;&amp; options.data || </span><span class="s2">null </span><span class="s1">); 
                    } </span><span class="s2">catch </span><span class="s1">( e ) { 
 
                        </span><span class="s0">// #14683: Only rethrow if this hasn't been notified as an error yet</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( callback ) { 
                            </span><span class="s2">throw </span><span class="s1">e; 
                        } 
                    } 
                }, 
 
                abort: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( callback ) { 
                        callback(); 
                    } 
                } 
            }; 
        } 
    } ); 
 
 
 
 
</span><span class="s0">// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)</span><span class="s1"> 
    jQuery.ajaxPrefilter( </span><span class="s2">function</span><span class="s1">( s ) { 
        </span><span class="s2">if </span><span class="s1">( s.crossDomain ) { 
            s.contents.script = </span><span class="s2">false</span><span class="s1">; 
        } 
    } ); 
 
</span><span class="s0">// Install script dataType</span><span class="s1"> 
    jQuery.ajaxSetup( { 
        accepts: { 
            script: </span><span class="s3">&quot;text/javascript, application/javascript, &quot; </span><span class="s1">+ 
            </span><span class="s3">&quot;application/ecmascript, application/x-ecmascript&quot;</span><span class="s1"> 
        }, 
        contents: { 
            script: </span><span class="s4">/\b(?:java|ecma)script\b/</span><span class="s1"> 
        }, 
        converters: { 
            </span><span class="s3">&quot;text script&quot;</span><span class="s1">: </span><span class="s2">function</span><span class="s1">( text ) { 
                jQuery.globalEval( text ); 
                </span><span class="s2">return </span><span class="s1">text; 
            } 
        } 
    } ); 
 
</span><span class="s0">// Handle cache's special case and crossDomain</span><span class="s1"> 
    jQuery.ajaxPrefilter( </span><span class="s3">&quot;script&quot;</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( s ) { 
        </span><span class="s2">if </span><span class="s1">( s.cache === undefined ) { 
            s.cache = </span><span class="s2">false</span><span class="s1">; 
        } 
        </span><span class="s2">if </span><span class="s1">( s.crossDomain ) { 
            s.type = </span><span class="s3">&quot;GET&quot;</span><span class="s1">; 
        } 
    } ); 
 
</span><span class="s0">// Bind script tag hack transport</span><span class="s1"> 
    jQuery.ajaxTransport( </span><span class="s3">&quot;script&quot;</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( s ) { 
 
        </span><span class="s0">// This transport only deals with cross domain requests</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( s.crossDomain ) { 
            </span><span class="s2">var </span><span class="s1">script, callback; 
            </span><span class="s2">return </span><span class="s1">{ 
                send: </span><span class="s2">function</span><span class="s1">( _, complete ) { 
                    script = jQuery( </span><span class="s3">&quot;&lt;script&gt;&quot; </span><span class="s1">).prop( { 
                        charset: s.scriptCharset, 
                        src: s.url 
                    } ).on( 
                        </span><span class="s3">&quot;load error&quot;</span><span class="s1">, 
                        callback = </span><span class="s2">function</span><span class="s1">( evt ) { 
                            script.remove(); 
                            callback = </span><span class="s2">null</span><span class="s1">; 
                            </span><span class="s2">if </span><span class="s1">( evt ) { 
                                complete( evt.type === </span><span class="s3">&quot;error&quot; </span><span class="s1">? </span><span class="s4">404 </span><span class="s1">: </span><span class="s4">200</span><span class="s1">, evt.type ); 
                            } 
                        } 
                    ); 
 
                    </span><span class="s0">// Use native DOM manipulation to avoid our domManip AJAX trickery</span><span class="s1"> 
                    document.head.appendChild( script[ </span><span class="s4">0 </span><span class="s1">] ); 
                }, 
                abort: </span><span class="s2">function</span><span class="s1">() { 
                    </span><span class="s2">if </span><span class="s1">( callback ) { 
                        callback(); 
                    } 
                } 
            }; 
        } 
    } ); 
 
 
 
 
    </span><span class="s2">var </span><span class="s1">oldCallbacks = [], 
        rjsonp = </span><span class="s4">/(=)\?(?=&amp;|$)|\?\?/</span><span class="s1">; 
 
</span><span class="s0">// Default jsonp settings</span><span class="s1"> 
    jQuery.ajaxSetup( { 
        jsonp: </span><span class="s3">&quot;callback&quot;</span><span class="s1">, 
        jsonpCallback: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">var </span><span class="s1">callback = oldCallbacks.pop() || ( jQuery.expando + </span><span class="s3">&quot;_&quot; </span><span class="s1">+ ( nonce++ ) ); 
            </span><span class="s2">this</span><span class="s1">[ callback ] = </span><span class="s2">true</span><span class="s1">; 
            </span><span class="s2">return </span><span class="s1">callback; 
        } 
    } ); 
 
</span><span class="s0">// Detect, normalize options and install callbacks for jsonp requests</span><span class="s1"> 
    jQuery.ajaxPrefilter( </span><span class="s3">&quot;json jsonp&quot;</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( s, originalSettings, jqXHR ) { 
 
        </span><span class="s2">var </span><span class="s1">callbackName, overwritten, responseContainer, 
            jsonProp = s.jsonp !== </span><span class="s2">false </span><span class="s1">&amp;&amp; ( rjsonp.test( s.url ) ? 
                        </span><span class="s3">&quot;url&quot; </span><span class="s1">: 
                    </span><span class="s2">typeof </span><span class="s1">s.data === </span><span class="s3">&quot;string&quot; </span><span class="s1">&amp;&amp; 
                    ( s.contentType || </span><span class="s3">&quot;&quot; </span><span class="s1">) 
                        .indexOf( </span><span class="s3">&quot;application/x-www-form-urlencoded&quot; </span><span class="s1">) === </span><span class="s4">0 </span><span class="s1">&amp;&amp; 
                    rjsonp.test( s.data ) &amp;&amp; </span><span class="s3">&quot;data&quot;</span><span class="s1"> 
                ); 
 
        </span><span class="s0">// Handle iff the expected data type is &quot;jsonp&quot; or we have a parameter to set</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jsonProp || s.dataTypes[ </span><span class="s4">0 </span><span class="s1">] === </span><span class="s3">&quot;jsonp&quot; </span><span class="s1">) { 
 
            </span><span class="s0">// Get callback name, remembering preexisting value associated with it</span><span class="s1"> 
            callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ? 
                s.jsonpCallback() : 
                s.jsonpCallback; 
 
            </span><span class="s0">// Insert callback into url or form data</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jsonProp ) { 
                s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, </span><span class="s3">&quot;$1&quot; </span><span class="s1">+ callbackName ); 
            } </span><span class="s2">else if </span><span class="s1">( s.jsonp !== </span><span class="s2">false </span><span class="s1">) { 
                s.url += ( rquery.test( s.url ) ? </span><span class="s3">&quot;&amp;&quot; </span><span class="s1">: </span><span class="s3">&quot;?&quot; </span><span class="s1">) + s.jsonp + </span><span class="s3">&quot;=&quot; </span><span class="s1">+ callbackName; 
            } 
 
            </span><span class="s0">// Use data converter to retrieve json after script execution</span><span class="s1"> 
            s.converters[ </span><span class="s3">&quot;script json&quot; </span><span class="s1">] = </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">if </span><span class="s1">( !responseContainer ) { 
                    jQuery.error( callbackName + </span><span class="s3">&quot; was not called&quot; </span><span class="s1">); 
                } 
                </span><span class="s2">return </span><span class="s1">responseContainer[ </span><span class="s4">0 </span><span class="s1">]; 
            }; 
 
            </span><span class="s0">// Force json dataType</span><span class="s1"> 
            s.dataTypes[ </span><span class="s4">0 </span><span class="s1">] = </span><span class="s3">&quot;json&quot;</span><span class="s1">; 
 
            </span><span class="s0">// Install callback</span><span class="s1"> 
            overwritten = window[ callbackName ]; 
            window[ callbackName ] = </span><span class="s2">function</span><span class="s1">() { 
                responseContainer = arguments; 
            }; 
 
            </span><span class="s0">// Clean-up function (fires after converters)</span><span class="s1"> 
            jqXHR.always( </span><span class="s2">function</span><span class="s1">() { 
 
                </span><span class="s0">// If previous value didn't exist - remove it</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( overwritten === undefined ) { 
                    jQuery( window ).removeProp( callbackName ); 
 
                    </span><span class="s0">// Otherwise restore preexisting value</span><span class="s1"> 
                } </span><span class="s2">else </span><span class="s1">{ 
                    window[ callbackName ] = overwritten; 
                } 
 
                </span><span class="s0">// Save back as free</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( s[ callbackName ] ) { 
 
                    </span><span class="s0">// Make sure that re-using the options doesn't screw things around</span><span class="s1"> 
                    s.jsonpCallback = originalSettings.jsonpCallback; 
 
                    </span><span class="s0">// Save the callback name for future use</span><span class="s1"> 
                    oldCallbacks.push( callbackName ); 
                } 
 
                </span><span class="s0">// Call if it was a function and we have a response</span><span class="s1"> 
                </span><span class="s2">if </span><span class="s1">( responseContainer &amp;&amp; jQuery.isFunction( overwritten ) ) { 
                    overwritten( responseContainer[ </span><span class="s4">0 </span><span class="s1">] ); 
                } 
 
                responseContainer = overwritten = undefined; 
            } ); 
 
            </span><span class="s0">// Delegate to script</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s3">&quot;script&quot;</span><span class="s1">; 
        } 
    } ); 
 
 
 
 
</span><span class="s0">// Support: Safari 8 only</span><span class="s1"> 
</span><span class="s0">// In Safari 8 documents created via document.implementation.createHTMLDocument</span><span class="s1"> 
</span><span class="s0">// collapse sibling forms: the second one becomes a child of the first one.</span><span class="s1"> 
</span><span class="s0">// Because of that, this security measure has to be disabled in Safari 8.</span><span class="s1"> 
</span><span class="s0">// https://bugs.webkit.org/show_bug.cgi?id=137337</span><span class="s1"> 
    support.createHTMLDocument = ( </span><span class="s2">function</span><span class="s1">() { 
        </span><span class="s2">var </span><span class="s1">body = document.implementation.createHTMLDocument( </span><span class="s3">&quot;&quot; </span><span class="s1">).body; 
        body.innerHTML = </span><span class="s3">&quot;&lt;form&gt;&lt;/form&gt;&lt;form&gt;&lt;/form&gt;&quot;</span><span class="s1">; 
        </span><span class="s2">return </span><span class="s1">body.childNodes.length === </span><span class="s4">2</span><span class="s1">; 
    } )(); 
 
 
</span><span class="s0">// Argument &quot;data&quot; should be string of html</span><span class="s1"> 
</span><span class="s0">// context (optional): If specified, the fragment will be created in this context,</span><span class="s1"> 
</span><span class="s0">// defaults to document</span><span class="s1"> 
</span><span class="s0">// keepScripts (optional): If true, will include scripts passed in the html string</span><span class="s1"> 
    jQuery.parseHTML = </span><span class="s2">function</span><span class="s1">( data, context, keepScripts ) { 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">data !== </span><span class="s3">&quot;string&quot; </span><span class="s1">) { 
            </span><span class="s2">return </span><span class="s1">[]; 
        } 
        </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">context === </span><span class="s3">&quot;boolean&quot; </span><span class="s1">) { 
            keepScripts = context; 
            context = </span><span class="s2">false</span><span class="s1">; 
        } 
 
        </span><span class="s2">var </span><span class="s1">base, parsed, scripts; 
 
        </span><span class="s2">if </span><span class="s1">( !context ) { 
 
            </span><span class="s0">// Stop scripts or inline event handlers from being executed immediately</span><span class="s1"> 
            </span><span class="s0">// by using document.implementation</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( support.createHTMLDocument ) { 
                context = document.implementation.createHTMLDocument( </span><span class="s3">&quot;&quot; </span><span class="s1">); 
 
                </span><span class="s0">// Set the base href for the created document</span><span class="s1"> 
                </span><span class="s0">// so any parsed elements with URLs</span><span class="s1"> 
                </span><span class="s0">// are based on the document's URL (gh-2965)</span><span class="s1"> 
                base = context.createElement( </span><span class="s3">&quot;base&quot; </span><span class="s1">); 
                base.href = document.location.href; 
                context.head.appendChild( base ); 
            } </span><span class="s2">else </span><span class="s1">{ 
                context = document; 
            } 
        } 
 
        parsed = rsingleTag.exec( data ); 
        scripts = !keepScripts &amp;&amp; []; 
 
        </span><span class="s0">// Single tag</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( parsed ) { 
            </span><span class="s2">return </span><span class="s1">[ context.createElement( parsed[ </span><span class="s4">1 </span><span class="s1">] ) ]; 
        } 
 
        parsed = buildFragment( [ data ], context, scripts ); 
 
        </span><span class="s2">if </span><span class="s1">( scripts &amp;&amp; scripts.length ) { 
            jQuery( scripts ).remove(); 
        } 
 
        </span><span class="s2">return </span><span class="s1">jQuery.merge( [], parsed.childNodes ); 
    }; 
 
 
    </span><span class="s0">/** 
     * Load a url into a page 
     */</span><span class="s1"> 
    jQuery.fn.load = </span><span class="s2">function</span><span class="s1">( url, params, callback ) { 
        </span><span class="s2">var </span><span class="s1">selector, type, response, 
            self = </span><span class="s2">this</span><span class="s1">, 
            off = url.indexOf( </span><span class="s3">&quot; &quot; </span><span class="s1">); 
 
        </span><span class="s2">if </span><span class="s1">( off &gt; -</span><span class="s4">1 </span><span class="s1">) { 
            selector = stripAndCollapse( url.slice( off ) ); 
            url = url.slice( </span><span class="s4">0</span><span class="s1">, off ); 
        } 
 
        </span><span class="s0">// If it's a function</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( params ) ) { 
 
            </span><span class="s0">// We assume that it's the callback</span><span class="s1"> 
            callback = params; 
            params = undefined; 
 
            </span><span class="s0">// Otherwise, build a param string</span><span class="s1"> 
        } </span><span class="s2">else if </span><span class="s1">( params &amp;&amp; </span><span class="s2">typeof </span><span class="s1">params === </span><span class="s3">&quot;object&quot; </span><span class="s1">) { 
            type = </span><span class="s3">&quot;POST&quot;</span><span class="s1">; 
        } 
 
        </span><span class="s0">// If we have elements to modify, make the request</span><span class="s1"> 
        </span><span class="s2">if </span><span class="s1">( self.length &gt; </span><span class="s4">0 </span><span class="s1">) { 
            jQuery.ajax( { 
                url: url, 
 
                </span><span class="s0">// If &quot;type&quot; variable is undefined, then &quot;GET&quot; method will be used.</span><span class="s1"> 
                </span><span class="s0">// Make value of this field explicit since</span><span class="s1"> 
                </span><span class="s0">// user can override it through ajaxSetup method</span><span class="s1"> 
                type: type || </span><span class="s3">&quot;GET&quot;</span><span class="s1">, 
                dataType: </span><span class="s3">&quot;html&quot;</span><span class="s1">, 
                data: params 
            } ).done( </span><span class="s2">function</span><span class="s1">( responseText ) { 
 
                </span><span class="s0">// Save response for use in complete callback</span><span class="s1"> 
                response = arguments; 
 
                self.html( selector ? 
 
                    </span><span class="s0">// If a selector was specified, locate the right elements in a dummy div</span><span class="s1"> 
                    </span><span class="s0">// Exclude scripts to avoid IE 'Permission Denied' errors</span><span class="s1"> 
                    jQuery( </span><span class="s3">&quot;&lt;div&gt;&quot; </span><span class="s1">).append( jQuery.parseHTML( responseText ) ).find( selector ) : 
 
                    </span><span class="s0">// Otherwise use the full result</span><span class="s1"> 
                    responseText ); 
 
                </span><span class="s0">// If the request succeeds, this function gets &quot;data&quot;, &quot;status&quot;, &quot;jqXHR&quot;</span><span class="s1"> 
                </span><span class="s0">// but they are ignored because response was set above.</span><span class="s1"> 
                </span><span class="s0">// If it fails, this function gets &quot;jqXHR&quot;, &quot;status&quot;, &quot;error&quot;</span><span class="s1"> 
            } ).always( callback &amp;&amp; </span><span class="s2">function</span><span class="s1">( jqXHR, status ) { 
                    self.each( </span><span class="s2">function</span><span class="s1">() { 
                        callback.apply( </span><span class="s2">this</span><span class="s1">, response || [ jqXHR.responseText, status, jqXHR ] ); 
                    } ); 
                } ); 
        } 
 
        </span><span class="s2">return this</span><span class="s1">; 
    }; 
 
 
 
 
</span><span class="s0">// Attach a bunch of functions for handling common AJAX events</span><span class="s1"> 
    jQuery.each( [ 
        </span><span class="s3">&quot;ajaxStart&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;ajaxStop&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;ajaxComplete&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;ajaxError&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;ajaxSuccess&quot;</span><span class="s1">, 
        </span><span class="s3">&quot;ajaxSend&quot;</span><span class="s1"> 
    ], </span><span class="s2">function</span><span class="s1">( i, type ) { 
        jQuery.fn[ type ] = </span><span class="s2">function</span><span class="s1">( fn ) { 
            </span><span class="s2">return this</span><span class="s1">.on( type, fn ); 
        }; 
    } ); 
 
 
 
 
    jQuery.expr.pseudos.animated = </span><span class="s2">function</span><span class="s1">( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.grep( jQuery.timers, </span><span class="s2">function</span><span class="s1">( fn ) { 
            </span><span class="s2">return </span><span class="s1">elem === fn.elem; 
        } ).length; 
    }; 
 
 
 
 
    </span><span class="s0">/** 
     * Gets a window from an element 
     */</span><span class="s1"> 
    </span><span class="s2">function </span><span class="s1">getWindow( elem ) { 
        </span><span class="s2">return </span><span class="s1">jQuery.isWindow( elem ) ? elem : elem.nodeType === </span><span class="s4">9 </span><span class="s1">&amp;&amp; elem.defaultView; 
    } 
 
    jQuery.offset = { 
        setOffset: </span><span class="s2">function</span><span class="s1">( elem, options, i ) { 
            </span><span class="s2">var </span><span class="s1">curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, 
                position = jQuery.css( elem, </span><span class="s3">&quot;position&quot; </span><span class="s1">), 
                curElem = jQuery( elem ), 
                props = {}; 
 
            </span><span class="s0">// Set position first, in-case top/left are set even on static elem</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( position === </span><span class="s3">&quot;static&quot; </span><span class="s1">) { 
                elem.style.position = </span><span class="s3">&quot;relative&quot;</span><span class="s1">; 
            } 
 
            curOffset = curElem.offset(); 
            curCSSTop = jQuery.css( elem, </span><span class="s3">&quot;top&quot; </span><span class="s1">); 
            curCSSLeft = jQuery.css( elem, </span><span class="s3">&quot;left&quot; </span><span class="s1">); 
            calculatePosition = ( position === </span><span class="s3">&quot;absolute&quot; </span><span class="s1">|| position === </span><span class="s3">&quot;fixed&quot; </span><span class="s1">) &amp;&amp; 
                ( curCSSTop + curCSSLeft ).indexOf( </span><span class="s3">&quot;auto&quot; </span><span class="s1">) &gt; -</span><span class="s4">1</span><span class="s1">; 
 
            </span><span class="s0">// Need to be able to calculate position if either</span><span class="s1"> 
            </span><span class="s0">// top or left is auto and position is either absolute or fixed</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( calculatePosition ) { 
                curPosition = curElem.position(); 
                curTop = curPosition.top; 
                curLeft = curPosition.left; 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                curTop = parseFloat( curCSSTop ) || </span><span class="s4">0</span><span class="s1">; 
                curLeft = parseFloat( curCSSLeft ) || </span><span class="s4">0</span><span class="s1">; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( jQuery.isFunction( options ) ) { 
 
                </span><span class="s0">// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)</span><span class="s1"> 
                options = options.call( elem, i, jQuery.extend( {}, curOffset ) ); 
            } 
 
            </span><span class="s2">if </span><span class="s1">( options.top != </span><span class="s2">null </span><span class="s1">) { 
                props.top = ( options.top - curOffset.top ) + curTop; 
            } 
            </span><span class="s2">if </span><span class="s1">( options.left != </span><span class="s2">null </span><span class="s1">) { 
                props.left = ( options.left - curOffset.left ) + curLeft; 
            } 
 
            </span><span class="s2">if </span><span class="s1">( </span><span class="s3">&quot;using&quot; </span><span class="s2">in </span><span class="s1">options ) { 
                options.using.call( elem, props ); 
 
            } </span><span class="s2">else </span><span class="s1">{ 
                curElem.css( props ); 
            } 
        } 
    }; 
 
    jQuery.fn.extend( { 
        offset: </span><span class="s2">function</span><span class="s1">( options ) { 
 
            </span><span class="s0">// Preserve chaining for setter</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( arguments.length ) { 
                </span><span class="s2">return </span><span class="s1">options === undefined ? 
                    </span><span class="s2">this </span><span class="s1">: 
                    </span><span class="s2">this</span><span class="s1">.each( </span><span class="s2">function</span><span class="s1">( i ) { 
                        jQuery.offset.setOffset( </span><span class="s2">this</span><span class="s1">, options, i ); 
                    } ); 
            } 
 
            </span><span class="s2">var </span><span class="s1">docElem, win, rect, doc, 
                elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">]; 
 
            </span><span class="s2">if </span><span class="s1">( !elem ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s0">// Support: IE &lt;=11 only</span><span class="s1"> 
            </span><span class="s0">// Running getBoundingClientRect on a</span><span class="s1"> 
            </span><span class="s0">// disconnected node in IE throws an error</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( !elem.getClientRects().length ) { 
                </span><span class="s2">return </span><span class="s1">{ top: </span><span class="s4">0</span><span class="s1">, left: </span><span class="s4">0 </span><span class="s1">}; 
            } 
 
            rect = elem.getBoundingClientRect(); 
 
            </span><span class="s0">// Make sure element is not hidden (display: none)</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( rect.width || rect.height ) { 
                doc = elem.ownerDocument; 
                win = getWindow( doc ); 
                docElem = doc.documentElement; 
 
                </span><span class="s2">return </span><span class="s1">{ 
                    top: rect.top + win.pageYOffset - docElem.clientTop, 
                    left: rect.left + win.pageXOffset - docElem.clientLeft 
                }; 
            } 
 
            </span><span class="s0">// Return zeros for disconnected and hidden elements (gh-2310)</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">rect; 
        }, 
 
        position: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">if </span><span class="s1">( !</span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">] ) { 
                </span><span class="s2">return</span><span class="s1">; 
            } 
 
            </span><span class="s2">var </span><span class="s1">offsetParent, offset, 
                elem = </span><span class="s2">this</span><span class="s1">[ </span><span class="s4">0 </span><span class="s1">], 
                parentOffset = { top: </span><span class="s4">0</span><span class="s1">, left: </span><span class="s4">0 </span><span class="s1">}; 
 
            </span><span class="s0">// Fixed elements are offset from window (parentOffset = {top:0, left: 0},</span><span class="s1"> 
            </span><span class="s0">// because it is its only offset parent</span><span class="s1"> 
            </span><span class="s2">if </span><span class="s1">( jQuery.css( elem, </span><span class="s3">&quot;position&quot; </span><span class="s1">) === </span><span class="s3">&quot;fixed&quot; </span><span class="s1">) { 
 
                </span><span class="s0">// Assume getBoundingClientRect is there when computed position is fixed</span><span class="s1"> 
                offset = elem.getBoundingClientRect(); 
 
            } </span><span class="s2">else </span><span class="s1">{ 
 
                </span><span class="s0">// Get *real* offsetParent</span><span class="s1"> 
                offsetParent = </span><span class="s2">this</span><span class="s1">.offsetParent(); 
 
                </span><span class="s0">// Get correct offsets</span><span class="s1"> 
                offset = </span><span class="s2">this</span><span class="s1">.offset(); 
                </span><span class="s2">if </span><span class="s1">( !jQuery.nodeName( offsetParent[ </span><span class="s4">0 </span><span class="s1">], </span><span class="s3">&quot;html&quot; </span><span class="s1">) ) { 
                    parentOffset = offsetParent.offset(); 
                } 
 
                </span><span class="s0">// Add offsetParent borders</span><span class="s1"> 
                parentOffset = { 
                    top: parentOffset.top + jQuery.css( offsetParent[ </span><span class="s4">0 </span><span class="s1">], </span><span class="s3">&quot;borderTopWidth&quot;</span><span class="s1">, </span><span class="s2">true </span><span class="s1">), 
                    left: parentOffset.left + jQuery.css( offsetParent[ </span><span class="s4">0 </span><span class="s1">], </span><span class="s3">&quot;borderLeftWidth&quot;</span><span class="s1">, </span><span class="s2">true </span><span class="s1">) 
                }; 
            } 
 
            </span><span class="s0">// Subtract parent offsets and element margins</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">{ 
                top: offset.top - parentOffset.top - jQuery.css( elem, </span><span class="s3">&quot;marginTop&quot;</span><span class="s1">, </span><span class="s2">true </span><span class="s1">), 
                left: offset.left - parentOffset.left - jQuery.css( elem, </span><span class="s3">&quot;marginLeft&quot;</span><span class="s1">, </span><span class="s2">true </span><span class="s1">) 
            }; 
        }, 
 
        </span><span class="s0">// This method will return documentElement in the following cases:</span><span class="s1"> 
        </span><span class="s0">// 1) For the element inside the iframe without offsetParent, this method will return</span><span class="s1"> 
        </span><span class="s0">//    documentElement of the parent window</span><span class="s1"> 
        </span><span class="s0">// 2) For the hidden or detached element</span><span class="s1"> 
        </span><span class="s0">// 3) For body or html element, i.e. in case of the html node - it will return itself</span><span class="s1"> 
        </span><span class="s0">//</span><span class="s1"> 
        </span><span class="s0">// but those exceptions were never presented as a real life use-cases</span><span class="s1"> 
        </span><span class="s0">// and might be considered as more preferable results.</span><span class="s1"> 
        </span><span class="s0">//</span><span class="s1"> 
        </span><span class="s0">// This logic, however, is not guaranteed and can change at any point in the future</span><span class="s1"> 
        offsetParent: </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return this</span><span class="s1">.map( </span><span class="s2">function</span><span class="s1">() { 
                </span><span class="s2">var </span><span class="s1">offsetParent = </span><span class="s2">this</span><span class="s1">.offsetParent; 
 
                </span><span class="s2">while </span><span class="s1">( offsetParent &amp;&amp; jQuery.css( offsetParent, </span><span class="s3">&quot;position&quot; </span><span class="s1">) === </span><span class="s3">&quot;static&quot; </span><span class="s1">) { 
                    offsetParent = offsetParent.offsetParent; 
                } 
 
                </span><span class="s2">return </span><span class="s1">offsetParent || documentElement; 
            } ); 
        } 
    } ); 
 
</span><span class="s0">// Create scrollLeft and scrollTop methods</span><span class="s1"> 
    jQuery.each( { scrollLeft: </span><span class="s3">&quot;pageXOffset&quot;</span><span class="s1">, scrollTop: </span><span class="s3">&quot;pageYOffset&quot; </span><span class="s1">}, </span><span class="s2">function</span><span class="s1">( method, prop ) { 
        </span><span class="s2">var </span><span class="s1">top = </span><span class="s3">&quot;pageYOffset&quot; </span><span class="s1">=== prop; 
 
        jQuery.fn[ method ] = </span><span class="s2">function</span><span class="s1">( val ) { 
            </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( elem, method, val ) { 
                </span><span class="s2">var </span><span class="s1">win = getWindow( elem ); 
 
                </span><span class="s2">if </span><span class="s1">( val === undefined ) { 
                    </span><span class="s2">return </span><span class="s1">win ? win[ prop ] : elem[ method ]; 
                } 
 
                </span><span class="s2">if </span><span class="s1">( win ) { 
                    win.scrollTo( 
                        !top ? val : win.pageXOffset, 
                        top ? val : win.pageYOffset 
                    ); 
 
                } </span><span class="s2">else </span><span class="s1">{ 
                    elem[ method ] = val; 
                } 
            }, method, val, arguments.length ); 
        }; 
    } ); 
 
</span><span class="s0">// Support: Safari &lt;=7 - 9.1, Chrome &lt;=37 - 49</span><span class="s1"> 
</span><span class="s0">// Add the top/left cssHooks using jQuery.fn.position</span><span class="s1"> 
</span><span class="s0">// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084</span><span class="s1"> 
</span><span class="s0">// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347</span><span class="s1"> 
</span><span class="s0">// getComputedStyle returns percent when specified for top/left/bottom/right;</span><span class="s1"> 
</span><span class="s0">// rather than make the css module depend on the offset module, just check for it here</span><span class="s1"> 
    jQuery.each( [ </span><span class="s3">&quot;top&quot;</span><span class="s1">, </span><span class="s3">&quot;left&quot; </span><span class="s1">], </span><span class="s2">function</span><span class="s1">( i, prop ) { 
        jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition, 
            </span><span class="s2">function</span><span class="s1">( elem, computed ) { 
                </span><span class="s2">if </span><span class="s1">( computed ) { 
                    computed = curCSS( elem, prop ); 
 
                    </span><span class="s0">// If curCSS returns percentage, fallback to offset</span><span class="s1"> 
                    </span><span class="s2">return </span><span class="s1">rnumnonpx.test( computed ) ? 
                    jQuery( elem ).position()[ prop ] + </span><span class="s3">&quot;px&quot; </span><span class="s1">: 
                        computed; 
                } 
            } 
        ); 
    } ); 
 
 
</span><span class="s0">// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods</span><span class="s1"> 
    jQuery.each( { Height: </span><span class="s3">&quot;height&quot;</span><span class="s1">, Width: </span><span class="s3">&quot;width&quot; </span><span class="s1">}, </span><span class="s2">function</span><span class="s1">( name, type ) { 
        jQuery.each( { padding: </span><span class="s3">&quot;inner&quot; </span><span class="s1">+ name, content: type, </span><span class="s3">&quot;&quot;</span><span class="s1">: </span><span class="s3">&quot;outer&quot; </span><span class="s1">+ name }, 
            </span><span class="s2">function</span><span class="s1">( defaultExtra, funcName ) { 
 
                </span><span class="s0">// Margin is only for outerHeight, outerWidth</span><span class="s1"> 
                jQuery.fn[ funcName ] = </span><span class="s2">function</span><span class="s1">( margin, value ) { 
                    </span><span class="s2">var </span><span class="s1">chainable = arguments.length &amp;&amp; ( defaultExtra || </span><span class="s2">typeof </span><span class="s1">margin !== </span><span class="s3">&quot;boolean&quot; </span><span class="s1">), 
                        extra = defaultExtra || ( margin === </span><span class="s2">true </span><span class="s1">|| value === </span><span class="s2">true </span><span class="s1">? </span><span class="s3">&quot;margin&quot; </span><span class="s1">: </span><span class="s3">&quot;border&quot; </span><span class="s1">); 
 
                    </span><span class="s2">return </span><span class="s1">access( </span><span class="s2">this</span><span class="s1">, </span><span class="s2">function</span><span class="s1">( elem, type, value ) { 
                        </span><span class="s2">var </span><span class="s1">doc; 
 
                        </span><span class="s2">if </span><span class="s1">( jQuery.isWindow( elem ) ) { 
 
                            </span><span class="s0">// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)</span><span class="s1"> 
                            </span><span class="s2">return </span><span class="s1">funcName.indexOf( </span><span class="s3">&quot;outer&quot; </span><span class="s1">) === </span><span class="s4">0 </span><span class="s1">? 
                                elem[ </span><span class="s3">&quot;inner&quot; </span><span class="s1">+ name ] : 
                                elem.document.documentElement[ </span><span class="s3">&quot;client&quot; </span><span class="s1">+ name ]; 
                        } 
 
                        </span><span class="s0">// Get document width or height</span><span class="s1"> 
                        </span><span class="s2">if </span><span class="s1">( elem.nodeType === </span><span class="s4">9 </span><span class="s1">) { 
                            doc = elem.documentElement; 
 
                            </span><span class="s0">// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],</span><span class="s1"> 
                            </span><span class="s0">// whichever is greatest</span><span class="s1"> 
                            </span><span class="s2">return </span><span class="s1">Math.max( 
                                elem.body[ </span><span class="s3">&quot;scroll&quot; </span><span class="s1">+ name ], doc[ </span><span class="s3">&quot;scroll&quot; </span><span class="s1">+ name ], 
                                elem.body[ </span><span class="s3">&quot;offset&quot; </span><span class="s1">+ name ], doc[ </span><span class="s3">&quot;offset&quot; </span><span class="s1">+ name ], 
                                doc[ </span><span class="s3">&quot;client&quot; </span><span class="s1">+ name ] 
                            ); 
                        } 
 
                        </span><span class="s2">return </span><span class="s1">value === undefined ? 
 
                            </span><span class="s0">// Get width or height on the element, requesting but not forcing parseFloat</span><span class="s1"> 
                            jQuery.css( elem, type, extra ) : 
 
                            </span><span class="s0">// Set width or height on the element</span><span class="s1"> 
                            jQuery.style( elem, type, value, extra ); 
                    }, type, chainable ? margin : undefined, chainable ); 
                }; 
            } ); 
    } ); 
 
 
    jQuery.fn.extend( { 
 
        bind: </span><span class="s2">function</span><span class="s1">( types, data, fn ) { 
            </span><span class="s2">return this</span><span class="s1">.on( types, </span><span class="s2">null</span><span class="s1">, data, fn ); 
        }, 
        unbind: </span><span class="s2">function</span><span class="s1">( types, fn ) { 
            </span><span class="s2">return this</span><span class="s1">.off( types, </span><span class="s2">null</span><span class="s1">, fn ); 
        }, 
 
        delegate: </span><span class="s2">function</span><span class="s1">( selector, types, data, fn ) { 
            </span><span class="s2">return this</span><span class="s1">.on( types, selector, data, fn ); 
        }, 
        undelegate: </span><span class="s2">function</span><span class="s1">( selector, types, fn ) { 
 
            </span><span class="s0">// ( namespace ) or ( selector, types [, fn] )</span><span class="s1"> 
            </span><span class="s2">return </span><span class="s1">arguments.length === </span><span class="s4">1 </span><span class="s1">? 
                </span><span class="s2">this</span><span class="s1">.off( selector, </span><span class="s3">&quot;**&quot; </span><span class="s1">) : 
                </span><span class="s2">this</span><span class="s1">.off( types, selector || </span><span class="s3">&quot;**&quot;</span><span class="s1">, fn ); 
        } 
    } ); 
 
    jQuery.parseJSON = JSON.parse; 
 
 
 
 
</span><span class="s0">// Register as a named AMD module, since jQuery can be concatenated with other</span><span class="s1"> 
</span><span class="s0">// files that may use define, but not via a proper concatenation script that</span><span class="s1"> 
</span><span class="s0">// understands anonymous AMD modules. A named AMD is safest and most robust</span><span class="s1"> 
</span><span class="s0">// way to register. Lowercase jquery is used because AMD module names are</span><span class="s1"> 
</span><span class="s0">// derived from file names, and jQuery is normally delivered in a lowercase</span><span class="s1"> 
</span><span class="s0">// file name. Do this after creating the global so that if an AMD module wants</span><span class="s1"> 
</span><span class="s0">// to call noConflict to hide this version of jQuery, it will work.</span><span class="s1"> 
 
</span><span class="s0">// Note that for maximum portability, libraries that are not jQuery should</span><span class="s1"> 
</span><span class="s0">// declare themselves as anonymous modules, and avoid setting a global if an</span><span class="s1"> 
</span><span class="s0">// AMD loader is present. jQuery is a special case. For more information, see</span><span class="s1"> 
</span><span class="s0">// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon</span><span class="s1"> 
 
    </span><span class="s2">if </span><span class="s1">( </span><span class="s2">typeof </span><span class="s1">define === </span><span class="s3">&quot;function&quot; </span><span class="s1">&amp;&amp; define.amd ) { 
        define( </span><span class="s3">&quot;jquery&quot;</span><span class="s1">, [], </span><span class="s2">function</span><span class="s1">() { 
            </span><span class="s2">return </span><span class="s1">jQuery; 
        } ); 
    } 
 
 
 
 
    </span><span class="s2">var</span><span class="s1"> 
 
    </span><span class="s0">// Map over jQuery in case of overwrite</span><span class="s1"> 
        _jQuery = window.jQuery, 
 
    </span><span class="s0">// Map over the $ in case of overwrite</span><span class="s1"> 
        _$ = window.$; 
 
    jQuery.noConflict = </span><span class="s2">function</span><span class="s1">( deep ) { 
        </span><span class="s2">if </span><span class="s1">( window.$ === jQuery ) { 
            window.$ = _$; 
        } 
 
        </span><span class="s2">if </span><span class="s1">( deep &amp;&amp; window.jQuery === jQuery ) { 
            window.jQuery = _jQuery; 
        } 
 
        </span><span class="s2">return </span><span class="s1">jQuery; 
    }; 
 
</span><span class="s0">// Expose jQuery and $ identifiers, even in AMD</span><span class="s1"> 
</span><span class="s0">// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)</span><span class="s1"> 
</span><span class="s0">// and CommonJS for browser emulators (#13566)</span><span class="s1"> 
    </span><span class="s2">if </span><span class="s1">( !noGlobal ) { 
        window.jQuery = window.$ = jQuery; 
    } 
 
 
 
 
 
    </span><span class="s2">return </span><span class="s1">jQuery; 
} ); 
</span></pre>
</body>
</html>